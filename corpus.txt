
Become an associate member   before August 7th!  
 
 
Bash is the GNU Project's shell.  Bash is the Bourne Again SHell.
Bash is an sh-compatible shell that
incorporates useful features from the Korn shell (ksh) and C shell
(csh).  It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2
Shell and Tools standard.  It offers functional improvements over sh
for both programming and interactive use.  In addition, most sh scripts
can be run by Bash without modification. The improvements offered by Bash include: The maintainer also has a   which
includes  . Bash
can be found on the main GNU ftp server:
 
(via HTTP) and
 
(via FTP).  It can also be found
on the  ;
please
  if possible. 
is available online, as
is  .  You may
also find more information about
Bash
by running
 
or
 ,
or by looking at
 ,
 ,
or similar directories on your system.  A brief summary is available by
running  . 
To ask for help about bash, bash programming or bash shell scripting
please use the
 
mailing list.  To report bugs or to discuss most aspects of developing
bash please use the
 
mailing list. Announcements about
Bash
and most other GNU software are made on
 . To subscribe to these or any GNU mailing lists, please send an empty
mail with a Subject: header of just   to the relevant
-request list.  For example, to subscribe yourself to the GNU
announcement list, you would send mail to  .
Or you can use the  . Development of
Bash,
and GNU in general, is a volunteer effort, and you can contribute.  For
information, please read  .  If you'd
like to get involved, it's a good idea to join the discussion mailing
list (see above). Bash
is free software; you can redistribute it and/or modify it under the
terms of the   as published by the Free
Software Foundation; either version 3 of the License, or (at your
option) any later version. Please send general FSF & GNU inquiries to
 .
There are also  
the FSF.  Broken links and other corrections or suggestions can be sent
to  . Please see the   for information on coordinating and submitting translations
of this article. Copyright © 2007, 2009, 2011, 2014 Free Software Foundation, Inc. This page is licensed under a  . Updated:
  timestamp start  
$Date: 2017/12/15 10:46:14 $
  timestamp end  
 
  or simply   is a   and   written by   for the   as a   replacement for the  .  First released in 1989,  it has been used as the default   shell for most   distributions and all releases of     prior to  .  A version  .  It is also the default user shell in   11. 
 Bash is a   that typically runs in a   where the user types commands that cause actions. Bash can also read and execute commands from a file, called a  . Like all Unix shells, it supports filename   (wildcard matching),  ,  ,  ,  , and   for   and  . The  ,  ,   variables and other basic features of the   are all copied from  . Other features, e.g.,  , are copied from   and  . Bash is a  -compliant shell, but with a number of extensions.
 The shell's name is an acronym for  , a   on the name of the   that it replaces  and the notion of being " ". 
 A   in Bash dating from version 1.03 (August 1989),  dubbed  , was discovered in early September 2014 and quickly led to a range of   across the  .  Patches to fix the bugs were made available soon after the bugs were identified.
  began   Bash on January 10, 1988,  after   became dissatisfied with the lack of progress being made by a prior developer.  Stallman and the   (FSF) considered a free shell that could run existing shell scripts so strategic to a completely free system built from BSD and GNU code that this was one of the few projects they funded themselves, with Fox undertaking the work as an employee of FSF.  Fox released Bash as a beta, version .99, on June 8, 1989,  and remained the primary maintainer until sometime between mid-1992  and mid-1994,  when he was laid off from FSF  and his responsibility was transitioned to another early contributor, Chet Ramey. 
 Since then, Bash has become by far the most popular shell among users of Linux, becoming the default interactive shell on that operating system's various distributions  (although   may be the default scripting shell) and on Apple's macOS releases before   in October 2019.  Bash has also been ported to   and distributed with   and  , to   by the   project, to   and to   via various terminal emulation applications.
 In September 2014, Stéphane Chazelas, a Unix/Linux specialist,  discovered a   in the program. The bug, first disclosed on September 24, was named   and assigned the numbers  - , CVE-  and CVE- . The bug was regarded as severe, since   scripts using Bash could be vulnerable, enabling  . The bug was related to how Bash passes function definitions to subshells through  . 
 The Bash   syntax is a   of the Bourne shell command syntax. Bash supports  ,   (Programmable Completion).  basic debugging  and   (using  ) since bash 2.05a  among other features. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc. Bash command syntax includes ideas drawn from the   (ksh) and the   (csh) such as command line editing,   (  command),  the directory stack, the   and   variables, and POSIX   syntax  .
 When a user presses the   within an interactive command-shell, Bash automatically uses  , since beta version 2.04,  to match partly typed program names, filenames and variable names. The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.
 Bash's syntax has many extensions lacking in the Bourne shell. Bash can perform integer calculations ("arithmetic evaluation") without spawning external processes. It uses the   command and the   variable syntax for this purpose. Its syntax simplifies  . For example, it can redirect   (stdout) and   (stderr) at the same time using the   operator. This is simpler to type than the Bourne shell equivalent ' '. Bash supports   using the   and  syntax, which substitutes the output of (or input to) a command where a filename is normally used. (This is implemented through   unnamed pipes on systems that support that, or via temporary   where necessary).
 When using the 'function' keyword, Bash function declarations are not compatible with Bourne/Korn/POSIX scripts (the Korn shell has the same problem when using 'function'), but Bash accepts the same function declaration syntax as the Bourne and Korn shells, and is POSIX-conformant. Because of these and other differences, Bash shell scripts are rarely runnable under the Bourne or Korn shell interpreters unless deliberately written with that compatibility in mind, which is becoming less common as Linux becomes more widespread. But in POSIX mode, Bash conforms with POSIX more closely. 
 Bash supports  . Since version 2.05b Bash can redirect   (stdin) from a "here string" using the   operator.
 Bash 3.0 supports in-process   matching using a syntax reminiscent of  . 
 In February 2009,  Bash 4.0 introduced support for  .  Associative array indices are strings, in a manner similar to   or  .>  They can be used to emulate multidimensional arrays. Bash 4 also switches its license to  ; some users suspect this licensing change is why MacOS continues to use older versions. 
 Brace expansion, also called alternation, is a feature copied from the  . It generates a set of alternative combinations. Generated results need not exist as files. The results of each expanded string are not sorted and left to right order is preserved:
 Users should not use brace expansions in portable shell scripts, because the   does not produce the same output.
 When brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally. Hence, a listing of JPEG and PNG images in the current directory could be obtained using:
 In addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots. Newer versions of Bash allow a third integer to specify the increment.
 When brace expansion is combined with variable expansion the variable expansion is performed   the brace expansion, which in some cases may necessitate the use of the   built-in, thus:
 When Bash starts, it executes the commands in a variety of  . Though similar to Bash shell script commands, which have execute permission enabled and an   like  , the initialization files used by Bash require neither.
 The skeleton   below is compatible with the Bourne shell and gives semantics similar to csh for the   and  . The   are tests to see if the   exists and is readable, simply skipping the part after the   if it is not.
 Some versions of   and   contain Bash system startup scripts, generally under the   directories. Bash calls these as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence. The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup. The startup scripts that launch the   may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the  . These issues can often be addressed using a   or   file to read the   — which provides the environment variables that Bash shell windows spawned from the window manager need, such as   or  .
 Invoking Bash with the   option or stating   in a script causes Bash to conform very closely to the  .  Bash shell scripts intended for   should take into account at least the POSIX shell standard. Some bash features not found in POSIX are: 
 If a piece of code uses such a feature, it is called a "bashism" – a problem for portable use. Debian's   and Vidar Holen's   can be used to make sure that a script does not contain these parts.  The list varies depending on the actual target shell: Debian's policy allows some extensions in their scripts (as they are in  ),  while a script intending to support pre-POSIX Bourne shells, like  's  , are even more limited in the features they can use. 
 Bash uses readline to provide keyboard shortcuts for command line editing using the default ( ) key bindings.   can be enabled by running  . 
 The Bash shell has two modes of execution for commands:  , and concurrent mode.
 To execute commands in batch (i.e., in sequence) they must be separated by the character ";", or on separate lines:
 in this example, when command1 is finished, command2 is executed.
 A [Background process|background execution] of command1 can occur using (symbol &) at the end of an execution command, and process will be executed in background returning immediately control to the shell and allowing continued execution of commands.
 Or to have a concurrent execution of two command1 and command2, they must be executed in the Bash shell in the following way:
 In this case command1 is executed in the background   symbol, returning immediately control to the shell that executes command2 in the foreground.
 A process can be stopped and control returned to bash by typing  +  while the process is running in the foreground. 
 A list of all processes, both in the background and stopped, can be achieved by running  :
 In the output, the number in brackets refers to the job id. The plus sign signifies the default process for   and  . The text "Running" and "Stopped" refer to the  . The last string is the command that started the process. 
 The state of a process can be changed using various commands. The   command brings a process to the foreground, while   sets a stopped process running in the background.   and   can take a job id as their first argument, to specify the process to act on. Without one, they use the default process, identified by a plus sign in the output of  . The   command can be used to end a process prematurely, by sending it a  . The job id must be specified after a percent sign:
 Bash supplies "conditional execution" command separators that make execution of a command contingent on the   set by a precedent command. For example:
 Where   is only executed if the   (change directory) command was "successful" (returned an exit status of zero) and the   command would only be executed if either the   or the   command return an "error" (non-zero exit status).
 For all commands the exit status is stored in the special variable  . Bash also supports   and   forms of conditional command evaluation.
 An external command called   reports Bash shell bugs. When the command is invoked, it brings up the user's default editor with a form to fill in. The form is mailed to the Bash maintainers (or optionally to other email addresses). 
 Bash programmable completion,   and   commands  have been available since the beta version of 2.04  in 2000.  These facilities allow complex intelligent completion, such as offering to tab-complete available program options and then, after the user selects an option that requires a filename as its next input, only auto-completing file paths (and not other options) for the next token.
 bash - GNU Bourne-Again SHell
 
  [options] [file]
 
 Bash is Copyright © 1989-2009 by the Free Software Foundation, Inc.
 
 
  is an  -compatible command language interpreter that executes commands read from the standard input or from a file.   also
incorporates useful features from the   and   shells (  and  ).
  is intended to be a conformant implementation of the Shell and Utilities portion of the IEEE POSIX specification (IEEE Standard 1003.1).
  can be configured to be POSIX-conformant by default.
 
 In addition to the single-character shell options documented in the description of the   builtin command,   interprets the following
options when it is invoked:
 If the   option is present, then commands are read from  . If there are arguments after the  , they are assigned to the
positional parameters, starting with  .

 
 If the   option is present, the shell is  .

 
 Make   act as if it had been invoked as a login shell (see   below).

 
 If the   option is present, the shell becomes   (see   below).

 
 If the   option is present, or if no arguments remain after option processing, then commands are read from the standard input. This option allows
the positional parameters to be set when invoking an interactive shell.

 
 A list of all double-quoted strings preceded by   is printed on the standard output. These are the strings that are subject to language translation
when the current locale is not   or  . This implies the   option; no commands will be executed.
 A   signals the end of options and disables further option processing. Any arguments after the   are treated as filenames and arguments. An
argument of   is equivalent to  .
 Display a usage message on standard output and exit successfully.
 Do not read and execute the personal initialization file   if the shell is interactive. This option is on by default if the shell is invoked
as  .
 
 
 If arguments remain after option processing, and neither the   nor the   option has been supplied, the first argument is assumed to be the
name of a file containing shell commands. If   is invoked in this fashion,   is set to the name of the file, and the positional parameters
are set to the remaining arguments.   reads and executes commands from this file, then exits.  's exit status is the exit status of the
last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory,
and, if no file is found, then the shell searches the directories in   for the script.
 
 A   is one whose first character of argument zero is a  , or one started with the   option.
 An   shell is one started without non-option arguments and without the   option whose standard input and error are both connected
to terminals (as determined by  (3)), or one started with the   option.   is set and   includes   if
  is interactive, allowing a shell script or a startup file to test this state.
 The following paragraphs describe how   executes its startup files. If any of the files exist but cannot be read,   reports an error.
Tildes are expanded in file names as described below under   in the   section.
 When   is invoked as an interactive login shell, or as a non-interactive shell with the   option, it first reads and executes
commands from the file  , if that file exists. After reading that file, it looks for  ,  , and
 , in that order, and reads and executes commands from the first one that exists and is readable. The   option may be used
when the shell is started to inhibit this behavior.
 When a login shell exits,   reads and executes commands from the files   and  , if the files
exists.
 When an interactive shell that is not a login shell is started,   reads and executes commands from  , if that file exists. This may
be inhibited by using the   option. The     option will force   to read and execute commands from  
instead of  .
 When   is started non-interactively, to run a shell script, for example, it looks for the variable   in the
environment, expands its value if it appears there, and uses the expanded value as the name of a file to read and execute.   behaves as if the
following command were executed:
 If   is invoked with the name  , it tries to mimic the startup behavior of historical versions of   as closely as possible, while
conforming to the POSIX standard as well. When invoked as an interactive login shell, or a non-interactive shell with the   option, it first
attempts to read and execute commands from   and  , in that order. The   option may be used to inhibit this
behavior. When invoked as an interactive shell with the name  ,   looks for the variable   expands
its value if it is defined, and uses the expanded value as the name of a file to read and execute. Since a shell invoked as   does not attempt to read
and execute commands from any other startup files, the   option has no effect. A non-interactive shell invoked with the name   does not
attempt to read any other startup files. When invoked as  ,   enters   mode after the startup files are read.
 When   is started in   mode, as with the   command line option, it follows the POSIX standard for startup files. In this
mode, interactive shells expand the   variable and commands are read and executed from the file whose name is the expanded value. No
other startup files are read.
  attempts to determine when it is being run with its standard input connected to a a network connection, as if by the remote shell daemon,
usually  , or the secure shell daemon  . If   determines it is being run in this fashion, it reads and executes commands from
 , if that file exists and is readable. It will not do this if invoked as  . The   option may be used to inhibit this
behavior, and the   option may be used to force another file to be read, but   does not generally invoke the shell with those options
or allow them to be specified.
 If the shell is started with the effective user (group) id not equal to the real user (group) id, and the   option is not supplied, no startup files
are read, shell functions are not inherited from the environment, the   and
  variables, if they appear in the environment, are ignored, and the effective user id is set to the real user id. If the
  option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset.
 
 
 The following definitions are used throughout the rest of this document.
 A space or tab.

 
 A sequence of characters considered as a single unit by the shell. Also known as a  .

 
 A   consisting only of alphanumeric characters and underscores, and beginning with an alphabetic character or an underscore. Also referred to as
an  .
 
 
  are words that have a special meaning to the shell. The following words are recognized as reserved when unquoted and either the first
word of a simple command (see   below) or the third word of a   or   command:
 
 
 
 The return value of a   is its exit status, or 128+  if the command is terminated by signal  .
 
 
 The return status of a pipeline is the exit status of the last command, unless the   option is enabled. If   is enabled, the
pipeline's return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. If the
reserved word   precedes a pipeline, the exit status of that pipeline is the logical negation of the exit status as described above. The shell waits for
all commands in the pipeline to terminate before returning a value.
 If the   reserved word precedes a pipeline, the elapsed as well as user and system time consumed by its execution are reported when the pipeline
terminates. The   option changes the output format to that specified by POSIX. The   variable may be set to a format
string that specifies how the timing information should be displayed; see the description of   under  
below.
 Each command in a pipeline is executed as a separate process (i.e., in a subshell).
 
 
 Of these list operators,   and   have equal precedence, followed by   and  , which have equal precedence.

 A sequence of one or more newlines may appear in a   instead of a semicolon to delimit commands.
 If a command is terminated by the control operator  , the shell executes the command in the   in a subshell. The shell does not
wait for the command to finish, and the return status is 0. Commands separated by a   are executed sequentially; the shell waits for each command to
terminate in turn. The return status is the exit status of the last command executed.
 AND and OR lists are sequences of one of more pipelines separated by the   and   control operators, respectively. AND and OR lists
are executed with left associativity. An AND list has the form
 An OR list has the form
 
 
  is executed in a subshell environment (see   below). Variable assignments and builtin commands
that affect the shell's environment do not remain in effect after the command completes. The return status is the exit status of  .
 When used with  , The   and   operators sort lexicographically using the current locale.
 When the   and   operators are used, the string to the right of the operator is considered a pattern and matched according to the rules
described below under  . If the shell option   is enabled, the match is performed without regard to the case of
alphabetic characters. The return value is 0 if the string matches ( ) or does not match ( ) the pattern, and 1 otherwise. Any part of the
pattern may be quoted to force it to be matched as a string.
 An additional binary operator,  , is available, with the same precedence as   and  . When it is used, the string to the right of the
operator is considered an extended regular expression and matched accordingly (as in  (3)). The return value is 0 if the string matches the pattern,
and 1 otherwise. If the regular expression is syntactically incorrect, the conditional expression's return value is 2. If the shell option  
is enabled, the match is performed without regard to the case of alphabetic characters. Any part of the pattern may be quoted to force it to be matched as a
string. Substrings matched by parenthesized subexpressions within the regular expression are saved in the array variable
  The element of   with index 0 is the portion of the string matching the
entire regular expression. The element of   with index   is the portion of the string matching the  th
parenthesized subexpression.
 Expressions may be combined using the following operators, listed in decreasing order of precedence:
 
 Returns the value of  . This may be used to override the normal precedence of operators.
 
 True if   is false.
 
 True if both   and   are true.
 
 True if either   or   is true.
 
 
 The format for a coprocess is:
 The return status of a coprocess is the exit status of  .
 
 
 
 
 In a non-interactive shell, or an interactive shell in which the   option to the   builtin is enabled (see
  below), a word beginning with   causes that word and all remaining characters on that line to be ignored.
An interactive shell without the   option enabled does not allow comments. The   option is on by default in
interactive shells.
 
  is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for
special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion.
 Each of the   listed above under   has special meaning to the shell and must be quoted if it is to
represent itself.
 When the command history expansion facilities are being used (see   below), the   character,
usually  , must be quoted to prevent history expansion.
 There are three quoting mechanisms: the  , single quotes, and double quotes.
 A non-quoted backslash ( ) is the  . It preserves the literal value of the next character that follows, with the exception of
<newline>. If a  <newline> pair appears, and the backslash is not itself quoted, the  <newline> is treated as a line
continuation (that is, it is removed from the input stream and effectively ignored).
 Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may not occur between single quotes,
even when preceded by a backslash.
 Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of  ,  ,  ,
and, when history expansion is enabled,  . The characters   and   retain their special meaning within double quotes. The backslash retains
its special meaning only when followed by one of the following characters:  ,  ,  ,  , or  . A double quote
may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an   appearing in double
quotes is escaped using a backslash. The backslash preceding the   is not removed.
 The special parameters   and   have special meaning when in double quotes (see   below).
 Words of the form  ' ' are treated specially. The word expands to  , with backslash-escaped characters replaced as specified
by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows:
 alert (bell)

 
 backspace

 
 
 an escape character

 
 form feed

 
 new line

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 backslash

 
 single quote

 
 double quote

 
 the eight-bit character whose value is the octal value   (one to three digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)

 
 a control-  character
 A double-quoted string preceded by a dollar sign ( " ") will cause the string to be translated according to the current locale. If the
current locale is   or  , the dollar sign is ignored. If the string is translated and replaced, the replacement is
double-quoted.
 
 
 A   is an entity that stores values. It can be a  , a number, or one of the special characters listed below under  . A   is a parameter denoted by a  . A variable has a   and zero or more  . Attributes are
assigned using the   builtin command (see   below in  
 A parameter is set if it has been assigned a value. The null string is a valid value. Once a variable is set, it may be unset only by using the  
builtin command (see   below).
 A   may be assigned to by a statement of the form
 In the context where an assignment statement is assigning a value to a shell variable or array index, the += operator can be used to append to or add to the
variable's previous value. When += is applied to a variable for which the integer attribute has been set,   is evaluated as an arithmetic expression
and added to the variable's current value, which is also evaluated. When += is applied to an array variable using compound assignment (see  
below), the variable's value is not unset (as it is when using =), and new values are appended to the array beginning at one greater than the array's maximum
index (for indexed arrays) or added as additional key-value pairs in an associative array. When applied to a string-valued variable,   is expanded
and appended to the variable's value.
 
 
 When a positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces (see  
below).
 
 
 Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, it expands to a single word with the value of each
parameter separated by the first character of the   special variable. That is, " " is equivalent to
" ", where   is the first character of the value of the   variable. If
  is unset, the parameters are separated by spaces. If   is null, the parameters are joined without intervening
separators.

 
 Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, each parameter expands to a separate word. That is,
" " is equivalent to " " " " ... If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined
with the beginning part of the original word, and the expansion of the last parameter is joined with the last part of the original word. When there are no
positional parameters, " " and   expand to nothing (i.e., they are removed).

 
 Expands to the number of positional parameters in decimal.

 
 Expands to the exit status of the most recently executed foreground pipeline.

 
 Expands to the current option flags as specified upon invocation, by the   builtin command, or those set by the shell itself (such as the  
option).

 
 Expands to the process ID of the shell. In a () subshell, it expands to the process ID of the current shell, not the subshell.

 
 Expands to the process ID of the most recently executed background (asynchronous) command.

 
 Expands to the name of the shell or shell script. This is set at shell initialization. If   is invoked with a file of commands,   is set
to the name of that file. If   is started with the   option, then   is set to the first argument after the string to be executed, if
one is present. Otherwise, it is set to the file name used to invoke  , as given by argument zero.

 
 At shell startup, set to the absolute pathname used to invoke the shell or shell script being executed as passed in the environment or argument list.
Subsequently, expands to the last argument to the previous command, after expansion. Also set to the full pathname used to invoke each command executed and
placed in the environment exported to that command. When checking mail, this parameter holds the name of the mail file currently being checked.
 
 
 Expands to the full file name used to invoke this instance of  .
 The major version number (the  ).

 1 
 The minor version number (the  ).

 2 
 The patch level.

 3 
 The build version.

 4 
 The release status (e.g.,  ).

 5 
 The value of  
 Expands to the effective user ID of the current user, initialized at shell startup. This variable is readonly.
 An array variable containing the list of groups of which the current user is a member. Assignments to   have no effect and return
an error status. If   is unset, it loses its special properties, even if it is subsequently reset.
 Each time this parameter is referenced, the shell substitutes a decimal number representing the current sequential line number (starting with 1) within a
script or function. When not in a script or function, the value substituted is not guaranteed to be meaningful. If   is unset, it
loses its special properties, even if it is subsequently reset.
 The previous working directory as set by the   command.

 
 The value of the last option argument processed by the   builtin command (see   below).

 
 The index of the next argument to be processed by the   builtin command (see   below).

 
 Automatically set to a string that describes the operating system on which   is executing. The default is system-dependent.
 The process ID of the shell's parent. This variable is readonly.

 
 The current working directory as set by the   command.

 
 Each time this parameter is referenced, a random integer between 0 and 32767 is generated. The sequence of random numbers may be initialized by assigning a
value to   If   is unset, it loses its special properties, even if it is subsequently
reset.

 
 Set to the line of input read by the   builtin command when no arguments are supplied.
 Incremented by one each time an instance of   is started.

 
 Expands to the user ID of the current user, initialized at shell startup. This variable is readonly.
 The search path for the   command. This is a colon-separated list of directories in which the shell looks for destination directories specified by
the   command. A sample value is ".:~:/usr".
 If   finds this variable in the environment when the shell starts with value "t", it assumes that the shell is running in an emacs shell buffer
and disables line editing.

 
 The default editor for the   builtin command.
 The home directory of the current user; the default argument for the   builtin command. The value of this variable is also used when performing
tilde expansion.
 The   that is used for word splitting after expansion and to split lines into words with the   builtin command. The
default value is ''<space><tab><newline>''.
 Used to determine the locale category for any category not specifically selected with a variable starting with  .

 
 This variable overrides the value of   and any other   variable specifying a locale category.
 Used by the   builtin command to determine the column length for printing selection lists. Automatically set upon receipt of a
 
 
 If this parameter is set to a file name and the   variable is not set,   informs the user of the arrival of mail in
the specified file.
 If set to the value 1,   displays error messages generated by the   builtin command (see  
below).   is initialized to 1 each time the shell is invoked or a shell script is executed.

 
 The search path for commands. It is a colon-separated list of directories in which the shell looks for commands (see  
below). A zero-length (null) directory name in the value of   indicates the current directory. A null directory name may appear as two
adjacent colons, or as an initial or trailing colon. The default path is system-dependent, and is set by the administrator who installs  . A common
value is ''/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
 The value of this parameter is expanded (see   below) and used as the primary prompt string. The default value is
''  ''.

 
 The value of this parameter is expanded as with   and used as the secondary prompt string. The default is ''  ''.

 
 The value of this parameter is used as the prompt for the   command (see   above).

 
 The value of this parameter is expanded as with   and the value is printed before each command   displays during an
execution trace. The first character of   is replicated multiple times, as necessary, to indicate multiple levels of indirection. The
default is ''  ''.

 
 The full pathname to the shell is kept in this environment variable. If it is not set when the shell starts,   assigns to it the full pathname of
the current user's login shell.
 A literal  .

 
 The elapsed time in seconds.

 
 The number of CPU seconds spent in user mode.

 
 The number of CPU seconds spent in system mode.

 
 The CPU percentage, computed as (%U + %S) / %R.
 The optional   specifies a longer format, including minutes, of the form  m . s. The value of   determines whether or
not the fraction is included.
 If this variable is not set,   acts as if it had the value  . If the value is null, no timing
information is displayed. A trailing newline is added when the format string is displayed.
 If set to a value greater than zero,   is treated as the default timeout for the   builtin. The   command
terminates if input does not arrive after   seconds when input is coming from a terminal. In an interactive shell, the value is
interpreted as the number of seconds to wait for input after issuing the primary prompt.   terminates after waiting for that number of seconds if
input does not arrive.

 
 If set,   uses its value as the name of a directory in which   creates temporary files for the shell's use.
 
 
 An indexed array is created automatically if any variable is assigned to using the syntax  [ ]= . The  
is treated as an arithmetic expression that must evaluate to a number greater than or equal to zero. To explicitly declare an indexed array, use     (see   below).     is also accepted;
the   is ignored.
 Associative arrays are created using    .
 Attributes may be specified for an array variable using the   and   builtins. Each attribute applies to all members of an array.

 Arrays are assigned to using compound assignments of the form  = value  ... value , where each   is of the
form [ ]= . Indexed array assignments do not require the bracket and subscript. When assigning to indexed arrays, if the optional
brackets and subscript are supplied, that index is assigned to; otherwise the index of the element assigned is the last index assigned to by the statement plus
one. Indexing starts at zero.
 When assigning to an associative array, the subscript is required.
 This syntax is also accepted by the   builtin. Individual array elements may be assigned to using the
 [ ]=  syntax introduced above.
 Any element of an array may be referenced using ${ [ ]}. The braces are required to avoid conflicts with pathname expansion. If
  is   or  , the word expands to all members of  . These subscripts differ only when the word appears within double
quotes. If the word is double-quoted, ${ [*]} expands to a single word with the value of each array member separated by the first character of the
  special variable, and ${ [@]} expands each element of   to a separate word. When there are no array members,
${ [@]} expands to nothing. If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined with the beginning
part of the original word, and the expansion of the last parameter is joined with the last part of the original word. This is analogous to the expansion of the
special parameters   and   (see   above). ${# [ ]} expands to the length of
${ [ ]}. If   is   or  , the expansion is the number of elements in the array. Referencing an array
variable without a subscript is equivalent to referencing the array with a subscript of 0.
 An array variable is considered set if a subscript has been assigned a value. The null string is a valid value.
 The   builtin is used to destroy arrays.    [ ] destroys the array element at index  . Care
must be taken to avoid unwanted side effects caused by pathname expansion.    , where   is an array, or  
 [ ], where   is   or  , removes the entire array.
 The  ,  , and   builtins each accept a   option to specify an indexed array and a   option to specify
an associative array. The   builtin accepts a   option to assign a list of words read from the standard input to an array. The   and
  builtins display array values in a way that allows them to be reused as assignments.
 
 
 Expansion is performed on the command line after it has been split into words. There are seven kinds of expansion performed:  ,
 ,  ,  ,  ,  , and
 .
 The order of expansions is: brace expansion, tilde expansion, parameter, variable and arithmetic expansion and command substitution (done in a left-to-right
fashion), word splitting, and pathname expansion.
 On systems that can support it, there is an additional expansion available:  .
 Only brace expansion, word splitting, and pathname expansion can change the number of words of the expansion; other expansions expand a single word to a
single word. The only exceptions to this are the expansions of " " and " " as explained above (see
 
 
 Brace expansions may be nested. The results of each expanded string are not sorted; left to right order is preserved. For example, a d,c,b e
expands into 'ade ace abe'.
 A sequence expression takes the form  , where   and   are either integers or
single characters, and  , an optional increment, is an integer. When integers are supplied, the expression expands to each number between  
and  , inclusive. Supplied integers may be prefixed with   to force each term to have the same width. When either   or   begins
with a zero, the shell attempts to force all generated terms to contain the same number of digits, zero-padding where necessary. When characters are supplied,
the expression expands to each character lexicographically between   and  , inclusive. Note that both   and   must be of the same
type. When the increment is supplied, it is used as the difference between each term. The default increment is 1 or -1 as appropriate.
 Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result. It is strictly
textual.   does not apply any syntactic interpretation to the context of the expansion or the text between the braces.
 A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma or a valid sequence expression. Any
incorrectly formed brace expansion is left unchanged. A   or   may be quoted with a backslash to prevent its being considered part of a brace
expression. To avoid conflicts with parameter expansion, the string   is not considered eligible for brace expansion.
 This construct is typically used as shorthand when the common prefix of the strings to be generated is longer than in the above example:
 
 
 If the tilde-prefix is a '~+', the value of the shell variable   replaces the tilde-prefix. If the tilde-prefix is a '~-', the value
of the shell variable   if it is set, is substituted. If the characters following the tilde in the tilde-prefix
consist of a number  , optionally prefixed by a '+' or a '-', the tilde-prefix is replaced with the corresponding element from the directory stack, as
it would be displayed by the   builtin invoked with the tilde-prefix as an argument. If the characters following the tilde in the tilde-prefix
consist of a number without a leading '+' or '-', '+' is assumed.
 If the login name is invalid, or the tilde expansion fails, the word is unchanged.
 Each variable assignment is checked for unquoted tilde-prefixes immediately following a   or the first  . In these cases, tilde expansion is
also performed. Consequently, one may use file names with tildes in assignments to   and
  and the shell assigns the expanded value.
 
 
 When braces are used, the matching ending brace is the first ' ' not escaped by a backslash or within a quoted string, and not within an embedded
arithmetic expansion, command substitution, or parameter expansion.
 In each of the cases below,   is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion.

 When not performing substring expansion, using the forms documented below,   tests for a parameter that is unset or null. Omitting the colon
results in a test only for a parameter that is unset.
 
 
 When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by  ,  , or  .
The first backquote not preceded by a backslash terminates the command substitution. When using the $( ) form, all characters between the
parentheses make up the command; none are treated specially.
 Command substitutions may be nested. To nest when using the backquoted form, escape the inner backquotes with backslashes.
 If the substitution appears within double quotes, word splitting and pathname expansion are not performed on the results.
 
 
 The evaluation is performed according to the rules listed below under   If   is
invalid,   prints a message indicating failure and no substitution occurs.
 
 
 When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic
expansion.
 
 
 The shell treats each character of   as a delimiter, and splits the results of the other expansions into words on these characters.
If   is unset, or its value is exactly  , the default, then sequences of
 ,  , and   at the beginning and end of the results of the previous expansions are ignored, and any
sequence of   characters not at the beginning or end serves to delimit words. If   has a value other than the
default, then sequences of the whitespace characters   and   are ignored at the beginning and end of the word, as long as the whitespace
character is in the value of   (an   whitespace character). Any character in   that is
not   whitespace, along with any adjacent   whitespace characters, delimits a field. A sequence of
  whitespace characters is also treated as a delimiter. If the value of   is null, no word splitting occurs.

 Explicit null arguments (  or  ) are retained. Unquoted implicit null arguments, resulting from the expansion of parameters that have no
values, are removed. If a parameter with no value is expanded within double quotes, a null argument results and is retained.
 Note that if no expansion occurs, no splitting is performed.
 
 
 The   shell variable may be used to restrict the set of file names matching a  . If
  is set, each matching file name that also matches one of the patterns in   is removed from the
list of matches. The file names   and   are always ignored when   is set and not null. However, setting
  to a non-null value has the effect of enabling the   shell option, so all other file names beginning with a
  will match. To get the old behavior of ignoring file names beginning with a  , make   one of the patterns in
  The   option is disabled when   is unset.
 
 Any character that appears in a pattern, other than the special pattern characters described below, matches itself. The NUL character may not occur in a
pattern. A backslash escapes the following character; the escaping backslash is discarded when matching. The special pattern characters must be quoted if they
are to be matched literally.
 The special pattern characters have the following meanings:
 Matches any string, including the null string. When the   shell option is enabled, and   is used in a pathname expansion context, two
adjacent  s used as a single pattern will match all files and zero or more directories and subdirectories. If followed by a  , two adjacent
 s will match only directories and subdirectories.

 
 Matches any single character.

 
 Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a  ; any character that sorts between
those two characters, inclusive, using the current locale's collating sequence and character set, is matched. If the first character following the   is
a   or a   then any character not enclosed is matched. The sorting order of characters in range expressions is determined by the current locale
and the value of the   shell variable, if set. A   may be matched by including it as the first or last character in the
set. A   may be matched by including it as the first character in the set.
 Within   and  , an   can be specified using the syntax  , which matches all characters with
the same collation weight (as defined by the current locale) as the character  .
 Within   and  , the syntax   matches the collating symbol  .
 
 Matches zero or one occurrence of the given patterns
 
 Matches zero or more occurrences of the given patterns
 
 Matches one or more occurrences of the given patterns
 
 Matches one of the given patterns
 
 Matches anything except one of the given patterns

 
 
 
 Before a command is executed, its input and output may be   using a special notation interpreted by the shell. Redirection may also be used
to open and close files for the current shell execution environment. The following redirection operators may precede or appear anywhere within a   or may follow a  . Redirections are processed in the order they appear, from left to right.
 Each redirection that may be preceded by a file descriptor number may instead be preceded by a word of the form { }. In this case, for each
redirection operator except >&- and <&-, the shell will allocate a file descriptor greater than 10 and assign it to  . If >&-
or <&- is preceded by { }, the value of   defines the file descriptor to close.
 In the following descriptions, if the file descriptor number is omitted, and the first character of the redirection operator is  , the redirection
refers to the standard input (file descriptor 0). If the first character of the redirection operator is  , the redirection refers to the standard
output (file descriptor 1).
 The word following the redirection operator in the following descriptions, unless otherwise noted, is subjected to brace expansion, tilde expansion,
parameter expansion, command substitution, arithmetic expansion, quote removal, pathname expansion, and word splitting. If it expands to more than one word,
  reports an error.
 Note that the order of redirections is significant. For example, the command
  handles several filenames specially when they are used in redirections, as described in the following table:
 
 If   is a valid integer, file descriptor   is duplicated.
 
 File descriptor 0 is duplicated.
 
 File descriptor 1 is duplicated.
 
 File descriptor 2 is duplicated.
 
 If   is a valid hostname or Internet address, and   is an integer port number or service name,   attempts to open a TCP
connection to the corresponding socket.
 
 If   is a valid hostname or Internet address, and   is an integer port number or service name,   attempts to open a UDP
connection to the corresponding socket.
 Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.
 
 
 The general format for redirecting input is:
 
 
 The general format for redirecting output is:
 
 
 The general format for appending output is:
 
 
 There are two formats for redirecting standard output and standard error:
 
 
 The format for appending standard output and standard error is:
 
 
 The format of here-documents is:
 If the redirection operator is  , then all leading tab characters are stripped from input lines and the line containing  .
This allows here-documents within shell scripts to be indented in a natural fashion.
 
 
 
 
 The operator
 
 
 Similarly, the redirection operator
 
 
 
 
  allow a string to be substituted for a word when it is used as the first word of a simple command. The shell maintains a list of aliases that
may be set and unset with the   and   builtin commands (see   below). The first word of each
simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The characters  ,  ,
 , and   and any of the shell   or quoting characters listed above may not appear in an alias name. The replacement text may
contain any valid shell input, including shell metacharacters. The first word of the replacement text is tested for aliases, but a word that is identical to an
alias being expanded is not expanded a second time. This means that one may alias   to  , for instance, and   does not try to
recursively expand the replacement text. If the last character of the alias value is a  , then the next command word following the alias is also
checked for alias expansion.
 Aliases are created and listed with the   command, and removed with the   command.
 There is no mechanism for using arguments in the replacement text. If arguments are needed, a shell function should be used (see
  below).
 Aliases are not expanded when the shell is not interactive, unless the   shell option is set using   (see the description of
  under   below).
 The rules concerning the definition and use of aliases are somewhat confusing.   always reads at least one complete line of input before executing
any of the commands on that line. Aliases are expanded when a command is read, not when it is executed. Therefore, an alias definition appearing on the same
line as another command does not take effect until the next line of input is read. The commands following the alias definition on that line are not affected by
the new alias. This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is
executed, because a function definition is itself a compound command. As a consequence, aliases defined in a function are not available until after that
function is executed. To be safe, always put alias definitions on a separate line, and do not use   in compound commands.
 For almost every purpose, aliases are superseded by shell functions.
 
 A shell function, defined as described above under   stores a series of commands for later execution. When
the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Functions are executed in
the context of the current shell; no new process is created to interpret them (contrast this with the execution of a shell script). When a function is
executed, the arguments to the function become the positional parameters during its execution. The special parameter   is updated to reflect the change.
Special parameter 0 is unchanged. The first element of the   variable is set to the name of the function while the function is
executing.
 All other aspects of the shell execution environment are identical between a function and its caller with these exceptions: the  
and   traps (see the description of the   builtin under   below) are not inherited unless the
function has been given the   attribute (see the description of the   builtin below) or the   shell
option has been enabled with the   builtin (in which case all functions inherit the   and   traps), and the
  trap is not inherited unless the   shell option has been enabled.
 Variables local to the function may be declared with the   builtin command. Ordinarily, variables and their values are shared between the
function and its caller.
 If the builtin command   is executed in a function, the function completes and execution resumes with the next command after the function call.
Any command associated with the   trap is executed before execution resumes. When a function completes, the values of the positional parameters and
the special parameter   are restored to the values they had prior to the function's execution.
 Function names and definitions may be listed with the   option to the   or   builtin commands. The   option to
  or   will list the function names only (and optionally the source file and line number, if the   shell option is
enabled). Functions may be exported so that subshells automatically have them defined with the   option to the   builtin. A function
definition may be deleted using the   option to the   builtin. Note that shell functions and variables with the same name may result in
multiple identically-named entries in the environment passed to the shell's children. Care should be taken in cases where this may cause a problem.

 Functions may be recursive. No limit is imposed on the number of recursive calls.
 
 The shell allows arithmetic expressions to be evaluated, under certain circumstances (see the   and   builtin commands and
 ). Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error.
The operators and their precedence, associativity, and values are the same as in the C language. The following list of operators is grouped into levels of
equal-precedence operators. The levels are listed in order of decreasing precedence.
 unary minus and plus

 
 logical and bitwise negation

 
 exponentiation

 
 multiplication, division, remainder

 
 addition, subtraction

 
 left and right bitwise shifts
 equality and inequality

 
 bitwise AND

 
 bitwise exclusive OR

 
 bitwise OR

 
 logical AND

 
 logical OR
 Constants with a leading 0 are interpreted as octal numbers. A leading 0x or 0X denotes hexadecimal. Otherwise, numbers take the form [ ]n, where
  is a decimal number between 2 and 64 representing the arithmetic base, and   is a number in that base. If   is omitted, then base
10 is used. The digits greater than 9 are represented by the lowercase letters, the uppercase letters, @, and _, in that order. If   is less than or
equal to 36, lowercase and uppercase letters may be used interchangeably to represent numbers between 10 and 35.
 Operators are evaluated in order of precedence. Sub-expressions in parentheses are evaluated first and may override the precedence rules
above.
 
 
 Conditional expressions are used by the   compound command and the   and   builtin commands to test file attributes and perform
string and arithmetic comparisons. Expressions are formed from the following unary or binary primaries. If any   argument to one of the primaries is
of the form  , then file descriptor   is checked. If the   argument to one of the primaries is one of  ,
 , or  , file descriptor 0, 1, or 2, respectively, is checked.
 Unless otherwise specified, primaries that operate on files follow symbolic links and operate on the target of the link, rather than the link itself.

 When used with  , The   and   operators sort lexicographically using the current locale.
 True if file descriptor   is open and refers to a terminal.
 
 
 When a simple command is executed, the shell performs the following expansions, assignments, and redirections, from left to right.
 The words that the parser has marked as variable assignments (those preceding the command name) and redirections are saved for later processing.

 2.

 The words that are not variable assignments or redirections are expanded. If any words remain after expansion, the first word is taken to be the name of the
command and the remaining words are the arguments.

 3.

 Redirections are performed as described above under  
 4.

 The text after the   in each variable assignment undergoes tilde expansion, parameter expansion, command substitution, arithmetic expansion, and
quote removal before being assigned to the variable.
 If no command name results, redirections are performed, but do not affect the current shell environment. A redirection error causes the command to exit with
a non-zero status.
 If there is a command name left after expansion, execution proceeds as described below. Otherwise, the command exits. If one of the expansions contained a
command substitution, the exit status of the command is the exit status of the last command substitution performed. If there were no command substitutions, the
command exits with a status of zero.
 
 
 After a command has been split into words, if it results in a simple command and an optional list of arguments, the following actions are taken.

 If the command name contains no slashes, the shell attempts to locate it. If there exists a shell function by that name, that function is invoked as
described above in   If the name does not match a function, the shell searches for it in the list of shell
builtins. If a match is found, that builtin is invoked.
 If the name is neither a shell function nor a builtin, and contains no slashes,   searches each element of the   for a
directory containing an executable file by that name.   uses a hash table to remember the full pathnames of executable files (see   under
  below). A full search of the directories in   is performed only if the command is not
found in the hash table. If the search is unsuccessful, the shell searches for a defined shell function named  . If that function
exists, it is invoked with the original command and the original command's arguments as its arguments, and the function's exit status becomes the exit status
of the shell. If that function is not defined, the shell prints an error message and returns an exit status of 127.
 If the search is successful, or if the command name contains one or more slashes, the shell executes the named program in a separate execution environment.
Argument 0 is set to the name given, and the remaining arguments to the command are set to the arguments given, if any.
 If this execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a  , a file
containing shell commands. A subshell is spawned to execute it. This subshell reinitializes itself, so that the effect is as if a new shell had been invoked to
handle the script, with the exception that the locations of commands remembered by the parent (see   below under   are retained by the child.
 If the program is a file beginning with  , the remainder of the first line specifies an interpreter for the program. The shell executes the
specified interpreter on operating systems that do not handle this executable format themselves. The arguments to the interpreter consist of a single optional
argument following the interpreter name on the first line of the program, followed by the name of the program, followed by the command arguments, if
any.
 
 The shell has an  , which consists of the following:
 • the current working directory as set by  ,  , or  , or inherited by the shell at invocation

 • the file creation mode mask as set by   or inherited from the shell's parent

 • current traps set by  
 • shell parameters that are set by variable assignment or with   or inherited from the shell's parent in the environment

 • shell functions defined during execution or inherited from the shell's parent in the environment

 • options enabled at invocation (either by default or with command-line arguments) or by  
 • options enabled by  
 • shell aliases defined with  
 • various process IDs, including those of background jobs, the value of  , and the value of  
 • the current working directory

 • the file creation mode mask

 • shell variables and functions marked for export, along with variables exported for the command, passed in the environment

 • traps caught by the shell are reset to the values inherited from the shell's parent, and traps ignored by the shell are ignored
 Command substitution, commands grouped with parentheses, and asynchronous commands are invoked in a subshell environment that is a duplicate of the shell
environment, except that traps caught by the shell are reset to the values that the shell inherited from its parent at invocation. Builtin commands that are
invoked as part of a pipeline are also executed in a subshell environment. Changes made to the subshell environment cannot affect the shell's execution
environment.
 Subshells spawned to execute command substitutions inherit the value of the   option from the parent shell. When not in posix mode, Bash clears the
  option in such subshells.
 If a command is followed by a   and job control is not active, the default standard input for the command is the empty file  .
Otherwise, the invoked command inherits the file descriptors of the calling shell as modified by redirections.
 
 
 When a program is invoked it is given an array of strings called the  . This is a list of  -  pairs, of the form
 = .
 The shell provides several ways to manipulate the environment. On invocation, the shell scans its own environment and creates a parameter for each name
found, automatically marking it for   to child processes. Executed commands inherit the environment. The   and  
commands allow parameters and functions to be added to and deleted from the environment. If the value of a parameter in the environment is modified, the new
value becomes part of the environment, replacing the old. The environment inherited by any executed command consists of the shell's initial environment, whose
values may be modified in the shell, less any pairs removed by the   command, plus any additions via the   and  
commands.
 The environment for any   or function may be augmented temporarily by prefixing it with parameter assignments, as described above in
  These assignment statements affect only the environment seen by that command.
 If the   option is set (see the   builtin command below), then   parameter assignments are placed in the environment for a
command, not just those that precede the command name.
 When   invokes an external command, the variable   is set to the full file name of the command and passed to that command in its
environment.
 
 The exit status of an executed command is the value returned by the   system call or equivalent function. Exit statuses fall between 0 and 255,
though, as explained below, the shell may use values above 125 specially. Exit statuses from shell builtins and compound commands are also limited to this
range. Under certain circumstances, the shell will use special values to indicate specific failure modes.
 For the shell's purposes, a command which exits with a zero exit status has succeeded. An exit status of zero indicates success. A non-zero exit status
indicates failure. When a command terminates on a fatal signal  ,   uses the value of 128+  as the exit status.
 If a command is not found, the child process created to execute it returns a status of 127. If a command is found but is not executable, the return status
is 126.
 If a command fails because of an error during expansion or redirection, the exit status is greater than zero.
 Shell builtin commands return a status of 0 ( ) if successful, and non-zero ( ) if an error occurs while they execute. All builtins
return an exit status of 2 to indicate incorrect usage.
  itself returns the exit status of the last command executed, unless a syntax error occurs, in which case it exits with a non-zero value. See
also the   builtin command below.
 
 When   is interactive, in the absence of any traps, it ignores   (so that   does not kill an interactive
shell), and   is caught and handled (so that the   builtin is interruptible). In all cases,   ignores
  If job control is in effect,   ignores  
and  
 Non-builtin commands run by   have signal handlers set to the values inherited by the shell from its parent. When job control is not in effect,
asynchronous commands ignore   and   in addition to these inherited handlers. Commands run as a result
of command substitution ignore the keyboard-generated job control signals   and
 
 The shell exits by default upon receipt of a   Before exiting, an interactive shell resends the
  to all jobs, running or stopped. Stopped jobs are sent   to ensure that they receive the
  To prevent the shell from sending the signal to a particular job, it should be removed from the jobs table with
the   builtin (see   below) or marked to not receive   using  .
 If the   shell option has been set with  ,   sends a   to all jobs when an interactive login
shell exits.
 If   is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command
completes. When   is waiting for an asynchronous command via the   builtin, the reception of a signal for which a trap has been set will
cause the   builtin to return immediately with an exit status greater than 128, immediately after which the trap is executed.
 
  refers to the ability to selectively stop ( ) the execution of processes and continue ( ) their execution at a
later point. A user typically employs this facility via an interactive interface supplied jointly by the operating system kernel's terminal driver and
 .
 The shell associates a   with each pipeline. It keeps a table of currently executing jobs, which may be listed with the   command. When
  starts a job asynchronously (in the  ), it prints a line that looks like:
 To facilitate the implementation of the user interface to job control, the operating system maintains the notion of a  . Members of this process group (processes whose process group ID is equal to the current terminal process group ID) receive keyboard-generated signals
such as   These processes are said to be in the  .   processes are those whose
process group ID differs from the terminal's; such processes are immune to keyboard-generated signals. Only foreground processes are allowed to read from or,
if the user so specifies with  , write to the terminal. Background processes which attempt to read from (write to when  
is in effect) the terminal are sent a   signal by the kernel's terminal driver, which, unless caught, suspends the
process.
 If the operating system on which   is running supports job control,   contains facilities to use it. Typing the   character
(typically  , Control-Z) while a process is running causes that process to be stopped and returns control to  . Typing the   character (typically  , Control-Y) causes the process to be stopped when it attempts to read input from the terminal, and control to be
returned to  . The user may then manipulate the state of this job, using the   command to continue it in the background, the  
command to continue it in the foreground, or the   command to kill it. A   takes effect immediately, and has the additional side effect of
causing pending output and typeahead to be discarded.
 There are a number of ways to refer to a job in the shell. The character   introduces a job specification ( ). Job number   may
be referred to as  . A job may also be referred to using a prefix of the name used to start it, or using a substring that appears in its command line.
For example,   refers to a stopped   job. If a prefix matches more than one job,   reports an error. Using  , on the other
hand, refers to any job containing the string   in its command line. If the substring matches more than one job,   reports an error. The
symbols   and   refer to the shell's notion of the  , which is the last job stopped while it was in the foreground or started
in the background. The   may be referenced using  . If there is only a single job,   and   can both be used to refer
to that job. In output pertaining to jobs (e.g., the output of the   command), the current job is always flagged with a  , and the previous
job with a  . A single % (with no accompanying job specification) also refers to the current job.
 Simply naming a job can be used to bring it into the foreground:   is a synonym for  , bringing job 1 from the background into the
foreground. Similarly,   resumes job 1 in the background, equivalent to  .
 The shell learns immediately whenever a job changes state. Normally,   waits until it is about to print a prompt before reporting changes in a
job's status so as to not interrupt any other output. If the   option to the   builtin command is enabled,   reports such changes
immediately. Any trap on   is executed for each child that exits.
 If an attempt to exit   is made while jobs are stopped (or, if the   shell option has been enabled using the   builtin,
running), the shell prints a warning message, and, if the   option is enabled, lists the jobs and their statuses. The   command may
then be used to inspect their status. If a second attempt to exit is made without an intervening command, the shell does not print another warning, and any
stopped jobs are terminated.
 
 
 When executing interactively,   displays the primary prompt   when it is ready to read a command, and the secondary prompt
  when it needs more input to complete a command.   allows these prompt strings to be customized by inserting a number of
backslash-escaped special characters that are decoded as follows:
 an ASCII bell character (07)

 
 the date in "Weekday Month Date" format (e.g., "Tue May 26")
 
 the   is passed to  (3) and the result is inserted into the prompt string; an empty   results in a locale-specific
time representation. The braces are required
 an ASCII escape character (033)

 
 the hostname up to the first '.'

 
 the hostname

 
 the number of jobs currently managed by the shell

 
 the basename of the shell's terminal device name

 
 newline

 
 carriage return

 
 the name of the shell, the basename of   (the portion following the final slash)

 
 the current time in 24-hour HH:MM:SS format

 
 the current time in 12-hour HH:MM:SS format

 
 the current time in 12-hour am/pm format

 
 the current time in 24-hour HH:MM format

 
 the username of the current user

 
 the version of   (e.g., 2.00)

 
 the release of  , version + patch level (e.g., 2.00.0)

 
 the current working directory, with   abbreviated with a tilde (uses the value of the  
variable)

 
 the basename of the current working directory, with   abbreviated with a tilde

 
 the history number of this command

 
 the command number of this command

 
 if the effective UID is 0, a  , otherwise a  
 
 the character corresponding to the octal number  
 
 a backslash

 
 begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt

 
 end a sequence of non-printing characters
 
 
 This is the library that handles reading input when using an interactive shell, unless the   option is given at shell invocation. Line
editing is also used when using the   option to the   builtin. By default, the line editing commands are similar to those of emacs. A
vi-style line editing interface is also available. Line editing can be enabled at any time using the   or   options to the  
builtin (see   below). To turn off line editing after the shell is running, use the   or  
options to the   builtin.

 
 Readline commands may be given numeric  , which normally act as a repeat count. Sometimes, however, it is the sign of the argument that is
significant. Passing a negative argument to a command that acts in the forward direction (e.g.,  ) causes that command to act in a backward
direction. Commands whose behavior with arguments deviates from this are noted below.
 When a command is described as   text, the text deleted is saved for possible future retrieval ( ). The killed text is saved in a
 . Consecutive kills cause the text to be accumulated into one unit, which can be yanked all at once. Commands which do not kill text separate
the chunks of text on the kill ring.
 
 
 The default key-bindings may be changed with an   file. Other programs that use this library may add their own commands and bindings.

 For example, placing
 The following symbolic character names are recognized:  ,  ,  ,  ,  ,  ,  ,
 ,  , and  .
 In addition to command names, readline allows keys to be bound to a string that is inserted when the key is pressed (a  ).
 
 
 When using the form  :  or  ,   is the name of a key spelled out in English. For example:
 In the second form,  :  or  ,   differs from   above in that strings denoting an entire
key sequence may be specified by placing the sequence within double quotes. Some GNU Emacs style key escapes can be used, as in the following example, but the
symbolic character names are not recognized.
 The full set of GNU Emacs style escape sequences is
 control prefix

 
 meta prefix

 
 an escape character

 
 backslash

 
 literal "

 
 literal '
 alert (bell)

 
 backspace

 
 delete

 
 form feed

 
 newline

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 the eight-bit character whose value is the octal value   (one to three digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)
  allows the current readline key bindings to be displayed or modified with the   builtin command. The editing mode may be switched
during interactive use by using the   option to the   builtin command (see   below).
 
 
 
 
 The   construct allows bindings to be made based on the editing mode, the terminal being used, or the application using readline. The text of the
test extends to the end of the line; no characters are required to isolate it.
 The   form of the   directive is used to test whether readline is in emacs or vi mode. This may be used in conjunction with the   command, for instance, to set bindings in the   and   keymaps only if readline is starting out in emacs mode.

 
 The   form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal's function keys. The
word on the right side of the   is tested against the both full name of the terminal and the portion of the terminal name before the first  .
This allows   to match both   and  , for instance.
 
 The   construct is used to include application-specific settings. Each program using the readline library sets the  ,
and an initialization file can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance,
the following command adds a key sequence that quotes the current or previous word in Bash:

 
 This command, as seen in the previous example, terminates an   command.

 
 Commands in this branch of the   directive are executed if the test fails.
 
 
 Incremental searches begin before the user has finished typing the search string. As each character of the search string is typed, readline displays the
next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history
entry. The characters present in the value of the   variable are used to terminate an incremental search. If that variable has not
been assigned a value the Escape and Control-J characters will terminate an incremental search. Control-G will abort an incremental search and restore the
original line. When the search is terminated, the history entry containing the search string becomes the current line.
 To find other matching entries in the history list, type Control-S or Control-R as appropriate. This will search backward or forward in the history for the
next entry matching the search string typed so far. Any other key sequence bound to a readline command will terminate the search and execute that command. For
instance, a   will terminate the search and accept the line, thereby executing the command from the history list.
 Readline remembers the last incremental search string. If two Control-Rs are typed without any intervening characters defining a new search string, any
remembered search string is used.
 Non-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or
be part of the contents of the current line.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 First, the command name is identified. If the command word is the empty string (completion attempted at the beginning of an empty line), any compspec
defined with the   option to   is used. If a compspec has been defined for that command, the compspec is used to generate the list of
possible completions for the word. If the command word is a full pathname, a compspec for the full pathname is searched for first. If no compspec is found for
the full pathname, an attempt is made to find a compspec for the portion following the final slash. If those searches to not result in a compspec, any compspec
defined with the   option to   is used as the default.
 Once a compspec has been found, it is used to generate the list of matching words. If a compspec is not found, the default   completion as
described above under   is performed.
 First, the actions specified by the compspec are used. Only matches which are prefixed by the word being completed are returned. When the   or
  option is used for filename or directory name completion, the shell variable   is used to filter the matches.

 Any completions specified by a pathname expansion pattern to the   option are generated next. The words generated by the pattern need not match the
word being completed. The   shell variable is not used to filter the matches, but the   variable is
used.
 Next, the string specified as the argument to the   option is considered. The string is first split using the characters in the
  special variable as delimiters. Shell quoting is honored. Each word is then expanded using brace expansion, tilde expansion,
parameter and variable expansion, command substitution, and arithmetic expansion, as described above under   The
results are split using the rules described above under  . The results of the expansion are prefix-matched against the word being
completed, and the matching words become the possible completions.
 After these matches have been generated, any shell function or command specified with the   and   options is invoked. When the command or
function is invoked, the   and   variables are
assigned values as described above under  . If a shell function is being invoked, the   and
  variables are also set. When the function or command is invoked, the first argument is the name of the command whose arguments
are being completed, the second argument is the word being completed, and the third argument is the word preceding the word being completed on the current
command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in
generating the matches.
 Any function specified with   is invoked first. The function may use any of the shell facilities, including the   builtin described
below, to generate the matches. It must put the possible completions in the   array variable.
 Next, any command specified with the   option is invoked in an environment equivalent to command substitution. It should print a list of
completions, one per line, to the standard output. Backslash may be used to escape a newline, if necessary.
 After all of the possible completions are generated, any filter specified with the   option is applied to the list. The filter is a pattern as used
for pathname expansion; a   in the pattern is replaced with the text of the word being completed. A literal   may be escaped with a
backslash; the backslash is removed before attempting a match. Any completion that matches the pattern will be removed from the list. A leading  
negates the pattern; in this case any completion not matching the pattern will be removed.
 Finally, any prefix and suffix specified with the   and   options are added to each member of the completion list, and the result is
returned to the readline completion code as the list of possible completions.
 If the previously-applied actions do not generate any matches, and the   option was supplied to   when the compspec was
defined, directory name completion is attempted.
 If the   option was supplied to   when the compspec was defined, directory name completion is attempted and any matches are
added to the results of the other actions.
 By default, if a compspec is found, whatever it generates is returned to the completion code as the full set of possible completions. The default
  completions are not attempted, and the readline default of filename completion is disabled. If the   option was supplied to
  when the compspec was defined, the   default completions are attempted if the compspec generates no matches. If the  
option was supplied to   when the compspec was defined, readline's default completion will be performed if the compspec (and, if attempted, the
default   completions) generate no matches.
 When a compspec indicates that directory name completion is desired, the programmable completion functions force readline to append a slash to completed
names which are symbolic links to directories, subject to the value of the   readline variable, regardless of the setting of the
  readline variable.
 There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with
 . It's possible for shell functions executed as completion handlers to indicate that completion should be retried by returning an exit status
of 124. If a shell function returns 124, and changes the compspec associated with the command on which completion is being attempted (supplied as the first
argument when the function is executed), programmable completion restarts from the beginning, with an attempt to find a compspec for that command. This allows
a set of completions to be built dynamically as completion is attempted, rather than being loaded all at once.
 For instance, assuming that there is a library of compspecs, each kept in a file corresponding to the name of the command, the following default completion
function would load completions dynamically:
 
 
 
 When the   option to the   builtin is enabled, the shell provides access to the  , the list of commands
previously typed. The value of the   variable is used as the number of commands to save in a history list. The text of the last
  commands (default 500) is saved. The shell stores each command in the history list prior to parameter and variable expansion
(see   above) but after history expansion is performed, subject to the values of the shell variables
  and  
 On startup, the history is initialized from the file named by the variable   (default  ). The file named
by the value of   is truncated, if necessary, to contain no more than the number of lines specified by the value of
  When the history file is read, lines beginning with the history comment character followed immediately by a
digit are interpreted as timestamps for the preceding history line. These timestamps are optionally displayed depending on the value of the
  variable. When an interactive shell exits, the last   lines are copied from the history list
to   If the   shell option is enabled (see the description of   under   below), the lines are appended to the history file, otherwise the history file is overwritten. If  
is unset, or if the history file is unwritable, the history is not saved. If the   variable is set, time stamps are written
to the history file, marked with the history comment character, so they may be preserved across shell sessions. This uses the history comment character to
distinguish timestamps from other history lines. After saving the history, the history file is truncated to contain no more than
  lines. If   is not set, no truncation is performed.
 The builtin command   (see   below) may be used to list or edit and re-execute a portion of the history
list. The   builtin may be used to display or modify the history list and manipulate the history file. When using command-line editing, search
commands are available in each editing mode that provide access to the history list.
 The shell allows control over which commands are saved on the history list. The   and  
variables may be set to cause the shell to save only a subset of the commands entered. The   shell option, if enabled, causes the shell to attempt
to save each line of a multi-line command in the same history entry, adding semicolons where necessary to preserve syntactic correctness. The  
shell option causes the shell to save the command with embedded newlines instead of semicolons. See the description of the   builtin below under
  for information on setting and unsetting shell options.
 
 The shell supports a history expansion feature that is similar to the history expansion in   This section describes what syntax features are
available. This feature is enabled by default for interactive shells, and can be disabled using the   option to the   builtin command (see
  below). Non-interactive shells do not perform history expansion by default.
 History expansions introduce words from the history list into the input stream, making it easy to repeat commands, insert the arguments to a previous
command into the current input line, or fix errors in previous commands quickly.
 History expansion is performed immediately after a complete line is read, before the shell breaks it into words. It takes place in two parts. The first is
to determine which line from the history list to use during substitution. The second is to select portions of that line for inclusion into the current one. The
line selected from the history is the  , and the portions of that line that are acted upon are  . Various   are available
to manipulate the selected words. The line is broken into words in the same fashion as when reading input, so that several  -separated words
surrounded by quotes are considered one word. History expansions are introduced by the appearance of the history expansion character, which is   by
default. Only backslash ( ) and single quotes can quote the history expansion character.
 Several characters inhibit history expansion if found immediately following the history expansion character, even if it is unquoted: space, tab, newline,
carriage return, and  . If the   shell option is enabled,   will also inhibit expansion.
 Several shell options settable with the   builtin may be used to tailor the behavior of history expansion. If the   shell option
is enabled (see the description of the   builtin below), and   is being used, history substitutions are not immediately passed to the
shell parser. Instead, the expanded line is reloaded into the   editing buffer for further modification. If   is being used, and
the   shell option is enabled, a failed history substitution will be reloaded into the   editing buffer for correction. The
  option to the   builtin command may be used to see what a history expansion will do before using it. The   option to the
  builtin may be used to add commands to the end of the history list without actually executing them, so that they are available for subsequent
recall.
 The shell allows control of the various characters used by the history expansion mechanism (see the description of   above under  ). The shell uses the history comment character to mark history timestamps when writing the history file.

 
 Start a history substitution, except when followed by a  , newline, carriage return, = or ( (when the   shell option is enabled
using the   builtin).

 
 Refer to command line  .

 
 Refer to the current command line minus  .

 
 Refer to the previous command. This is a synonym for '!-1'.
 The entire command line typed so far.

 
 
 The  th word.

 
 The first argument. That is, word 1.

 
 The last argument.

 
 The word matched by the most recent '? ?' search.

 
 A range of words; '- ' abbreviates '0- '.

 
 All of the words but the zeroth. This is a synonym for ' '. It is not an error to use   if there is just one word in the event; the empty
string is returned in that case.

 
 Abbreviates  .

 
 Abbreviates   like  , but omits the last word.
 
 
 Remove a trailing file name component, leaving only the head.

 
 Remove all leading file name components, leaving the tail.

 
 Remove a trailing suffix of the form  , leaving the basename.

 
 Remove all but the trailing suffix.

 
 Print the new command but do not execute it.

 
 Quote the substituted words, escaping further substitutions.

 
 Quote the substituted words as with  , but break into words at   and newlines.
 Repeat the previous substitution.

 
 Cause changes to be applied over the entire event line. This is used in conjunction with ' ' (e.g.,
' ') or ' '. If used with ' ', any delimiter can be used in place of /, and the final
delimiter is optional if it is the last character of the event line. An   may be used as a synonym for  .

 
 Apply the following ' ' modifier once to each word in the event line.
 
 
 Unless otherwise noted, each builtin command documented in this section as accepting options preceded by   accepts   to signify the end of
the options. The  ,  ,  , and   builtins do not accept options and do not treat   specially. The  ,
 ,  ,  ,  , and   builtins accept and process arguments beginning with   without requiring
 . Other builtins that accept arguments but are not specified as accepting options interpret arguments beginning with   as invalid options and
require   to prevent this interpretation.
 
 Use   as the keymap to be affected by the subsequent bindings. Acceptable   names are  , and  .   is equivalent to  ;   is equivalent to
 .
 List the names of all   functions.

 
 Display   function names and bindings in such a way that they can be re-read.

 
 List current   function names and bindings.

 
 Display   key sequences bound to macros and the strings they output in such a way that they can be re-read.

 
 Display   key sequences bound to macros and the strings they output.

 
 Display   variable names and values in such a way that they can be re-read.

 
 List current   variable names and values.
 
 Read key bindings from  .
 
 Query about which keys invoke the named  .
 
 Unbind all keys bound to the named  .
 
 Remove any current binding for  .
 
 Cause   to be executed whenever   is entered. When   is executed, the shell sets the
  variable to the contents of the   line buffer and the   variable to the
current location of the insertion point. If the executed command changes the value of   or
  those new values will be reflected in the editing state.
 The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the
same flags. If   is specified, only those completions matching   will be displayed.
 The return value is true unless an invalid option is supplied, or no matches were generated.
 The process of applying these completion specifications when word completion is attempted is described above under  .

 Other options, if specified, have the following meanings. The arguments to the  ,  , and   options (and, if necessary, the  
and   options) should be quoted to protect them from expansion before the   builtin is invoked.
 
 The   controls several aspects of the compspec's behavior beyond the simple generation of completions.   may be one
of:

 
 Perform the rest of the default   completions if the compspec generates no matches.

 
 Use readline's default filename completion if the compspec generates no matches.

 
 Perform directory name completion if the compspec generates no matches.

 
 Tell readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting
special characters, or suppressing trailing spaces). Intended to be used with shell functions.

 
 Tell readline not to append a space (the default) to words completed at the end of the line.

 
 After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other
actions.
 
 The   may be one of the following to generate a list of possible completions:

 
 Alias names. May also be specified as  .

 
 Array variable names.

 
  key binding names.

 
 Names of shell builtin commands. May also be specified as  .

 
 Command names. May also be specified as  .

 
 Directory names. May also be specified as  .

 
 Names of disabled shell builtins.

 
 Names of enabled shell builtins.

 
 Names of exported shell variables. May also be specified as  .

 
 File names. May also be specified as  .

 
 Names of shell functions.

 
 Group names. May also be specified as  .

 
 Help topics as accepted by the   builtin.

 
 Hostnames, as taken from the file specified by the   shell variable.

 
 Job names, if job control is active. May also be specified as  .

 
 Shell reserved words. May also be specified as  .

 
 Names of running jobs, if job control is active.

 
 Service names. May also be specified as  .

 
 Valid arguments for the   option to the   builtin.

 
 Shell option names as accepted by the   builtin.

 
 Signal names.

 
 Names of stopped jobs, if job control is active.

 
 User names. May also be specified as  .

 
 Names of all shell variables. May also be specified as  .
 
 The pathname expansion pattern   is expanded to generate the possible completions.
 
 The   is split using the characters in the   special variable as delimiters, and each resultant word is expanded. The
possible completions are the members of the resultant list which match the word being completed.
 
  is executed in a subshell environment, and its output is used as the possible completions.
 
 The shell function   is executed in the current shell environment. When it finishes, the possible completions are retrieved from the value of
the   array variable.
 
  is a pattern as used for pathname expansion. It is applied to the list of possible completions generated by the preceding options and
arguments, and each completion matching   is removed from the list. A leading   in   negates the pattern; in this case,
any completion not matching   is removed.
 
  is added at the beginning of each possible completion after all other options have been applied.
 
  is appended to each possible completion after all other options have been applied.
 Each   is an indexed array variable (see   above).

 
 Each   is an associative array variable (see   above).

 
 Use function names only.

 
 The variable is treated as an integer; arithmetic evaluation (see   above) is performed when the variable is
assigned a value.

 
 When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.

 
 Make  s readonly. These names cannot then be assigned values by subsequent assignment statements or unset.

 
 Give each   the   attribute. Traced functions inherit the   and   traps from the calling shell. The trace
attribute has no special meaning for variables.

 
 When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.

 
 Mark  s for export to subsequent commands via the environment.
 Displays the  th entry counting from the left of the list shown by   when invoked without options, starting with zero.

 
 Displays the  th entry counting from the right of the list shown by   when invoked without options, starting with zero.

 
 Clears the directory stack by deleting all of the entries.

 
 Produces a longer listing; the default listing format uses a tilde to denote the home directory.

 
 Print the directory stack with one entry per line.

 
 Print the directory stack with one entry per line, prefixing each entry with its index in the stack.
 alert (bell)

 
 backspace

 
 suppress further output

 
 an escape character

 
 form feed

 
 new line

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 backslash

 
 the eight-bit character whose value is the octal value   (zero to three octal digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)
 The   option suppresses the command numbers when listing. The   option reverses the order of the commands. If the   option is given,
the commands are listed on standard output. Otherwise, the editor given by   is invoked on a file containing those commands. If   is not
given, the value of the   variable is used, and the value of   if   is not
set. If neither variable is set,   is used. When editing is complete, the edited commands are echoed and executed.
 In the second form,   is re-executed after each instance of   is replaced by  . A useful alias to use with this is ''r="fc
-s"'', so that typing ''r cc'' runs the last command beginning with ''cc'' and typing ''r'' re-executes the last command.
 If the first form is used, the return value is 0 unless an invalid option is encountered or   or   specify history lines out of range.
If the   option is supplied, the return value is the value of the last command executed or failure if an error occurs with the temporary file of
commands. If the second form is used, the return status is that of the command re-executed, unless   does not specify a valid history line, in which
case   returns failure.
 When the end of options is encountered,   exits with a return value greater than zero.   is set to the index of the
first non-option argument, and   is set to ?.
  normally parses the positional parameters, but if more arguments are given in  ,   parses those instead.

  can report errors in two ways. If the first character of   is a colon,   error reporting is used. In normal
operation diagnostic messages are printed when invalid options or missing option arguments are encountered. If the variable   is set
to 0, no error messages will be displayed, even if the first character of   is not a colon.
 If an invalid option is seen,   places ? into   and, if not silent, prints an error message and unsets
  If   is silent, the option character found is placed in   and no
diagnostic message is printed.
 If a required argument is not found, and   is not silent, a question mark ( ) is placed in  ,   is
unset, and a diagnostic message is printed. If   is silent, then a colon ( ) is placed in   and   is
set to the option character found.
  returns true if an option, specified or unspecified, is found. It returns false if the end of options is encountered or an error
occurs.
 Display a short description of each  
 
 Display the description of each   in a manpage-like format

 
 Display only a short usage synopsis for each  
 Clear the history list by deleting all the entries.
 
 Delete the history entry at position  .
 Append the ''new'' history lines (history lines entered since the beginning of the current   session) to the history file.

 
 Read the history lines not already read from the history file into the current history list. These are lines appended to the history file since the
beginning of the current   session.

 
 Read the contents of the history file and use them as the current history.

 
 Write the current history to the history file, overwriting the history file's contents.

 
 Perform history substitution on the following   and display the result on the standard output. Does not store the results in the history list.
Each   must be quoted to disable normal history expansion.

 
 Store the   in the history list as a single entry. The last command in the history list is removed before the   are added.
 List process IDs in addition to the normal information.

 
 List only the process ID of the job's process group leader.

 
 Display information only about jobs that have changed status since the user was last notified of their status.

 
 Restrict output to running jobs.

 
 Restrict output to stopped jobs.
 If the   option is supplied,   replaces any   found in   or   with the corresponding process group ID,
and executes   passing it  , returning its exit status.
 Exit a login shell.
 Copy at most   lines. If   is 0, all lines are copied.

 
 Begin assigning to   at index  . The default index is 0.

 
 Discard the first   lines read.

 
 Remove a trailing newline from each line read.

 
 Read lines from file descriptor   instead of the standard input.

 
 Evaluate   each time   lines are read. The   option specifies  .

 
 Specify the number of lines read between each call to  .
 If not supplied with an explicit origin,   will clear   before assigning to it.
  returns successfully unless an invalid option or option argument is supplied,   is invalid or unassignable, or if   is
not an indexed array.
 Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.

 
 Removes the  th entry counting from the left of the list shown by  , starting with zero. For example: ''popd +0'' removes the first
directory, ''popd +1'' the second.

 
 Removes the  th entry counting from the right of the list shown by  , starting with zero. For example: ''popd -0'' removes the last
directory, ''popd -1'' the next to last.
 The   option causes the output to be assigned to the variable   rather than being printed to the standard output.
 The   is reused as necessary to consume all of the  . If the   requires more   than are supplied, the
extra format specifications behave as if a zero value or null string, as appropriate, had been supplied. The return value is zero on success, non-zero on
failure.
 Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.

 
 Rotates the stack so that the  th directory (counting from the left of the list shown by  , starting with zero) is at the top.

 
 Rotates the stack so that the  th directory (counting from the right of the list shown by  , starting with zero) is at the top.

 
 Adds   to the directory stack at the top, making it the new current working directory.
 
 The words are assigned to sequential indices of the array variable  , starting at 0.   is unset before any new values are assigned.
Other   arguments are ignored.
 
 The first character of   is used to terminate the input line, rather than newline.
 If the standard input is coming from a terminal,   (see   above) is used to obtain the line. Readline uses the
current (or default, if line editing was not previously active) editing settings.
 
 If   is being used to read the line,   is placed into the editing buffer before editing begins.
 
  returns after reading   characters rather than waiting for a complete line of input, but honor a delimiter if fewer than
  characters are read before the delimiter.
 
  returns after reading exactly   characters rather than waiting for a complete line of input, unless EOF is encountered or
  times out. Delimiter characters encountered in the input are not treated specially and do not cause   to return until  
characters are read.
 
 Display   on standard error, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming
from a terminal.
 Backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used
as a line continuation.

 
 Silent mode. If input is coming from a terminal, characters are not echoed.
 
 Cause   to time out and return failure if a complete line of input is not read within   seconds.   may be a decimal
number with a fractional portion following the decimal point. This option is only effective if   is reading input from a terminal, pipe, or other
special file; it has no effect when reading from regular files. If   is 0,   returns success if input is available on the specified file
descriptor, failure otherwise. The exit status is greater than 128 if the timeout is exceeded.
 Read input from file descriptor  .
 Automatically mark variables and functions which are modified or created for export to the environment of subsequent commands.

 
 Report the status of terminated background jobs immediately, rather than before the next primary prompt. This is effective only when job control is enabled.

 
 Exit immediately if a   (which may consist of a single  ), a   command enclosed in parentheses, or one of
the commands executed as part of a command list enclosed by braces (see   above) exits with a non-zero status. The shell does
not exit if the command that fails is part of the command list immediately following a   or   keyword, part of the test following the
  or   reserved words, part of any command executed in a   or   list except the command following the final
  or  , any command in a pipeline but the last, or if the command's return value is being inverted with  . A trap on  ,
if set, is executed before the shell exits. This option applies to the shell environment and each subshell environment separately (see   above), and may cause subshells to exit before executing all the commands in the subshell.

 
 Disable pathname expansion.

 
 Remember the location of commands as they are looked up for execution. This is enabled by default.

 
 All arguments in the form of assignment statements are placed in the environment for a command, not just those that precede the command name.

 
 Monitor mode. Job control is enabled. This option is on by default for interactive shells on systems that support it (see  
above). Background processes run in a separate process group and a line containing their exit status is printed upon their completion.

 
 Read commands but do not execute them. This may be used to check a shell script for syntax errors. This is ignored by interactive shells.
 
 The   can be one of the following:

 
 Same as  .

 
 Same as  .

 
 Use an emacs-style command line editing interface. This is enabled by default when the shell is interactive, unless the shell is started with the
  option. This also affects the editing interface used for  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Enable command history, as described above under   This option is on by default in interactive shells.

 
 The effect is as if the shell command ''IGNOREEOF=10'' had been executed (see   above).

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Currently ignored.

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 If set, the return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands in the pipeline
exit successfully. This option is disabled by default.

 
 Change the behavior of   where the default operation differs from the POSIX standard to match the standard ( ).

 
 Same as  .

 
 Same as  .

 
 Use a vi-style command line editing interface. This also affects the editing interface used for  .

 
 Same as  .

 If   is supplied with no  , the values of the current options are printed. If   is supplied with no  , a
series of   commands to recreate the current option settings is displayed on the standard output.
 Turn on   mode. In this mode, the   and   files are not processed, shell functions
are not inherited from the environment, and the   and
  variables, if they appear in the environment, are ignored. If the shell is started with the effective user (group) id not
equal to the real user (group) id, and the   option is not supplied, these actions are taken and the effective user id is set to the real user id. If
the   option is supplied at startup, the effective user id is not reset. Turning this option off causes the effective user and group ids to be set to
the real user and group ids.

 
 Exit after reading and executing one command.

 
 Treat unset variables and parameters other than the special parameters "@" and "*" as an error when performing parameter expansion. If expansion is
attempted on an unset variable or parameter, the shell prints an error message, and, if not interactive, exits with a non-zero status.

 
 Print shell input lines as they are read.

 
 After expanding each  ,   command,   command,   command, or arithmetic   command, display the
expanded value of   followed by the command and its expanded arguments or associated word list.

 
 The shell performs brace expansion (see   above). This is on by default.

 
 If set,   does not overwrite an existing file with the  ,  , and   redirection operators. This may be
overridden when creating output files by using the redirection operator   instead of  .

 
 If set, any trap on   is inherited by shell functions, command substitutions, and commands executed in a subshell environment. The   trap
is normally not inherited in such cases.

 
 Enable   style history substitution. This option is on by default when the shell is interactive.

 
 If set, the shell does not follow symbolic links when executing commands such as   that change the current working directory. It uses the physical
directory structure instead. By default,   follows the logical chain of directories when performing commands which change the current directory.

 
 If set, any traps on   and   are inherited by shell functions, command substitutions, and commands executed in a subshell
environment. The   and   traps are normally not inherited in such cases.

 
 If no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters are set to the  s, even if some
of them begin with a  .

 
 Signal the end of options, cause all remaining  s to be assigned to the positional parameters. The   and   options are turned off.
If there are no  s, the positional parameters remain unchanged.
 Enable (set) each  .

 
 Disable (unset) each  .

 
 Suppresses normal output (quiet mode); the return status indicates whether the   is set or unset. If multiple   arguments are
given with  , the return status is zero if all   are enabled; non-zero otherwise.

 
 Restricts the values of   to be those defined for the   option to the   builtin.
 The return status when listing options is zero if all   are enabled, non-zero otherwise. When setting or unsetting options, the return status
is zero unless an   is not a valid shell option.
 The list of   options is:
 If set, a command name that is the name of a directory is executed as if it were the argument to the   command. This option is only used by
interactive shells.
 
 If set, an argument to the   builtin command that is not a directory is assumed to be the name of a variable whose value is the directory to change
to.
 If set, minor errors in the spelling of a directory component in a   command will be corrected. The errors checked for are transposed characters, a
missing character, and one character too many. If a correction is found, the corrected file name is printed, and the command proceeds. This option is only used
by interactive shells.
 
 If set,   checks that a command found in the hash table exists before trying to execute it. If a hashed command no longer exists, a normal path
search is performed.
 
 If set,   lists the status of any stopped and running jobs before exiting an interactive shell. If any jobs are running, this causes the exit to
be deferred until a second exit is attempted without an intervening command (see   above). The shell always postpones exiting
if any jobs are stopped.
 
 If set,   checks the window size after each command and, if necessary, updates the values of   and
 
 If set,   attempts to save all lines of a multiple-line command in the same history entry. This allows easy re-editing of multi-line
commands.
 
 If set,   changes its behavior to that of version 3.1 with respect to quoted arguments to the conditional command's =~ operator.

 
 If set,   changes its behavior to that of version 3.2 with respect to locale-specific string comparison when using the conditional command's <
and > operators.
 
 If set,   changes its behavior to that of version 4.0 with respect to locale-specific string comparison when using the conditional command's <
and > operators and the effect of interrupting a command list.
 
 If set,   attempts spelling correction on directory names during word completion if the directory name initially supplied does not exist.

 If set,   includes filenames beginning with a '.' in the results of pathname expansion.
 
 If set, a non-interactive shell will not exit if it cannot execute the file specified as an argument to the   builtin command. An interactive
shell does not exit if   fails.
 
 If set, aliases are expanded as described above under   This option is enabled by default for interactive
shells.
 
 If set, behavior intended for use by debuggers is enabled:
 The   option to the   builtin displays the source file name and line number corresponding to each function name supplied as an
argument.

 
 If the command run by the   trap returns a non-zero value, the next command is skipped and not executed.

 
 If the command run by the   trap returns a value of 2, and the shell is executing in a subroutine (a shell function or a shell script executed by
the   or   builtins), a call to   is simulated.

 
  and   are updated as described in their descriptions above.

 
 Function tracing is enabled: command substitution, shell functions, and subshells invoked with       inherit the   and
  traps.

 
 Error tracing is enabled: command substitution, shell functions, and subshells invoked with       inherit the   trap.

 
 If set, the extended pattern matching features
 
 If set,  ' ' and  " " quoting is performed within   expansions enclosed in double
quotes. This option is enabled by default.
 
 If set, patterns which fail to match filenames during pathname expansion result in an expansion error.
 
 If set, the suffixes specified by the   shell variable cause words to be ignored when performing word completion even if the
ignored words are the only possible completions. See   above for a description of
  This option is enabled by default.
 
 If set, the pattern   used in a pathname expansion context will match a files and zero or more directories and subdirectories. If the pattern is
followed by a  , only directories and subdirectories match.
 
 If set, shell error messages are written in the standard GNU error message format.
 
 If set, the history list is appended to the file named by the value of the   variable when the shell exits, rather than
overwriting the file.
 
 If set, and   is being used, a user is given the opportunity to re-edit a failed history substitution.
 
 If set, and   is being used, the results of history substitution are not immediately passed to the shell parser. Instead, the resulting line
is loaded into the   editing buffer, allowing further modification.
 
 If set, and   is being used,   will attempt to perform hostname completion when a word containing a   is being completed (see
  under   above). This is enabled by default.
 
 If set,   will send   to all jobs when an interactive login shell exits.
 
 If set, allow a word beginning with   to cause that word and all remaining characters on that line to be ignored in an interactive shell (see
  above). This option is enabled by default.
 If set, and the   option is enabled, multi-line commands are saved to the history with embedded newlines rather than using semicolon separators
where possible.
 
 The shell sets this option if it is started as a login shell (see   above). The value may not be changed.

 
 If set, and a file that   is checking for mail has been accessed since the last time it was checked, the message ''The mail in   has
been read'' is displayed.
 
 If set, and   is being used,   will not attempt to search the   for possible completions when completion is
attempted on an empty line.
 
 If set,   matches filenames in a case-insensitive fashion when performing pathname expansion (see   above).

 
 If set,   matches patterns in a case-insensitive fashion when performing matching while executing   or   conditional
commands.
 
 If set,   allows patterns which match no files (see   above) to expand to a null string, rather than themselves.

 
 If set, the programmable completion facilities (see   above) are enabled. This option is enabled by default.

 
 If set, prompt strings undergo parameter expansion, command substitution, arithmetic expansion, and quote removal after being expanded as described in
  above. This option is enabled by default.
 
 The shell sets this option if it is started in restricted mode (see   below). The value may not be changed. This is not
reset when the startup files are executed, allowing the startup files to discover whether or not a shell is restricted.
 
 If set, the   builtin prints an error message when the shift count exceeds the number of positional parameters.
 
 If set, the   ( ) builtin uses the value of   to find the directory containing the file supplied as an argument.
This option is enabled by default.
 
 If set, the   builtin expands backslash-escape sequences by default.
 Expressions may be combined using the following operators, listed in decreasing order of precedence. The evaluation depends on the number of arguments; see
below.
 True if   is false.
 
 Returns the value of  . This may be used to override the normal precedence of operators.
 
 True if both   and   are true.
 
 True if either   or   is true.
 
 The expression is false.
 
 The expression is true if and only if the argument is not null.
 
 If the first argument is  , the expression is true if and only if the second argument is null. If the first argument is one of the unary conditional
operators listed above under   the expression is true if the unary test is true. If the first
argument is not a valid unary conditional operator, the expression is false.
 
 If the second argument is one of the binary conditional operators listed above under   the
result of the expression is the result of the binary test using the first and third arguments as operands. The   and   operators are considered
binary operators when there are three arguments. If the first argument is  , the value is the negation of the two-argument test using the second and
third arguments. If the first argument is exactly   and the third argument is exactly  , the result is the one-argument test of the second
argument. Otherwise, the expression is false.
 
 If the first argument is  , the result is the negation of the three-argument expression composed of the remaining arguments. Otherwise, the
expression is parsed and evaluated according to precedence using the rules listed above.
 
 The expression is parsed and evaluated according to precedence using the rules listed above.
 Print the accumulated user and system times for the shell and for processes run from the shell. The return status is 0.
 If a   is   (0) the command   is executed on exit from the shell. If a   is
  the command   is executed before every  ,   command,   command,
  command, every arithmetic   command, and before the first command executes in a shell function (see  
above). Refer to the description of the   option to the   builtin for details of its effect on the   trap. If a
  is   the command   is executed each time a shell function or a script executed with the
  or   builtins finishes executing.
 If a   is   the command   is executed whenever a simple command has a non-zero exit status,
subject to the following conditions. The   trap is not executed if the failed command is part of the command list immediately following
a   or   keyword, part of the test in an   statement, part of a command executed in a   or   list, or if
the command's return value is being inverted via  . These are the same conditions obeyed by the   option.
 Signals ignored upon entry to the shell cannot be trapped, reset or listed. Trapped signals that are not being ignored are reset to their original values in
a subshell or subshell environment when one is created. The return status is false if any   is invalid; otherwise   returns
true.
 All current limits are reported

 
 The maximum socket buffer size

 
 The maximum size of core files created

 
 The maximum size of a process's data segment

 
 The maximum scheduling priority ("nice")

 
 The maximum size of files written by the shell and its children

 
 The maximum number of pending signals

 
 The maximum size that may be locked into memory

 
 The maximum resident set size (many systems do not honor this limit)

 
 The maximum number of open file descriptors (most systems do not allow this value to be set)

 
 The pipe size in 512-byte blocks (this may not be set)

 
 The maximum number of bytes in POSIX message queues

 
 The maximum real-time scheduling priority

 
 The maximum stack size

 
 The maximum amount of cpu time in seconds

 
 The maximum number of processes available to a single user

 
 The maximum amount of virtual memory available to the shell

 
 The maximum number of file locks

 
 The maximum number of threads
 
 
 If   is started with the name  , or the   option is supplied at invocation, the shell becomes restricted. A restricted shell is
used to set up an environment more controlled than the standard shell. It behaves identically to   with the exception that the following are
disallowed or not performed:
 • setting or unsetting the values of   or  
 • specifying command names containing  
 • specifying a file name containing a   as an argument to the   builtin command

 • Specifying a filename containing a slash as an argument to the   option to the   builtin command

 • importing function definitions from the shell environment at startup

 • parsing the value of   from the shell environment at startup

 • redirecting output using the >, >|, <>, >&, &>, and >> redirection operators

 • using the   builtin command to replace the shell with another command

 • adding or deleting builtin commands with the   and   options to the   builtin command

 • Using the   builtin command to enable disabled shell builtins

 • specifying the   option to the   builtin command

 • turning off restricted mode with   or  .
 When a command that is found to be a shell script is executed (see   above),   turns off any restrictions
in the shell spawned to execute the script.
 
 
 , Brian Fox and Chet Ramey
 
 
 
 
 
 Brian Fox, Free Software Foundation 
 
 Chet Ramey, Case Western Reserve University 
 
 
 If you find a bug in   you should report it. But first, you should make sure that it really is a bug, and that it appears in the latest version
of  . The latest version is always available from  .
 Once you have determined that a bug actually exists, use the   command (from the source package) to submit a bug report. If you have a fix, you
are encouraged to mail that as well! Suggestions and 'philosophical' bug reports may be mailed to   or posted to the Usenet newsgroup
 .
 ALL bug reports should include:
 
 
 It's too big and too slow.
 There are some subtle differences between   and traditional versions of  , mostly because of the  
specification.
 Aliases are confusing in some uses.
 Shell builtin commands and functions are not stoppable/restartable.
 Compound commands and command sequences of the form 'a ; b ; c' are not handled gracefully when process suspension is attempted. When a process is stopped,
the shell immediately executes the next command in the sequence. It suffices to place the sequence of commands between parentheses to force it into a subshell,
which may be stopped as a unit.
 Array variables may not (yet) be exported.
 There may be only one active coprocess at a time.

  google_ad_section_end  
 
 (1),
 (1),
 (1),
 (7),
 (5),
 (7),
 (8),
 (5),
 (7),
 (1),
 (5),
 (1),
 (3),
 (5),
 (5),
 (5),
 (1),
 (1),
 (3),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (5),
 (1),
 (2),
 (7),
 (3),
 (1),
 (1),
 (1),
 (3),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1)
 
 Execute   command without any arguments to instantly navigate to your user home directory from any location. Execute   to toggle between your last two visited locations. In what directory you end up after executing   and   commands? Regardless of the script complexity, do not attempt to write your entire script in one go. Slowly develop your script by testing each core line by executing it first on the terminal command line. When successful, transfer it to your shell script. Enter   command to learn more about all   command line options used within the previous   script. Try to run the   command without   option prefix! Does it work? Never name your private variables using UPPERCASE characters. This is because uppercase variable names are reserved for  , and you run a risk of overwriting them. This may lead to the dysfunctional or misbehaving script execution.  When unsure whether your command produced   or   try to redirect its output. For example, if you are able to redirect its output successfully to a file with   notation, it means that your command produced  . Conversely, successfully redirecting command output with   notation is indicating that your command produced  .  The moment you notice that your script contains two lines of the same code, you may consider to enact a function instead.  Read manual pages, if you wish to learn more about  ,   and   command's options used by our   bash script. Example:    Comparing strings with integers using numeric comparison operators will result in the error:  . When comparing values, you may want to use   command first to confirm that your variables hold expected values before using them as part of the comparison operation.  Can you rewrite the if_else.sh script to reverse the logic of its execution in a way that the else block gets executed if the variable   is less than variable  ? Check bash manual page with   command for more information about  ,   and other bash options. Currently, the default storage directory is  . Perhaps the script could be more flexible? Can you think of a way to use positional parameter   to let the user to decide on which directory to use to store the resulting backup file?  Rewrite the above character count for loop to print names of all files and directories inside your current working directory along with the number of characters each file and directory name consists from. The for loop output should look similar to:
 
 The current script does not check for the existence of user directories prior to the backup function execution. This can lead to unforeseen consequences. Do you think that you would be able to create your own improved copy of the backup script by defining a separate loop to check the existence of all user directories before the backup for loop is reached? You for loop will exit the script's execution if any of the user directories on the supplied list does not exist. Can you use the arithmetic expansion to perform a modulus operation? For example what is the result of modulus operation  ? Experiment with the backup.sh script. The script is far from being perfect, add new features or fix current features. Do not be afraid to break things as that is perfectly normal. Troubleshooting and fixing code is perhaps the best booster for you to enhance your understanding of bash scripting and to improve your ability to script beyond what has been discussed in this tutorial.  Join   and get a daily digest of news, geek trivia, and our feature articles. The Windows Subsystem for Linux, introduced in the  , became a stable feature in the  . You can now run Ubuntu and openSUSE on Windows, with Fedora and more Linux distributions coming soon.   This isn’t a  , a container, or Linux software compiled for Windows (like  ). Instead, Windows 10 offers a full Windows Subsystem intended for Linux for running Linux software. It’s based on Microsoft’s abandoned Project Astoria work for running Android apps on Windows. Think of it as the opposite of  . While Wine allows you to run Windows applications directly on Linux, the Windows Subsystem for Linux allows you to run Linux applications directly on Windows. Microsoft worked with Canonical to offer a full Ubuntu-based Bash shell environment that runs atop this subsystem. Technically, this isn’t Linux at all. Linux is the underlying operating system kernel, and that isn’t available here. Instead, this allows you to run the Bash shell and the exact same binaries you’d normally run on Ubuntu Linux. Free software purists often argue the average Linux operating system   because it’s really a lot of GNU software running on the Linux kernel. The Bash shell you’ll get is really just all those GNU utilities and other software. While this feature was originally called “Bash on Ubuntu on Windows,” it also allows you to  . It now supports other Linux distributions, too. You can choose openSUSE Leap or SUSE Enterprise Server instead of Ubuntu, and Fedora is also on its way. There are some limitations here. This doesn’t yet support background server software, and it won’t officially work with  . Not every command-line application works, either, as the feature isn’t perfect.   This feature doesn’t work on the 32-bit version of Windows 10, so  . It’s time to   if you’re still using the 32-bit version, anyway. Assuming you have 64-bit Windows, to get started, head to Control Panel > Programs > Turn Windows Features On Or Off. Enable the “Windows Subsystem for Linux” option in the list, and then click the “OK” button. Click “Restart now” when you’re prompted to restart your computer. The feature won’t work until you reboot. : Starting with the Fall Creators Update, you no longer have to enable Developer Mode in the Settings app to use this feature. You just need to install it from  . After your computer restarts, open the Microsoft Store from the Start menu, and search for “Linux” in the store. Click “Get the apps” under the “Linux on Windows?” banner. : Starting with the Fall Creators Update, you can no longer install Ubuntu by running the “bash” command. Instead, you have to install Ubuntu or another Linux distribution from the Store app.   You’ll see a list of every Linux distribution currently available in the Windows Store. As of the Fall Creators Update, this includes  , with a promise that Fedora will arrive soon. :   and   are now available in the Store, but aren’t listed here. Search for “Debian Linux” or “Kali Linux” to find and install them. To install a Linux distribution, click it, and then click the “Get” or “Install” button to install it like any other Store application. If you’re not sure which Linux environment to install, we recommend Ubuntu. This popular Linux distribution was previously the only option available, but other Linux systems are now available for people who have more specific needs. You can also install multiple Linux distributions and they’ll each get their own unique shortcuts. You can even run multiple different Linux distributions at a time in different windows.   You now have a full command-line bash shell based on Ubuntu, or whatever other Linux distribution you installed. Because they’re the same binaries, you can   to install software from Ubuntu’s repositories if you’re using Ubuntu. Just use whatever command you’d normally use on that Linux distribution. You’ll have access to all the Linux command line software out there, although some applications may not yet work perfectly. To open the Linux environment you installed, just open the Start menu and search for whatever distribution you installed. For example, if you installed Ubuntu, launch the Ubuntu shortcut. You can pin this application shortcut to your Start menu, taskbar, or desktop for easier access. The first time you launch the Linux environment, you’re be prompted to enter a UNIX username and password. These don’t have to match your Windows username and password, but will be used within the Linux environment. For example, if you enter “bob” and “letmein” as your credentials, your username in the Linux environment will be “bob” and the password you use inside the Linux environment will be “letmein”—no matter what your Windows username and password are.   You can launch your installed Linux environment by running the   command. If you have multiple Linux distributions installed, you can   this command launches. If you have Ubuntu installed, you can also run the   command to install it. For openSUSE Leap 42, use    . For SUSE Linux Enterprise Sever 12, use   . These commands are listed on each Linux distribution’s page on the Windows Store. You can still launch your default Linux environment by running the   command, but Microsoft says this is deprecated. This means the   command may stop functioning in the future. If you’re experienced using a Bash shell on Linux, Mac OS X, or other platforms, you’ll be right at home. On Ubuntu, you need to prefix a command with    to  . The “root” user on UNIX platforms has full system access, like the “Administrator” user on Windows. Your Windows file system is located at   in the Bash shell environment. Use the same Linux terminal commands you’d use to get around. If you’re used to the standard Windows Command Prompt with its DOS commands, here are a few basic commands common to both Bash and Windows:   It’s important to remember that, unlike Windows, the Bash shell and its Linux-imitating environment are case-sensitive. In other words, “File.txt” with a capital letter is different from “file.txt” without a capital. For more instructions, consult   and other similar introductions to the Bash shell, Ubuntu command line, and Linux terminal online. You’ll need to   to install and update the Ubuntu environment’s software.  Be sure to prefix these commands with   , which makes them run as root–the Linux equivalent of Administrator. Here are the apt-get commands you’ll need to know: If you installed a SUSE Linux distribution, you can use the   to install software instead. After you’ve downloaded and installed an application, you can type its name at the prompt, and then press Enter to run it. Check that particular application’s documentation for more details. If you want a more accurate Ubuntu experience on Windows 10, you can also install the Ubuntu fonts and enable them in the terminal. You don’t have to do this, as the default Windows command prompt font looks pretty good to us, but it’s an option. Here’s what it looks like: To install the font, first download the   from Ubuntu’s website. Open the downloaded .zip file and locate the “UbuntuMono-R.ttf” file. This is the Ubuntu monospace font, which is the only one used in the terminal. It’s the only font you need to install. Double-click the “UbuntuMono-R.ttf” file and you’ll see a preview of the font. Click “Install” to install it to your system.   To make the Ubuntu monospace font become an option in the console, you’ll need to add a setting to  . Open a registry editor by pressing Windows+R on your keyboard, typing   , and then pressing Enter. Navigate to the following key or copy and paste it into the Registry Editor’s address bar: Right-click in the right pane and select New > String Value. Name the new value   . Double-click the “000” string you just created, and then enter   as its value data. Launch an Ubuntu window, right-click the title bar, and then select the “Properties” command. Click the “Font” tab, and then select “Ubuntu Mono” in the font list. Software you install in the Bash shell is restricted to the Bash shell. You can access these programs from the Command Prompt, PowerShell, or elsewhere in Windows, but only if you  . JOIN GEEK TALK ON FACEBOOK Facebook Twitter LinkedIn The Best Tech Newsletter Anywhere The Best Tech Newsletter Anywhere Join   and get a daily digest of news, comics, trivia, reviews, and more. Sridhar has developed technical communication artifacts and has a master's degree in Software Systems. Want to watch this again later?       If you want to speak to someone who doesn't know your language, you will need an interpreter to translate the conversation between you and the other person. Similarly, if you want to run a command on a computer, the computer also needs an interpreter to understand the command and execute it.  On Linux, the interpreter that can understand the user commands and settings and pass them on to the computer for further processing is called a  . Here are a few shells on Linux:  On most Linux systems,  , called the  , is set as the default shell. The bash shell is also responsible for letting the users configure a set of user preferences or settings, also known as a user environment.  To know if bash exists on a Linux system, run the following command to display the contents of the   file:    The output will look something like this. It is a list of all the shells available on the system:            Apart from the commands you enter, bash can run a set of commands from a file, called a  , which we will refer to as a script going forward. Thus, bash is also a programming language in its own right. It contains its own syntax and programming constructs such as break, continue, exit, exec, return, and so on.  In Linux, everything is a file, be it a regular file with text in it or a device file. As a shell, bash regularly deals with three common files for standard input and output (I/O):  By default, these files are always open. Whenever a file is open in Linux, it is assigned a number called a   to keep track of it. If you are familiar with the C programming language, a file descriptor is similar to a file handle or a pointer.  Thus, stdin, stdout, and stderr are assigned the file descriptors  ,  , and   respectively. In the bash shell commands and scripts, they standard I/O are referred to as  ,  , and  , respectively. When other files are open, they get assigned the file descriptors between 3 and 9.  Imagine a simple command:    In this example,   is the command followed by   as the argument for the command. This is an example of a simple command.  In reality, you might have to run a sequence of complex commands that includes a set of simple commands. Typically, if we had to bring all of them together to run in a particular sequence, you would have to do put the commands in a programming construct such as a loop or conditions.  In Linux, you can use a method called as   by putting the commands in a pipeline. You can use   to gather the output of one command and redirect it as the input of another command.    Get access risk-free for 30 days,
			 just create an account. The command   displays the contents of the   on the standard output, the screen. When its output is redirected to the   command, the contents of the   file are displayed one screen at a time. That's the power of redirection using pipes!  Imagine you have a gunzipped file of a tar file. To extract the actual contents of the file, you would have to run two commands to first extract the tar file and then extract the tar file, as follows:  With the simplicity and the elegance of redirection, the same result can be obtained using the following command:    Therefore, redirection helps you to gather the output from a script, a program, a command, or a file and redirect it as input to another script, a program, a command, or a file.  We learned that each command is associated with three standard I/O files - a stdin (fd 0), stdout (fd 1), and a stderr (fd 2).  If you want to send the stderr output to stdout, run the following command:    The   notation refers to the address of fd 1, stdout.  Sometimes, you might want to close a file descriptor for a specific reason or after a job is done.  For example, to close stdout, run the following command:    In this lesson, we discovered the Linux shells and explored the   shell.  We learned that a bash command is attached to three standard input and output (I/O) files:  Further, they are assigned the   of 0, 1, and 2 respectively. Any other open file is assigned a file descriptor between 3 and 9.  Through examples, we learned redirection through pipes, which is a method to redirect the input from one command/script as the input of another. 
 
			To unlock this lesson you must be a Study.com Member.
			 Already a member?  
		Already registered?
		
		 
 Did you know… We have over 200 college
						courses that prepare you to earn
						credit by exam that is accepted by over 1,500 colleges and universities. You can test out of the
						first two years of college and save thousands off your degree. Anyone can earn
						credit-by-exam regardless of age or education level. To learn more, visit our  Not sure what college you want to attend yet? Study.com has thousands of articles about every
							imaginable degree, area of
							study
							and career path that can help you find the school that's right for you. Get the unbiased info you need to find the right school. Browse an area of study or degree level.  Back To Course 
  chapters |
				  lessons
				
			 
  chapters |
				  lessons
				 
 Next Lesson ©  copyright 2003-2020 Study.com.
			All other trademarks and copyrights are the property of their respective owners.
			All rights reserved.
		 
Next:  , Up:     [ ][ ] Bash is the shell, or command language interpreter,
for the   operating system.
The name is an acronym for the ‘ ’,
a pun on Stephen Bourne, the author of the direct ancestor of
the current Unix shell  , 
which appeared in the Seventh Edition Bell Labs Research version
of Unix.
 Bash is largely compatible with   and incorporates useful
features from the Korn shell   and the C shell  .
It is intended to be a conformant implementation of the  
  Shell and Tools portion of the    
specification (  Standard 1003.1).
It offers functional improvements over   for both interactive and
programming use.
 While the   operating system provides other shells, including
a version of  , Bash is the default shell.
Like other   software, Bash is quite portable.  It currently runs
on nearly every version of Unix and a few other operating systems -
independently-supported ports exist for  ,  ,
and Windows platforms.
 
 
 Get the highlights in your inbox every week. When a computer boots up, a kernel (whether it's Linux, BSD, Mach, or NT) recognizes all the physical hardware and enables each component to talk with one another and be orchestrated by some basic software. A computer's most basic set of instructions simply keeps it powered on and in a safe state: activating fans periodically to prevent overheating, using subsystems to monitor disk space or "listen" for newly attached devices, and so on. If this was all computers did, they'd be about as interesting as a convection oven. Computer scientists recognized this early on, so   a   for Unix computers that operates outside of the kernel (or   the kernel, like a shell in nature) and allows humans to interact with the computer whenever they want to. It was an exciting development at a time when people were feeding punchcards into computers to tell them what to do. Of all the shells available, Bash is one of the most popular, the most powerful, and the most friendly. When you start a terminal (such as the   or   on Linux or   on macOS) running the Bash shell, you're greeted with a  . A prompt is a symbol, usually a dollar sign ( ), indicating that the shell is waiting for your input. Of course, knowing what you're supposed to type is another matter entirely. This probably comes across as unfriendly, but it's actually a perfectly succinct representation of the many connotations around the term "Bash." To many new users, there's no separation between the concept of Bash and the concept of Linux or Unix: it's the proverbial black-screen-with-green-text into which you're supposed to code what your computer does next. That conflates the Bash shell with the   you type into the shell. It's important to understand that they're two separate things: Bash is just an application, and its primary job is to run   applications (in the form of commands) that are installed on the same system. You can learn Bash, but only in the context of learning the operating system that it's running on. Without knowing commands, there's not much you can do with Bash. On Linux and Unix (such as BSD and macOS), most commands are stored by default in system directories like   and  . By nature, Bash doesn't know these commands any more than you naturally know Klingonese, but just as you can look up Klingon words, Bash can look up commands. When you issue a command to Bash, it searches specific directories on your system to see whether such a command exists. If the command does exist, then Bash executes it. Bash is also a command, and it's usually the default command executed when you open a terminal window or log into a text console. To find out where any command is located on your system, Bash included, you can use the   command in a terminal: A few commands are built into Bash. Most built-in commands are specific to Bash scripting or low-level environment settings, but a few are universally useful, such as   (for  ). Built-in commands don't show up when you search for them because they don't exist in your usual executable path: They're still available, though, because they're built into Bash, and Bash is what you're running. Most modern Linux and Unix distributions provide a Bash shell by default. They do this because Bash is well-known, and it has several convenience functions that other shells don't. However, some systems use another shell by default. To find out whether you're running a Bash shell, you can use the   command along with a special variable representing the name of the currently running process: If you're not running Bash, but you'd like to try it, you can probably download and   from your software center, software repository, or ports tree. Or you can use   or Homebrew on macOS. If all else fails, visit the   for more information. Bash is a legitimate interface to your computer, and it's not just for server admins and programmers. It can be your desktop, your word processor, your graphics editing application, and much, much more. Some people use Bash more than they use desktop apps. There are hundreds of commands available for Linux and Unix, and it might surprise you just how diverse they are. For instance, you can resize and crop photos without ever opening the photo in a viewer or editor: You can play music with commands like   or  , convert audio with  , adjust and edit video with  , edit text with   or  , check email with   or  , browse the internet with  , browse files with   or  , and do much, much more. It's all done in Bash, using the commands you find on your system or in your software repository. One reason Bash (and Linux in general) is considered so powerful is because it's scriptable. Anything you can type into Bash manually, you can also list in a plain-text file and have Bash run it for you. Instead of spending an afternoon manually running a hundred commands, you can   the commands and have your computer execute them while you tend to more important matters. Because nearly everything on Linux runs on top of the Bash shell, nearly everything on Linux can be scripted through Bash. While there are exceptions to this (graphical applications may have their own scripting language, for instance, or no scripting at all), scripting your OS opens up tens of thousands of possible functions you can make happen on your computer without doing them yourself. The amount of work this saves Linux users each day is impossible to estimate. It's not the usual automation that makes the difference, though; it's the bespoke workflows that people invent for themselves, the things nobody else thinks need automation. When experienced users say that they want to learn Bash, if they don't mean they want to learn Linux commands, then they probably mean that they want to improve the way they script their commands. For instance, this is an extremely rudimentary Bash script that converts a temporary file (imagine it's a file created by a separate process) to a specific directory: That's valid Bash. You can verify it by copying and pasting the command (the last line beginning with  ) into a terminal. As long as there's a file called   and a directory called  , the command works. Learning Bash, though, is all about understanding how a simple command like this can be improved for the sake of automation. For instance, if the file   doesn't exist, then the script fails. If this script is a key component to, for instance, a blogging site that requires a new image each day so that a custom header image can be constructed, then the script's failure could cause catastrophic errors elsewhere. A user who knows Bash could add resiliency using Bash syntax: This is just one example of the process of learning to script with Bash, but it demonstrates how learning both Linux and Bash are equally useful and not entirely separate tasks. Bash is as powerful as other shells but adds convenience functions like the double brackets (  and  ) in the sample code. These "Bashisms" are much loved by Bash users because they avoid the sometimes verbose and awkward syntax in other shells like tcsh or ash. However, they are unique to Bash and are not  -compliant, which could cause compatibility issues on systems not running Bash. Then again, Bash is open source  , so most users can install it if they need it. The lack of compatibility only forces an extra dependency and does not exclude anyone from using a script. If you want to learn Bash, you can read any number of   on  . Or, you can take an   and even join in on some no-cost  . Best of all, you can also   to learn Bash. Good luck, and happy hacking! Get the highlights in your inbox every week.  
 For more discussion on open source and the role of the CIO in the enterprise, join us at  . The opinions expressed on this website are those of each author, not of the author's employer or of Red Hat. Opensource.com aspires to publish all content under a   but may not be able to do so in all cases. You are responsible for ensuring that you have the necessary permission to reuse any work on this site. Red Hat and the Red Hat logo are trademarks of Red Hat, Inc., registered in the United States and other countries. Copyright ©2020 Red Hat, Inc. The following topics of bash programming are covered in this article. You can run bash script from the terminal or by executing any bash file. Run the following command from the terminal to execute a very simple bash statement. The output of the command will be ‘ ’. Open any editor to create a bash file. Here,   editor is used to create the file and filename is set as ‘ Add the following bash script to the file and save the file. You can run bash file by two ways. One way is by using bash command and another is by setting execute permission to bash file and run the file. Both ways are shown here. You can use echo command with various options. Some useful options are mentioned in the following example. When you use ‘ ’ command without any option then a newline is added by default.   option is used to print any text without new line and   option is used to remove backslash characters from the output. Create a new bash file with a name, ‘ ’ and add the following script. Run the file with bash command.  symbol is used to add single line comment in bash script. Create a new file named ‘  and add the following script with single line comment. Run the file with bash command. You can use multi line comment in bash in various ways. A simple way is shown in the following example. Create a new bash named,   and add the following script. Here,   and   symbols are used to add multiline comment in bash script. This following script will calculate the square of 5. Run the file with bash command. You can check the following link to know more about the use of bash comment. Create a bash file with the name,   to know the use of   loop. In the example,   loop will iterate for   times. The value of   variable will increment by   in each step. When the value of   variable will 5 then the   loop will terminate. Run the file with bash command. You can check the following link to know more about the use of while loop. The basic   loop declaration is shown in the following example. Create a file named ‘ ’ and add the following script using   loop. Here,   loop will iterate for   times and print all values of the variable,   in single line. Run the file with bash command. You can use for loop for different purposes and ways in your bash script. You can check the following link to know more about the use of for loop. ‘ ’ command is used to take input from user in bash. Create a file named ‘ ’ and add the following script for taking input from the user. Here, one string value will be taken from the user and display the value by combining other string value. Run the file with bash command. You can check the following link to know more about the use of user input. You can use if condition with single or multiple conditions. Starting and ending block of this statement is define by   and  . Create a file named ‘ ’ with the following script to know the use   statement in bash. Here,   is assigned to the variable,  . if the value of   is less than 10 then the output will be “ ”, otherwise the output will be “ ”. For comparison,   is used here. For comparison, you can also use   for  ,   for   and   for   in bash script. Run the file with bash command. Different types of logical conditions can be used in if statement with two or more conditions. How you can define multiple conditions in if statement using   logic is shown in the following example.  is used to apply   logic of   statement. Create a file named   to check the following code. Here, the value of   and  variables will be taken from the user and compared with ‘ ’ and ‘ ’. If both values match then the output will be “ ”, otherwise the output will be “ ”. Run the file with bash command. ‘ ’ is used to define   logic in   condition. Create a file named  with the following code to check the use of   logic of   statement. Here, the value of   will be taken from the user. If the value is equal to   or  then the output will be “ ”, otherwise the output will be “ ”. Run the file with bash command. The use of   condition is little different in bash than other programming language. ‘ ’ is used to define   condition in bash. Create a file named, ‘ ’ and add the following script to check how   is defined in bash script. Run the file with bash command.  statement is used as the alternative of   statement. The starting and ending block of this statement is defined by ‘ ’ and ‘ ’. Create a new file named, ‘ ’ and add the following script. The output of the following script will be same to the previous  example. Run the file with bash command. Bash script can read input from command line argument like other programming language. For example,   and   variable are used to read first and second command line arguments. Create a file named “ ” and add the following script. Two argument values read by the following script and prints the total number of arguments and the argument values as output. Run the file with bash command. You can check the following link to know more about the use of command line argument. How you can read command line arguments with names is shown in the following script. Create a file named, ‘  and add the following code. Here, two arguments,  and   are read by this script and print the sum of X and Y. Run the file with bash command and with two command line arguments. You can easily combine string variables in bash. Create a file named “ ” and add the following script to check how you can combine string variables in bash by placing variables together or using   operator. Run the file with bash command. Like other programming language, bash has no built-in function to cut value from any string data. But you can do the task of substring in another way in bash that is shown in the following script. To test the script, create a file named ‘ ’ with the following code. Here, the value,   indicates the starting point from where the substring will start and   indicates the length of the substring. Run the file with bash command. You can do the arithmetical operations in bash in different ways. How you can add two integer numbers in bash using double brackets is shown in the following script. Create a file named ‘ ’ with the following code. Two integer values will be taken from the user and printed the result of addition. Run the file with bash command. You can check the following link to know more about bash arithmetic. How you can create a simple function and call the function is shown in the following script. Create a file named ‘ ’ and add the following code. You can call any function by name only without using any bracket in bash script. Run the file with bash command. Bash can’t declare function parameter or arguments at the time of function declaration. But you can use parameters in function by using other variable. If two values are passed at the time of function calling then $1 and $2 variable are used for reading the values. Create a file named ‘ ’ and add the following code. Here, the function, ‘  will calculate the area of a rectangle based on the parameter values. Run the file with bash command. Bash function can pass both numeric and string values. How you can pass a string value from the function is shown in the following example. Create a file named, ‘ ’ and add the following code. The function,   returns a string value into the variable,   which prints later by combining with other string. Run the file with bash command. You can check the following link to know more about the use of bash function. Bash uses ‘ ’ command to create a new directory. Create a file named ‘ ’ and add the following code to take a new directory name from the user. If the directory name is not exist in the current location then it will create the directory, otherwise the program will display error. Run the file with bash command. If you want to check the existence of directory in the current location before executing the ‘ ’ command then you can use the following code.  ’ option is used to test a particular directory is exist or not. Create a file named, ‘  and add the following code to create a directory by checking existence. Run the file with bash command. You can check the following link to know more about directory creation. You can read any file line by line in bash by using loop. Create a file named, ‘ ’ and add the following code to read an existing file named, ‘ ’. Run the file with bash command. Run the following command to check the original content of ‘ ’ file. You can check the following link to know the different ways to read file. ‘ ’ command is used in bash to remove any file. Create a file named ‘ ’ with the following code to take the filename from the user and remove. Here,   option is used to get permission from the user before removing the file. Run the file with bash command. New data can be added into any existing file by using   operator in bash. Create a file named  ’ and add the following code to add new content at the end of the file. Here, ‘ ’ will be added at the of ‘  file after executing the script. Run the file with bash command. You can check the existence of file in bash by using   or   option.   option is used in the following script to test the file existence. Create a file named, ‘ ’ and add the following code. Here, the filename will pass from the command line. Run the following commands to check the existence of the file. Here,   file exists and    is not exist in the current location. You can send email by using ‘ ’ or ‘ ’ command. Before using these commands, you have to install all necessary packages. Create a file named, ‘ ’ and add the following code to send the email. Run the file with bash command. You can get the current system date and time value using ` ` command. Every part of date and time value can be parsed using ‘  and ‘ . Create a new file named ‘  and add the following code to separate day, month, year, hour, minute and second values. Run the file with bash command.   is a built-in command of Linux that waits for completing any running process.   command is used with a particular process id or job id. If no process id or job id is given with wait command then it will wait for all current child processes to complete and returns exit status. Create a file named ‘  and add the following script. Run the file with bash command. You can check the following link to know more about wait command. When you want to pause the execution of any command for specific period of time then you can use   command. You can set the delay amount by   Create a file named   and add the following script. This script will wait for 5 seconds after running. Run the file with bash command. You can check the following link to know more about sleep command. Hope, after reading this article you have got a basic concept on bash scripting language and you will be able to apply them based on your requirements.
 I am a trainer of web programming courses. I like to write article or tutorial on various IT topics. I have a YouTube channel where many types of tutorials based on Ubuntu, Windows, Word, Excel, WordPress, Magento, Laravel etc. are published:  . Powered by  
 
 
 Version 1.11 Last updated 20081227 Edition  The primary reason for writing this document is that a lot of readers feel the existing   to be too short and incomplete, while the   guide is too much of a reference work.  There is nothing in between these two extremes.  I also wrote this guide on the general principal that not enough free basic courses are available, though they should be. This is a practical guide which, while not always being too serious, tries to give real-life instead of theoretical examples.  I partly wrote it because I don't get excited with stripped down and over-simplified examples written by people who know what they are talking about, showing some really cool Bash feature so much out of its context that you cannot ever use it in practical circumstances.  You can read that sort of stuff after finishing this book, which contains exercises and examples that will help you survive in the real world. From my experience as UNIX/Linux user, system administrator and trainer, I know that people can have years of daily interaction with their systems, without having the slightest knowledge of task automation.  Thus they often think that UNIX is not userfriendly, and even worse, they get the impression that it is slow and old-fashioned.  This problem is another one that can be remedied by this guide. Everybody working on a UNIX or UNIX-like system who wants to make life easier on themselves, power users and sysadmins alike, can benefit from reading this book.  Readers who already have a grasp of working the system using the command line will learn the ins and outs of shell scripting that ease execution of daily tasks.  System administration relies a great deal on shell scripting; common tasks are often automated using simple scripts.  This document is full of examples that will encourage you to write your own and that will inspire you to improve on existing scripts. Prerequisites/not in this course: You should be an experienced UNIX or Linux user, familiar with basic commands, man pages and documentation Being able to use a text editor Understand system boot and shutdown processes, init and initscripts Create users and groups, set passwords Permissions, special modes Understand naming conventions for devices, partitioning, mounting/unmounting file systems Adding/removing software on your system See   (or your local  ) if you haven't mastered one or more of these topics.  Additional information can be found in your system documentation (man and info pages), or at  . The most recent edition can be found at  .  You should find the same version at  . This guide is available in print from  . This guide has been translated: Chinese translation at  , by Wang Wei. Ukrainian translation at  , by Yaroslav Fedevych and his team. A french translation is in the making and will be linked to as soon as it is finished.   
 
Thanks to all the friends who helped (or tried to) and to my husband; your encouraging words made this work possible.  Thanks to all the people who submitted bug reports, examples and remarks - among many, many others: Hans Bol, one of the groupies Mike Sim, remarks on style Dan Richter, for array examples Gerg Ferguson, for ideas on the title Mendel Leo Cooper, for making room #linux.be, for keeping my feet on the ground Frank Wang, for his detailed remarks on all the things I did wrong ;-) Special thanks to Tabatha Marshall, who volunteered to do a complete review and spell and grammar check.  We make a great team: she works when I sleep.  And vice versa ;-) 
Missing information, missing links, missing characters, remarks?  Mail it to 
 
the maintainer of this document.
 The author and publisher have made every effort in the preparation of this book to ensure the accuracy of the information.  However, the information contained in this book is offered without warranty, either express or implied.  Neither the author nor the publisher nor any dealer or distributor will be held liable for any damages caused or alleged to be caused either directly or indirectly by this book. The logos, trademarks and symbols used in this book are the properties of
their respective owners. , available from  .  The Bash shell is available on nearly every Linux system, and can these days be found on a wide variety of UNIX systems. Compiles easily if you need to make your own, tested on a wide variety of UNIX, Linux, MS Windows and other systems. The following typographic and usage conventions occur in this text:
   This guide discusses concepts useful in the daily life of the serious Bash user.  While a basic knowledge of the usage of the shell is required, we start with a discussion of the basic shell components and practices in the first three chapters. Chapters four to six are discussions of basic tools that are commonly used in shell scripts. Chapters eight to twelve discuss the most common constructs in shell scripts. All chapters come with exercises that will test your preparedness for the
next chapter. : Bash basics: why Bash is so good, building blocks, first guidelines on developing good scripts. : Script basics: writing and debugging. : The Bash Environment: initialization files, variables, quoting characters, shell expansion order, aliases, options. : Regular expressions: an introduction. : Sed: an introduction to the sed line editor. :Awk: introduction to the awk programming language. : Conditional statements: constructs used in Bash to test conditions. : Interactive scripts: making scripts user-friendly, catching user input. : Executing commands repetitively: constructs used in Bash to automate command execution. : Advanced variables: specifying variable types, introduction to arrays of variables, operations on variables. : Functions: an introduction. : Catching signals: introduction to process signalling, trapping user-sent signals. In this introduction module we Describe some common shells Point out GNU Bash advantages and features Describe the shell's building blocks Discuss Bash initialization files See how the shell executes commands Look into some simple script examples The UNIX shell program interprets user commands, which are either directly entered by the user, or which can be read from a file called the shell script or shell program.  Shell scripts are interpreted, not compiled.  The shell reads commands from the script line per line and searches for those commands on the system (see  ), while a compiler converts a program into machine readable form, an executable file - which may then be used in a shell script. Apart from passing commands to the kernel, the main task of a shell is providing a user environment, which can be configured individually using shell resource configuration files. Just like people know different languages and dialects, your UNIX system will usually offer a variety of shell types:  or Bourne Shell: the original shell still
used on UNIX systems and in UNIX-related environments.  This is the basic shell, a small program with few features.  While this is not the standard shell, it is still available on every Linux system for compatibility with UNIX programs.  or Bourne Again shell: the standard GNU
shell, intuitive and flexible.  Probably most advisable for beginning users while being at the same time a powerful tool for the advanced and professional user.  On Linux,   is the standard shell for common users.  This shell is a so-called   of the Bourne shell, a set
of add-ons and plug-ins.  This means that the Bourne Again shell is compatible with the Bourne shell: commands that work in  , also work in
 .  However, the reverse is not always the case.  All examples and exercises in this book use  .  or C shell: the syntax of this shell resembles that of the C programming language.  Sometimes asked for by programmers.  or TENEX C shell: a superset of the common C shell, enhancing user-friendliness and speed.  That is why some also call it the Turbo C shell.  or the Korn shell: sometimes appreciated
by people with a UNIX background.  A superset of the Bourne shell; with standard configuration a nightmare for beginning users. The file   gives an overview of known shells on a Linux system: Your default shell is set in the   file, like this line for user  : To switch from one shell to another, just enter the name of the new shell
in the active terminal.  The system finds the directory where the name occurs using the   settings, and since a shell is an executable file (program), the current shell activates it and it gets executed.  A new prompt is usually shown, because each shell has its typical appearance: The GNU project (GNU's Not UNIX) provides tools for UNIX-like system administration which are free software and comply to UNIX standards. Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use; these include command line editing, unlimited size command history, job control, shell functions and aliases, indexed arrays of unlimited size, and integer arithmetic in any base from two to sixty-four. Bash can run most sh scripts without modification. Like the other GNU projects, the bash initiative was started to preserve, protect and promote the freedom to use, study, copy, modify and redistribute software.  It is generally known that such conditions stimulate creativity.  This was also the case with the bash program, which has a lot of extra features that other shells can't offer. In addition to the single-character shell command line options which can generally be configured using the   shell built-in command, there are several multi-character options that you can use.  We will come across a couple of the more popular options in this and the following chapters; the complete list can be found in the Bash info pages,  -> . Startup files are scripts that are read and executed by Bash when it starts.  The following subsections describe different ways to start the shell, and the startup files that are read consequently. Interactive means you can enter commands.  The shell is not running because a script has been activated.  A login shell means that you got the shell after authenticating to the system, usually by giving your user name and password. Files read: ,   or  : first existing readable file is read  upon logout. Error messages are printed if configuration files exist but are not readable.  If a file does not exist, bash searches for the next. A non-login shell means that you did not have to authenticate to the system.  For instance, when you open a terminal using an icon, or a menu item, that is a non-login shell. Files read: This file is usually referred to in  :   See   for more information on the   construct. All scripts use non-interactive shells.  They are programmed to do certain tasks and cannot be instructed to do other jobs than those for which they are programmed. Files read: defined by   is not used to search for this file, so if you want to use it, best refer to it by giving the full path and file name. Bash tries to behave as the historical Bourne   program while conforming to the POSIX standard as well. Files read: When invoked interactively, the   variable can point to extra startup information. This option is enabled either using the   built-in:   or by calling the   program with the   option.  Bash will then try to behave as compliant as possible to the POSIX standard for shells.  Setting the   variable does the same. Files read: defined by   variable. Files read when invoked by  : Be aware of the dangers when using tools such as  ,  ,   and  .  They are intrinsically insecure because confidential data is sent over the network unencrypted.  If you need tools for remote execution, file transfer and so on, use an implementation of Secure SHell, generally known as SSH, freely available from  .  Different client programs are available for non-UNIX systems as well, see your local software mirror. No startup files are read in this case. An interactive shell generally reads from, and writes to, a user's terminal: input and output are connected to a terminal.  Bash interactive behavior is started when the   command is called upon without non-option arguments, except when the option is a string to read from or when the shell is invoked to read from standard input, which allows for positional parameters to be set (see   ). Test by looking at the content of the special parameter  , it contains an 'i' when the shell is interactive: In non-interactive shells, the prompt,  , is unset. Differences in interactive mode: Bash reads startup files. Job control enabled by default. Prompts are set,   is enabled for multi-line commands, it is usually set to  .  This is also the prompt you get when the shell thinks you entered an unfinished command, for instance when you forget quotes, command structures that cannot be left out, etc. Commands are by default read from the command line using  . Bash interprets the shell option   instead of exiting immediately upon receiving EOF (End Of File). Command history and history expansion are enabled by default.  History is saved in the file pointed to by   when the shell exits.  By default,   points to  . Alias expansion is enabled. In the absence of traps, the   signal is ignored. In the absence of traps,   is caught and handled.  Thus, typing  + , for example, will not quit your interactive shell. Sending   signals to all jobs on exit is configured with the   option. Commands are executed upon read. Bash checks for mail periodically. Bash can be configured to exit when it encounters unreferenced variables.  In interactive mode this behavior is disabled. When shell built-in commands encounter redirection errors, this will not cause the shell to exit. Special built-ins returning errors when used in POSIX mode don't cause the shell to exit.  The built-in commands are listed in  . Failure of   will not exit the shell. Parser syntax errors don't cause the shell to exit. Simple spell check for the arguments to the   built-in is enabled by default. Automatic exit after the length of time specified in the   variable has passed, is enabled. More information: See   for more about signals.  discusses the various expansions performed upon entering a command. Conditional expressions are used by the   compound command and by the   and   built-in commands. Expressions may be unary or binary.  Unary expressions are often used to examine the status of a file.  You only need one object, for instance a file, to do the operation on. There are string operators and numeric comparison operators as well; these are binary operators, requiring two objects to do the operation on.  If the   argument to one of the primaries is in the form  , then file descriptor N is checked.  If the   argument to one of the primaries is one of  ,   or  , then file descriptor 0, 1 or 2 respectively is checked. Conditionals are discussed in detail in  . More information about the file descriptors in  . The shell allows arithmetic expressions to be evaluated, as one of
the shell expansions or by the   built-in. Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error.  The operators and their precedence and associativity are the same as in the C language, see  . Aliases allow a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the   and   commands. Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed. We will discuss aliases in detail in  . Bash provides one-dimensional array variables.  Any variable may be used as an array; the   built-in will explicitly declare an array.  There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously.  Arrays are zero-based.  See  . The directory stack is a list of recently-visited directories.  The   built-in adds directories to the stack as it changes the current directory, and the   built-in removes specified directories from the stack and changes the current directory to the directory removed. Content can be displayed issuing the   command or by checking the content of the   variable. More information about the workings of this mechanism can be found in the Bash info pages. Bash makes playing with the prompt even more fun.  See the section   in the Bash info pages. When invoked as   or with the   or   option, the following happens: The   built-in is disabled. Setting or unsetting  ,  ,   or   is not possible. Command names can no longer contain slashes. Filenames containing a slash are not allowed with the   ( ) built-in command. The   built-in does not accept slashes with the   option. Import of functions at startup is disabled.  is ignored at startup. Output redirection using  ,  ,  ,  ,   and   is disabled. The   built-in is disabled. The   and   options are disabled for the   built-in. A default   cannot be specified with the   built-in. Turning off restricted mode is not possible. When a command that is found to be a shell script is executed,   turns off any restrictions in the shell spawned to execute the script. More information: -> -> : advanced redirection Bash determines the type of program that is to be executed.  Normal programs are system commands that exist in compiled form on your system.  When such a program is executed, a new process is created because Bash makes an exact copy of itself.  This child process has the same environment as its parent, only the process ID number is different.  This procedure is called  . After the forking process, the address space of the child process is overwritten with the new process data.  This is done through an   call to the system. The   mechanism thus switches an old command with a new, while the environment in which the new program is executed remains the same, including configuration of input and output devices, environment variables and priority.  This mechanism is used to create all UNIX processes, so it also applies to the Linux operating system.  Even the first process,  , with process ID 1, is forked during the boot procedure in the so-called   procedure. Built-in commands are contained within the shell itself.  When the name of a built-in command is used as the first word of a simple command, the shell executes the command directly, without creating a new process.  Built-in commands are necessary to implement functionality impossible or inconvenient to obtain with separate utilities. Bash supports 3 types of built-in commands: Bourne Shell built-ins: ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Bash built-in commands: ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Special built-in commands: When Bash is executing in POSIX mode, the special built-ins differ from other built-in commands in three respects: Special built-ins are found before shell functions during command lookup. If a special built-in returns an error status, a non-interactive shell exits. Assignment statements preceding the command stay in effect in the shell environment after the command completes. The POSIX special built-ins are  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Most of these built-ins will be discussed in the next chapters.  For those commands for which this is not the case, we refer to the Info pages. When the program being executed is a shell script, bash will create a new bash process using a  .  This subshell reads the lines from the shell script one line at a time.  Commands on each line are read, interpreted and executed as if they would have come directly from the keyboard. While the subshell processes each line of the script, the parent shell waits for its child process to finish.  When there are no more lines in the shell script to read, the subshell terminates.  The parent shell awakes and displays a new prompt. If input is not commented, the shell reads it and divides it into words and operators, employing quoting rules to define the meaning of each character of input.  Then these words and operators are translated into commands and other constructs, which return an exit status available for inspection or processing.  The above fork-and-exec scheme is only applied after the shell has analyzed input in the following way: The shell reads its input from a file, from a string or from the user's terminal. Input is broken up into words and operators, obeying the quoting rules, see  .  These tokens are separated by  .  Alias expansion is performed. The shell   (analyzes and substitutes) the tokens into simple and compound commands. Bash performs various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Redirection is performed if necessary, redirection operators and their operands are removed from the argument list. Commands are executed. Optionally the shell waits for the command to complete and collects its exit status. A simple shell command such as   consists of the command itself followed by arguments, separated by spaces. More complex shell commands are composed of simple commands arranged together in a variety of ways: in a pipeline in which the output of one command becomes the input of a second, in a loop or conditional construct, or in some other grouping.  A couple of examples:     Shell functions are a way to group commands for later execution using a single name for the group.  They are executed just like a   command.  When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Shell functions are executed in the current shell context; no new process is created to interpret them. Functions are explained in  . A parameter is an entity that stores values.  It can be a name, a number or a special value.  For the shell's purpose, a variable is a parameter that stores a name.  A variable has a value and zero or more attributes.  Variables are created with the   shell built-in command. If no value is given, a variable is assigned the null string.  Variables can only be removed with the   built-in. Assigning variables is discussed in  , advanced use of variables in  . Shell expansion is performed after each command line has been split into tokens.  These are the expansions performed: Brace expansion Tilde expansion Parameter and variable expansion Command substitution Arithmetic expansion Word splitting Filename expansion We'll discuss these expansion types in detail in  . Before a command is executed, its input and output may be redirected using a special notation interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment. When executing a command, the words that the parser has marked as variable assignments (preceding the command name) and redirections are saved for later reference.  Words that are not variable assignments or redirections are expanded; the first remaining word after expansion is taken to be the name of the command and the rest are arguments to that command.  Then redirections are performed, then strings assigned to variables are expanded.  If no command name results, variables will affect the current shell environment. An important part of the tasks of the shell is to search for commands.  Bash does this as follows: Check whether the command contains slashes.  If not, first check with the function list to see if it contains a command by the name we are looking for. If command is not a function, check for it in the built-in list. If command is neither a function nor a built-in, look for it analyzing the directories listed in  .  Bash uses a   (data storage area in memory) to remember the full path names of executables so extensive   searches can be avoided. If the search is unsuccessful, bash prints an error message and returns an exit status of 127. If the search was successful or if the command contains slashes, the shell executes the command in a separate execution environment. If execution fails because the file is not executable and not a directory, it is assumed to be a shell script. If the command was not begun asynchronously, the shell waits for the command to complete and collects its exit status. When a file containing shell commands is used as the first non-option argument when invoking Bash (without   or  , this will create a non-interactive shell.  This shell first searches for the script file in the current directory, then looks in   if the file cannot be found there. This guide is mainly about the last shell building block, scripts.  Some general considerations before we continue: A script should run without errors. It should perform the task for which it is intended. Program logic is clearly defined and apparent. A script does not do unnecessary work. Scripts should be reusable. The structure of a shell script is very flexible.  Even though in Bash a lot of freedom is granted, you must ensure correct logic, flow control and efficiency so that users executing the script can do so easily and correctly. When starting on a new script, ask yourself the following questions: Will I be needing any information from the user or from the user's environment? How will I store that information? Are there any files that need to be created?  Where and with which permissions and ownerships? What commands will I use?  When using the script on different systems, do all these systems have these commands in the required versions? Does the user need any notifications?  When and why? The table below gives an overview of programming terms that you need to be familiar with: In order to speed up the developing process, the logical order of a program should be thought over in advance.  This is your first step when developing a script. A number of methods can be used; one of the most common is working with lists.  Itemizing the list of tasks involved in a program allows you to describe each process.  Individual tasks can be referenced by their item number. Using your own spoken language to pin down the tasks to be executed by your program will help you to create an understandable form of your program.  Later, you can replace the everyday language statements with shell language words and constructs. The example below shows such a logic flow design.  It describes the rotation of log files.  This example shows a possible repetitive loop, controlled by the number of base log files you want to rotate: Do you want to rotate logs? If yes: Enter directory name containing the logs to be rotated. Enter base name of the log file. Enter number of days logs should be kept. Make settings permanent in user's crontab file. If no, go to step 3. Do you want to rotate another set of logs? If yes: repeat step 1. If no: go to step 3. Exit The user should provide information for the program to do something.  Input from the user must be obtained and stored.  The user should be notified that his crontab will change. The   script below executes some well-known commands ( ,  ,  ,  ) to display information about you and your machine. A script always starts with the same two characters,  .  After that, the shell that will execute the commands following the first line is defined.  This script starts with clearing the screen on line 2.  Line 3 makes it print a message, informing the user about what is going to happen.  Line 5 greets the user.  Lines 6, 9, 13, 16 and 20 are only there for orderly output display purposes.  Line 8 prints the current date and the number of the week.  Line 11 is again an informative message, like lines 3, 18 and 22.  Line 12 formats the output of the  ; line 15 shows operating system and CPU information.  Line 19 gives the uptime and load information. Both   and   are Bash built-in commands.  The first always exits with a 0 status, and simply prints arguments followed by an end of line character on the standard output, while the latter allows for definition of a formatting string and gives a non-zero exit status code upon failure. This is the same script using the   built-in: Creating user friendly scripts by means of inserting messages is treated in  . This implies that the   program is installed in  . If you execute a script from cron, supply full path names and redirect output and errors.  Since the shell runs in non-interactive mode, any errors will cause the script to exit prematurely if you don't think about this. The following chapters will discuss the details of the above scripts. An init script starts system services on UNIX and Linux machines.  The system log daemon, the power management daemon, the name and mail daemons are common examples.  These scripts, also known as startup scripts, are stored in a specific location on your system, such as   or  .  Init, the initial process, reads its configuration files and decides which services to start or stop in each run level.  A run level is a configuration of processes; each system has a single user run level, for instance, for performing administrative tasks, for which the system has to be in an unused state as much as possible, such as recovering a critical file system from a backup.  Reboot and shutdown run levels are usually also configured. The tasks to be executed upon starting a service or stopping it are listed in the startup scripts.  It is one of the system administrator's tasks to configure  , so that services are started and stopped at the correct moment.  When confronted with this task, you need a good understanding of the startup and shutdown procedures on your system.  We therefore advise that you read the man pages for   and   before starting on your own initialization scripts. Here is a very simple example, that will play a sound upon starting and stopping your machine: The   statement often used in this kind of script is described in  . Bash is the GNU shell, compatible with the Bourne shell and incorporating many useful features from other shells.  When the shell is started, it reads its configuration files.  The most important are: Bash behaves different when in interactive mode and also has a POSIX compliant and a restricted mode. Shell commands can be split up in three groups: the shell functions, shell built-ins and existing commands in a directory on your system.  Bash supports additional built-ins not found in the plain Bourne shell. Shell scripts consist of these commands arranged as shell syntax dictates.  Scripts are read and executed line per line and should have a logical structure. These are some exercises to warm you up for the next chapter: Where is the   program located on your system? Use the   option to find out which version you are running. Which shell configuration files are read when you login to your system using the graphical user interface and then opening a terminal window? Are the following shells interactive shells?  Are they login shells? A shell opened by clicking on the background of your graphical desktop, selecting   or such from a menu. A shell that you get after issuing the command  . A shell that you get when logging in to the console in text mode. A shell obtained by the command  . A shell opened by the   script. A shell that you get on a remote host, for which you didn't have to give the login and/or password because you use SSH and maybe SSH keys. Can you explain why   does not exit when you type  +  on the command line? Display directory stack content. If it is not yet the case, set your prompt so that it displays your location in the file system hierarchy, for instance add this line to  :   Display hashed commands for your current shell session. How many processes are currently running on your system?  Use   and  , the first line of output of   is not a process! How to display the system hostname?  Only the name, nothing more! After going through this chapter, you will be able to: Write a simple script Define the shell type that should execute the script Put comments in a script Change permissions on a script Execute and debug a script A shell script is a sequence of commands for which you have a repeated use.  This sequence is typically executed by entering the name of the script on the command line.  Alternatively, you can use scripts to automate tasks using the cron facility.  Another use for scripts is in the UNIX boot and shutdown procedure, where operation of daemons and services are defined in init scripts. To create a shell script, open a new empty file in your editor.  Any text editor will do:  ,  ,  ,   et cetera are all valid.  You might want to chose a more advanced editor like   or  , however, because these can be configured to recognize shell and Bash syntax and can be a great help in preventing those errors that beginners frequently make, such as forgetting brackets and semi-colons. In order to activate syntax highlighting in  , use the command   or   or   You can add this setting to your   file to make it permanent. Put UNIX commands in the new empty file, like you would enter them on the command line.   As discussed in the previous chapter (see  ), commands can be shell functions, shell built-ins, UNIX commands and other scripts. Give your script a sensible name that gives a hint about what the script does.  Make sure that your script name does not conflict with existing commands.  In order to ensure that no confusion can rise, script names often end in  ; even so, there might be other scripts on your system with the same name as the one you chose.  Check using  ,   and other commands for finding information about programs and files:       In this example we use the   Bash built-in to inform the user about what is going to happen, before the task that will create the output is executed.  It is strongly advised to inform users about what a script is doing, in order to prevent them from becoming nervous  .  We will return to the subject of notifying users in  . Write this script for yourself as well.  It might be a good idea to create a directory   to hold your scripts.  Add the directory to the contents of the   variable:   If you are just getting started with Bash, use a text editor that uses different colours for different shell constructs.  Syntax highlighting is supported by  ,  ,  ,   and many other editors; check the documentation of your favorite editor. The prompts throughout this course vary depending on the author's mood.  This resembles much more real life situations than the standard educational   prompt.  The only convention we stick to, is that the   prompt ends in a hash mark (#). The script should have execute permissions for the correct owners in order to be runnable.  When setting permissions, check that you really obtained the permissions that you want.  When this is done, the script can run like any other command: This is the most common way to execute a script.  It is preferred to execute the script like this in a subshell.  The variables, functions and aliases created in this subshell are only known to the particular bash session of that subshell.  When that shell exits and the parent regains control, everything is cleaned up and all changes to the state of the shell made by the script, are forgotten. If you did not put the   directory in your  , and   (the current directory) is not in the   either, you can activate the script like this:   A script can also explicitly be executed by a given shell, but generally we only do this if we want to obtain special behavior, such as checking if the script works with another shell or printing traces for debugging:       The specified shell will start as a subshell of your current shell and execute the script.  This is done when you want the script to start up with specific options or under specific conditions which are not specified in the script. If you don't want to start a new shell but execute the script in the current shell, you   it:   The Bash   built-in is a synonym for the Bourne shell   (dot) command. The script does not need execute permission in this case.  Commands are executed in the current shell context, so any changes made to your environment will be visible when the script finishes execution: When running a script in a subshell, you should define which shell should run the script.  The shell type in which you wrote the script might not be the default on your system, so commands you entered might result in errors when executed by the wrong shell. The first line of the script determines the shell to start.  The first two characters of the first line should be  , then follows the path to the shell that should interpret the commands that follow.  Blank lines are also considered to be lines, so don't start your script with an empty line. For the purpose of this course, all scripts will start with the line   As noted before, this implies that the Bash executable can be found in  . You should be aware of the fact that you might not be the only person reading your code.  A lot of users and system administrators run scripts that were written by other people.  If they want to see how you did it, comments are useful to enlighten the reader. Comments also make your own life easier.  Say that you had to read a lot of man pages in order to achieve a particular result with some command that you used in your script.   You won't remember how it worked if you need to change your script after a few weeks or months, unless you have commented what you did, how you did it and/or why you did it. Take the   example and copy it to  , which we edit so that the comments reflect what the script does.  Everything the shell encounters after a hash mark on a line is ignored and only visible upon opening the shell script file: In a decent script, the first lines are usually comment about what to expect.  Then each big chunk of commands will be commented as needed for clarity's sake.  Linux init scripts, as an example, in your system's   directory, are usually well commented since they have to be readable and editable by everyone running Linux. When things don't go according to plan, you need to determine what exactly causes the script to fail.  Bash provides extensive debugging features.  The most common is to start up the subshell with the   option, which will run the entire script in debug mode.  Traces of each command plus its arguments are printed to standard output after the commands have been expanded but before they are executed. This is the   script ran in debug mode.  Note again that the added comments are not visible in the output of the script. There is now a full-fledged debugger for Bash, available at  .  These debugging features are available in most modern versions of Bash, starting from 3.x. Using the   Bash built-in you can run in normal mode those portions of the script of which you are sure they are without fault, and display debugging information only for troublesome zones.  Say we are not sure what the   command will do in the example  , then we could enclose it in the script like this: Output then looks like this: You can switch debugging mode on and off as many times as you want within the same script. The table below gives an overview of other useful Bash options: The dash is used to activate a shell option and a plus to deactivate it.  Don't let this confuse you! In the example below, we demonstrate these options on the command line: Alternatively, these modes can be specified in the script itself, by adding the desired options to the first line shell declaration.  Options can be combined, as is usually the case with UNIX commands:   Once you found the buggy part of your script, you can add   statements before each command of which you are unsure, so that you will see exactly where and why things don't work.  In the example   script, it could be done like this, still assuming that the displaying of users gives us problems: In more advanced scripts, the   can be inserted to display the content of variables at different stages in the script, so that flaws can be detected: A shell script is a reusable series of commands put in an executable text file.  Any text editor can be used to write scripts. Scripts start with   followed by the path to the shell executing the commands from the script.  Comments are added to a script for your own future reference, and also to make it understandable for other users.  It is better to have too many explanations than not enough. Debugging a script can be done using shell options.  Shell options can be used for partial debugging or for analyzing the entire script.  Inserting   commands at strategic locations is also a common troubleshooting technique. This exercise will help you to create your first script. Write a script using your favorite editor.  The script should display the path to your homedirectory and the terminal type that you are using.  Additionally it shows all the services started up in runlevel 3 on your system.  (hint: use  ,   and  ) Add comments in your script. Add information for the users of your script. Change permissions on your script so that you can run it. Run the script in normal mode and in debug mode.  It should run without errors. Make errors in your script: see what happens if you misspell commands, if you leave out the first line or put something unintelligible there, or if you misspell shell variable names or write them in lower case characters after they have been declared in capitals.  Check what the debug comments say about this. In this chapter we will discuss the various ways in which the Bash environment can be influenced: Editing shell initialization files Using variables Using different quote styles Perform arithmetic calculations Assigning aliases Using expansion and substitution When invoked interactively with the   option or when invoked as  , Bash reads the   instructions.  These usually set the shell variables  ,  ,  ,   and  . On some systems, the   value is configured in  ; on other systems this file holds pointers to other configuration files such as: , the system-wide Readline initialization file where you can configure the command line bell-style. the   directory, which contains files configuring system-wide behavior of specific programs. All settings that you want to apply to all your users' environments should be in this file.  It might look like this: This configuration file sets some basic shell environment variables as well as some variables required by users running Java and/or Java applications in their web browser.  See  . See   for more on the conditional   used in this file;   discusses loops such as the   construct. The Bash source contains sample   files for general or individual use.  These and the one in the example above need changes in order for them to work in your environment! On systems offering multiple types of shells, it might be better to put Bash-specific configurations in this file, since   is also read by other shells, such as the Bourne shell.  Errors generated by shells that don't understand the Bash syntax are prevented by splitting the configuration files for the different types of shells.  In such cases, the user's   might point to   in order to include it in the shell initialization process upon login. You might also find that   on your system only holds shell environment and program startup settings, while   contains system-wide definitions for shell functions and aliases.  The   file might be referred to in   or in individual user shell initialization files. The source contains sample   files, or you might find a copy in  .  This is part of the   that comes with the Bash documentation: Apart from general aliases, it contains useful aliases which make commands work even if you misspell them.  We will discuss aliases in  .  This file contains a function,  ; functions will be studied in detail in  . These files might not be in your home directory by default; create them if needed. This is the preferred configuration file for configuring user environments individually.  In this file, users can add extra configuration options or change default settings: This user configures the backspace character for login on different operating systems.  Apart from that, the user's   and   are read. This file contains specific settings that are normally only executed when you log in to the system.  In the example, we use it to configure the   value and to show a list of connected users upon login.  This user also gets the calendar for the current month: In the absence of  , this file will be read. In the absence of   and  ,   is read.  It can hold the same configurations, which are then also accessible by other shells.  Mind that other shells might not understand the Bash syntax. Today, it is more common to use a non-login shell, for instance when logged in graphically using X terminal windows.  Upon opening such a window, the user does not have to provide a user name or password; no authentication is done.  Bash searches for   when this happens, so it is referred to in the files read upon login as well, which means you don't have to enter the same settings in multiple files. In this user's   a couple of aliases are defined and variables for specific programs are set after the system-wide   is read: More examples can be found in the Bash package.  Remember that sample files might need changes in order to work in your environment. Aliases are discussed in  . This file contains specific instructions for the logout procedure.  In the example, the terminal window is cleared upon logout.  This is useful for remote connections, which will leave a clean window after closing them. When making changes to any of the above files, users have to either reconnect to the system or   the altered file for the changes to take effect.  By interpreting the script this way, changes are applied to the current shell session: Most shell scripts execute in a private environment: variables are not inherited by child processes unless they are exported by the parent shell.  Sourcing a file containing shell commands is a way of applying changes to your own environment and setting variables in the current shell. This example also demonstrates the use of different prompt settings by different users.  In this case, red means danger.  When you have a green prompt, don't worry too much. Note that   is the same as  . Should you get lost in all these configuration files, and find yourself confronted with settings of which the origin is not clear, use   statements, just like for debugging scripts; see  .  You might add lines like this: or like this: As seen in the examples above, shell variables are in uppercase
characters by convention.  Bash keeps a list of two types of variables: Global variables or environment variables are available in all shells.  The   or   commands can be used to display environment variables.  These programs come with the   package. Below is a typical output: Local variables are only available in the current shell.  Using the   built-in command without any options will display a list of all variables (including environment variables) and functions.  The output will be sorted according to the current locale and displayed in a reusable format. Below is a diff file made by comparing   and   output, after leaving out the functions which are also displayed by the   command: the GNU Awk programming language is explained in  . Apart from dividing variables in local and global variables, we can also divide them in categories according to the sort of content the variable contains.  In this respect, variables come in 4 types: String variables Integer variables Constant variables Array variables We'll discuss these types in  .  For now, we will work with integer and string values for our variables. Variables are case sensitive and capitalized by default.  Giving local variables a lowercase name is a convention which is sometimes applied.  However, you are free to use the names you want or to mix cases.  Variables can also contain digits, but a name starting with a digit is not allowed: To set a variable in the shell, use   Putting spaces around the equal sign will cause errors.  It is a good habit to quote content strings when assigning values to variables: this will reduce the chance that you make errors. Some examples using upper and lower cases, numbers and spaces: A variable created like the ones in the example above is only available to the current shell.  It is a local variable: child processes of the current shell will not be aware of this variable.  In order to pass variables to a subshell, we need to   them using the   built-in command.  Variables that are exported are referred to as environment variables.  Setting and exporting is usually done in one step:   A subshell can change variables it inherited from the parent, but the changes made by the child don't affect the parent.  This is demonstrated in the example: When first trying to read the value of   in a subshell, it is not there (  shows a null string).  The subshell quits, and   is exported in the parent - a variable can be exported after it has been assigned a value.  Then a new subshell is started, in which the variable exported from the parent is visible.  The variable is changed to hold another name, but the value for this variable in the parent stays the same. Bash uses certain shell variables in the same way as the Bourne shell.  In some cases, Bash assigns a default value to the variable.  The table below gives an overview of these plain shell variables: These variables are set or used by Bash, but other shells do not normally treat them specially. Check the Bash man, info or doc pages for extended information.  Some variables are read-only, some are set automatically and some lose their meaning when set to a different value than the default. The shell treats several parameters specially.  These parameters may only be referenced; assignment to them is not allowed. The implementation of   has always been a problem and realistically should have been replaced with the behavior of  .  In almost every case where coders use  , they mean  .    Can cause bugs and even security holes in your software. The positional parameters are the words following the name of a shell script.  They are put into the variables  ,  ,   and so on.  As long as needed, variables are added to an internal array.    holds the total number of parameters, as is demonstrated with this simple script: Upon execution one could give any numbers of arguments: More on evaluating these parameters is in   and  . Some examples on the other special parameters: User   starts entering the   command, which results in the assignment of the   variable.  The process ID of his shell is 10662.  After putting a job in the background, the   holds the process ID of the backgrounded job.  The shell running is  .  When a mistake is made,   holds an exit code different from 0 (zero). Apart from making the script more readable, variables will also enable you to faster apply a script in another environment or for another purpose.  Consider the following example, a very simple script that makes a backup of  's home directory to a remote server: First of all, you are more likely to make errors if you name files and directories manually each time you need them.  Secondly, suppose   wants to give this script to  , then carol will have to do quite some editing before she can use the script to back up her home directory.  The same is true if   wants to use this script for backing up other directories.  For easy recycling, make all files, directories, usernames, servernames etcetera variable.  Thus, you only need to edit a value once, without having to go through the entire script to check where a parameter occurs.  This is an example: The above is purely an example that everybody can understand, using a small directory and a host on the same subnet.  Depending on your bandwidth, the size of the directory and the location of the remote server, it can take an awful lot of time to make backups using this mechanism.  For larger directories and lower bandwidth, use   to keep the directories at both ends synchronized. A lot of keys have special meanings in some context or other.  Quoting is used to remove the special meaning of characters or words: quotes can disable special treatment for special characters, they can prevent reserved words from being recognized as such and they can disable parameter expansion. Escape characters are used to remove the special meaning from a single character.  A non-quoted backslash, \, is used as an escape character in Bash.  It preserves the literal value of the next character that follows, with the exception of  .  If a newline character appears immediately after the backslash, it marks the continuation of a line when it is longer that the width of the terminal; the backslash is removed from the input stream and effectively ignored. In this example, the variable   is created and set to hold a value.  The first   displays the value of the variable, but for the second, the dollar sign is escaped. Single quotes ('') are used to preserve the literal value of each character enclosed within the quotes.  A single quote may not occur between single quotes, even when preceded by a backslash. We continue with the previous example: Using double quotes the literal value of all characters enclosed is preserved, except for the dollar sign, the backticks (backward single quotes, ``) and the backslash. The dollar sign and the backticks retain their special meaning within the double quotes. The backslash retains its meaning only when followed by dollar, backtick, double quote, backslash or newline.  Within double quotes, the backslashes are removed from the input stream when followed by one of these characters.  Backslashes preceding characters that don't have a special meaning are left unmodified for processing by the shell interpreter. A double quote may be quoted within double quotes by preceding it with a backslash. Words in the form   are treated in a special way.  The word expands to a string, with backslash-escaped characters replaced as specified by the ANSI-C standard.  Backslash escape sequences can be found in the Bash documentation. A double-quoted string preceded by a dollar sign will cause the string to be translated according to the current locale.  If the current locale is   or  , the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted. After the command has been split into   (see  ), these tokens or words are expanded or resolved.  There are eight kinds of expansion performed, which we will discuss in the next sections, in the order that they are expanded. After all expansions, quote removal is performed. Brace expansion is a mechanism by which arbitrary strings may be generated.  Patterns to be brace-expanded take the form of an optional  , followed by a series of comma-separated strings between a pair of braces, followed by an optional  .  The preamble is prefixed to each string contained within the braces, and the postscript is then appended to each resulting string, expanding left to right. Brace expansions may be nested.  The results of each expanded string are not sorted; left to right order is preserved: Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result.  It is strictly textual.  Bash does not apply any syntactic interpretation to the context of the expansion or the text between the braces.  To avoid conflicts with parameter expansion, the string   is not considered eligible for brace expansion. A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma.  Any incorrectly formed brace expansion is left unchanged. If a word begins with an unquoted tilde character ( ), all of the characters up to the first unquoted slash (or all characters, if there is no unquoted slash) are considered a  .  If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login name.  If this login name is the null string, the tilde is replaced with the value of the   shell variable.  If   is unset, the home directory of the user executing the shell is substituted instead.  Otherwise, the tilde-prefix is replaced with the home directory associated with the specified login name. If the tilde-prefix is  , the value of the shell variable   replaces the tilde-prefix.  If the tilde-prefix is  , the value of the shell variable  , if it is set, is substituted. If the characters following the tilde in the tilde-prefix consist of a number N, optionally prefixed by a   or a  , the tilde-prefix is replaced with the corresponding element from the directory stack, as it would be displayed by the   built-in invoked with the characters following tilde in the tilde-prefix as an argument.  If the tilde-prefix, without the tilde, consists of a number without a leading   or  ,   is assumed. If the login name is invalid, or the tilde expansion fails, the word
is left unchanged. Each variable assignment is checked for unquoted tilde-prefixes immediately following a   or  .  In these cases, tilde expansion is also performed.  Consequently, one may use file names with tildes in assignments to  ,  , and  , and the shell assigns the expanded value. Example:  will be expanded to  , so if   is  , the directory   will be added to the content of the   variable. The   character introduces parameter expansion, command substitution, or arithmetic expansion.  The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name. When braces are used, the matching ending brace is the first   not escaped by a backslash or within a quoted string, and not within an embedded arithmetic expansion, command substitution, or parameter expansion. The basic form of parameter expansion is  .  The value of   is substituted.  The braces are required when   is a positional parameter with more than one digit, or when   is followed by a character that is not to be interpreted as part of its name. If the first character of   is an exclamation point,  Bash uses the value of the variable formed from the rest of   as the name of the variable; this variable is then expanded and that value is used in the rest of the substitution, rather than the value of   itself.  This is known as  . You are certainly familiar with straight parameter expansion, since it happens all the time, even in the simplest of cases, such as the one above or the following: The following is an example of indirect expansion: Note that this is not the same as  . The following construct allows for creation of the named variable if it does not yet exist:   Example: Special parameters, among others the positional parameters, may not be assigned this way, however. We will further discuss the use of the curly braces for treatment of variables in  .  More information can also be found in the Bash info pages. Command substitution allows the output of a command to replace the
command itself.  Command substitution occurs when a command is enclosed like this:   or like this using backticks:   Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted.  Embedded newlines are not deleted, but they may be removed during word splitting. When the old-style backquoted form of substitution is used, backslash retains its literal meaning except when followed by  ,  , or  .  The first backticks not preceded by a backslash terminates the command substitution.  When using the   form, all characters between the parentheses make up the command; none are treated specially. Command substitutions may be nested.  To nest when using the backquoted form, escape the inner backticks with backslashes. If the substitution appears within double quotes, word splitting and file name expansion are not performed on the results. Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.  The format for arithmetic expansion is:   The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially.  All tokens in the expression undergo parameter expansion, command substitution, and quote removal.  Arithmetic substitutions may be nested. Evaluation of arithmetic expressions is done in fixed-width integers with no check for overflow - although division by zero is trapped and recognized as an error.  The operators are roughly the same as in the C programming language.  In order of decreasing precedence, the list looks like this: Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated.  Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax.  The value of a variable is evaluated as an arithmetic expression when it is referenced.  A shell variable need not have its integer attribute turned on to be used in an expression. Constants with a leading 0 (zero) are interpreted as octal numbers.  A
leading   or   denotes hexadecimal.  Otherwise, numbers take the form  , where   is a decimal number between 2 and 64 representing the arithmetic base, and N is a number in that base.  If   is omitted, then base 10 is used.  The digits greater than 9 are represented by the lowercase letters, the uppercase letters,  , and  , in that order.  If   is less than or equal to 36, lowercase and uppercase letters may be used interchangably to represent numbers between 10 and 35. Operators are evaluated in order of precedence.  Sub-expressions in parentheses are evaluated first and may override the precedence rules above. Wherever possible, Bash users should try to use the syntax with square brackets:   However, this will only calculate the result of  , and do no tests: See  , among others, for practical examples in scripts. Process substitution is supported on systems that support named pipes (FIFOs) or the   method of naming open files.  It takes the form of   or   The process   is run with its input or output connected to a FIFO or some file in  .  The name of this file is passed as an argument to the current command as the result of the expansion.  If the   form is used, writing to the file will provide input for  .  If the   form is used, the file passed as an argument should be read to obtain the output of  .  Note that no space may appear between the < or > signs and the left parenthesis, otherwise the construct would be interpreted as a redirection. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion. More information in  . The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. The shell treats each character of   as a delimiter, and splits the results of the other expansions into words on these characters.  If   is unset, or its value is exactly  , the default, then any sequence of   characters serves to delimit words.  If   has a value other than the default, then sequences of the whitespace characters   and   are ignored at the beginning and end of the word, as long as the whitespace character is in the value of   (an   whitespace character).  Any character in   that is not   whitespace, along with any adjacent   whitespace characters, delimits a field.  A sequence of   whitespace characters is also treated as a delimiter.  If the value of   is null, no word splitting occurs. Explicit null arguments (  or  ) are retained.  Unquoted implicit null arguments, resulting from the expansion of parameters that have no values, are removed.  If a parameter with no value is expanded within double quotes, a null argument results and is retained. If no expansion occurs, no splitting is performed. After word splitting, unless the   option has been set (see  ), Bash scans each word for the characters  ,  , and  .  If one of these characters appears, then the word is regarded as a  , and replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are found, and the shell option   is disabled, the word is left unchanged.  If the   option is set, and no matches are found, the word is removed.  If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. When a pattern is used for file name generation, the character   at the start of a file name or immediately following a slash must be matched explicitly, unless the shell option   is set.  When matching a file name, the slash character must always be matched explicitly.  In other cases, the   character is not treated specially. The   shell variable may be used to restrict the set of file names matching a pattern.  If   is set, each matching file name that also matches one of the patterns in   is removed from the list of matches.  The file names   and   are always ignored, even when   is set.  However, setting   has the effect of enabling the   shell option, so all other file names beginning with a   will match.  To get the old behavior of ignoring file names beginning with a  , make   one of the patterns in  .  The   option is disabled when   is unset. An alias allows a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the   and   built-in commands.  Issue the   without options to display a list of aliases known to the current shell. Aliases are useful for specifying the default version of a command that exists in several versions on your system, or to specify default options to a command.  Another use for aliases is for correcting incorrect spelling. The first word of each simple command, if unquoted, is checked to see if it has an alias.  If so, that word is replaced by the text of the alias.  The alias name and the replacement text may contain any valid shell input, including shell metacharacters, with the exception that the alias name may not contain  .  The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time.  This means that one may alias   to  , for instance, and Bash will not try to recursively expand the replacement text. If the last character of the alias value is a space or tab character, then the next command word following the alias is also checked for alias expansion. Aliases are not expanded when the shell is not interactive, unless
the   option is set using the   shell built-in. Aliases are created using the   shell built-in.  For permanent use, enter the   in one of your shell initialization files; if you just enter the alias on the command line, it is only recognized within the current shell. Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias.  This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed.  To be safe, always put alias definitions on a separate line, and do not use   in compound commands. Aliases are not inherited by child processes.  Bourne shell ( ) does not recognize aliases. More about functions is in  . Aliases are looked up after functions and thus resolving is slower.  While aliases are easier to understand, shell functions are preferred over aliases for almost every purpose. We already discussed a couple of Bash options that are useful for debugging your scripts.  In this section, we will take a more in-depth view of the Bash options. Use the   option to   to display all shell options: See the Bash Info pages, section  ->  for a description of each option.  A lot of options have one-character shorthands: the   option, for instance, is equal to specifying  . Shell options can either be set different from the default upon calling the shell, or be set during shell operation.  They may also be included in the shell resource configuration files. The following command executes a script in POSIX-compatible mode: For changing the current environment temporarily, or for use in a script,
we would rather use  .  Use   (dash) for enabling an option,   for disabling: The above example demonstrates the   option, which prevents existing files from being overwritten by redirection operations.  The same goes for one-character options, for instance  , which will treat unset variables as an error when set, and exits a non-interactive shell upon
encountering such errors: This option is also useful for detecting incorrect content assignment to variables: the same error will also occur, for instance, when assigning a character string to a variable that was declared explicitly as one holding only integer values. One last example follows, demonstrating the   option, which prevents special characters from being expanded: The Bash environment can be configured globally and on a per user basis.  Various configuration files are used to fine-tune the behavior of the shell. These files contain shell options, settings for variables, function definitions and various other building blocks for creating ourselves a cosy environment. Except for the reserved Bourne shell, Bash and special parameters, variable names can be chosen more or less freely. Because a lot of characters have double or even triple meanings, depending on the environment, Bash uses a system of quoting to take away special meaning from one or multiple characters when special treatment is not wanted. Bash uses various methods of expanding command line entries in order to determine which commands to execute. For this exercise, you will need to read the   man pages, because we are going to use the   directory to hold default shell configuration files, which are copied to the home directory of each newly added user. First we will do some general exercises on setting and displaying variables. Create 3 variables,  ,   and  ; initialize them to hold the values  ,   and   respectively. Display the values of all three variables. Are these local or global variables? Remove  . Can you see the two remaining variables in a new terminal window? Edit   so that all users are greeted upon login (test this). For the   account, set the prompt to something like  , preferably in a bright color such as red or pink or in reverse video mode. Make sure that newly created users also get a nice personalized prompt which informs them on which system in which directory they are working.  Test your changes by adding a new user and logging in as that user. Write a script in which you assign two integer values to two variables.  The script should calculate the surface of a rectangle which has these proportions.  It should be aired with comments and generate elegant output. Don't forget to   your scripts! In this chapter we discuss: Using regular expressions Regular expression metacharacters Finding patterns in files or output Character ranges and classes in Bash A   is a pattern that describes a set of strings.  Regular expressions are constructed analogously to arithmetic expressions by using various operators to combine smaller expressions. The fundamental building blocks are the regular expressions that match a single character.  Most characters, including all letters and digits, are regular expressions that match themselves.  Any metacharacter with special meaning may be quoted by preceding it with a backslash. A regular expression may be followed by one of several repetition operators (metacharacters): Two regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating two substrings that respectively match the concatenated subexpressions. Two regular expressions may be joined by the infix operator  ; the resulting regular expression matches any string matching either subexpression. Repetition takes precedence over concatenation, which in turn takes precedence over alternation.  A whole subexpression may be enclosed in parentheses to override these precedence rules. In basic regular expressions the metacharacters  ,  ,  ,  ,  , and   lose their special meaning; instead use the backslashed versions  ,  ,  ,  ,  , and  . Check in your system documentation whether commands using regular expressions support extended expressions.  searches the input files for lines containing a match to a given pattern list.  When it finds a match in a line, it copies the line to standard output (by default), or whatever other sort of output you have requested with options. Though   expects to do the matching on text, it has no limits on input line length other than available memory, and it can match arbitrary characters within a line.  If the final byte of an input file is not a  ,   silently supplies one.  Since newline is also a separator for the list of patterns, there is no way to match newline characters in a text. Some examples: With the first command, user   displays the lines from   containing the string  . Then she displays the line numbers containing this search string. With the third command she checks which users are not using  , but accounts with the   shell are not displayed. Then she counts the number of accounts that have   as the shell. The last command displays the lines from all the files in her home directory starting with  , excluding matches containing the string  , so as to exclude matches from   which might contain the same string, in upper or lower cases.  Note that the search is for the    , and not for the    . Now let's see what else we can do with grep, using regular expressions. We use GNU   in these examples, which supports extended regular expressions.  GNU   is the default on Linux systems.  If you are working on proprietary systems, check with the   option which version you are using.  GNU   can be downloaded from  . From the previous example, we now exclusively want to display lines starting with the string  : If we want to see which accounts have no shell assigned whatsoever, we search for lines ending in  : To check that   is exported in  , first select   lines and then search for lines starting with the string  , so as not to display   and other possible paths: Similarly,   matches the end of a word. If you want to find a string that is a separate word (enclosed by spaces), it is better use the  , as in this example where we are displaying information for the root partition: If this option is not used, all the lines from the file system table will be displayed. A   is a list of characters enclosed by   and  .  It matches any single character in that list; if the first character of the list is the caret,  , then it matches any character NOT in the list.  For example, the regular expression   matches any single digit. Within a bracket expression, a   consists of two characters separated by a hyphen.  It matches any single character that sorts between the two characters, inclusive, using the locale's collating sequence and character set.  For example, in the default C locale,   is equivalent to  .  Many locales sort characters in dictionary order, and in these locales   is typically not equivalent to  ; it might be equivalent to  , for example.  To obtain the traditional interpretation of bracket expressions, you can use the C locale by setting the   environment variable to the value  . Finally, certain named classes of characters are predefined within bracket expressions.  See the   man or info pages for more information about these predefined expressions. In the example, all the lines containing either a   or   character are displayed. Use the   for a single character match.  If you want to get a list of all five-character English dictionary words starting with   and ending in   (handy for solving crosswords): If you want to display lines containing the literal dot character, use the   option to  . For matching multiple characters, use the asterisk.  This example selects all words starting with   and ending in   from the system's dictionary: If you want to find the literal asterisk character in a file or output, use single quotes.  Cathy in the example below first tries finding the asterisk character in   without using quotes, which does not return any lines.  Using quotes, output is generated: Apart from   and regular expressions, there's a good deal of pattern matching that you can do directly in the shell, without having to use an external program. As you already know, the asterisk (*) and the question mark (?) match any string or any single character, respectively.  Quote these special characters to match them literally: But you can also use the square braces to match any enclosed character or range of characters, if pairs of characters are separated by a hyphen.  An example: This lists all files in  's home directory, starting with  ,  ,  ,  ,   or  . If the first character within the braces is   or  , any character not enclosed will be matched.  To match the dash ( ), include it as the first or last character in the set.  The sorting depends on the current locale and of the value of the   variable, if it is set.  Mind that other locales might interpret   as   if sorting is done in dictionary order.  If you want to be sure to have the traditional interpretation of ranges, force this behavior by setting   or   to  . Character classes can be specified within the square braces, using the syntax  , where CLASS is defined in the POSIX standard and has one of the values ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   or  . Some examples: When the   shell option is enabled (using the   built-in), several extended pattern matching operators are recognized.  Read more in the Bash info pages, section  -> -> -> . Regular expressions are powerful tools for selecting particular lines from files or output.  A lot of UNIX commands use regular expressions:  ,  , the   database and so on.  They can be made available in any language or application using external libraries, and they even found their way to non-UNIX systems.  For instance, regular expressions are used in the Excell spreadsheet that comes with the MicroSoft Windows Office suite.  In this chapter we got the feel of the   command, which is indispensable in any UNIX environment. The   command can do much more than the few tasks we discussed here; we only used it as an example for regular expressions.  The GNU   version comes with plenty of documentation, which you are strongly advised to read! Bash has built-in features for matching patterns and can recognize character classes and ranges. These exercises will help you master regular expressions. Display a list of all the users on your system who log in with the Bash shell as a default. From the   directory, display all lines starting with the string  . Print all the lines from the same file that don't contain the string. Display localhost information from the   file, display the line number(s) matching the search string and count the number of occurrences of the string. Display a list of   subdirectories containing information about shells. How many   files do these subdirectories contain?  Don't count anything in the form of  . Make a list of files in your home directory that were changed less that 10 hours ago, using  , but leave out directories. Put these commands in a shell script that will generate comprehensible output. Can you find an alternative for  , using  ? Using the file system table (  for instance), list local disk devices. Make a script that checks whether a user exists in  .  For now, you can specify the user name in the script, you don't have to work with arguments and conditionals at this stage. Display configuration files in   that contain numbers in their names. At the end of this chapter you will know about the following topics: What is  ? Interactive use of  Regular expressions and stream editing Using   commands in scripts   These explanations are far from complete and certainly not meant to be used as the definite user manual for  .  This chapter is only included in order to show some more interesting topics in the next chapters, and because every power user should have a basic knowledge of things that can be done with this editor. For detailed information, refer to the   info and man pages. 
 A   is used to perform basic transformations on text read from a file or a pipe.  The result is sent to standard output.  The syntax for the   command has no output file specification, but results can be saved to a file using output redirection.  The editor does not modify the original input. What distinguishes   from other editors, such as   and  , is its ability to filter text that it gets from a pipeline feed.  You do not need to interact with the editor while it is running; that is why   is sometimes called a  .  This feature allows use of editing commands in scripts, greatly easing repetitive editing tasks.  When facing replacement of text in a large number of files,   is a great help. The   program can perform text pattern substitutions and deletions using regular expressions, like the ones used with the   command; see  . The editing commands are similar to the ones used in the   editor: Apart from editing commands, you can give options to  .  An overview is in the table below: The   info pages contain more information; we only list the most frequently used commands and options here. This is something you can do with  , of course, but you can't do a   using that command.  This is just to get you started. This is our example text file: We want   to find all the lines containing our search pattern, in this case  .  We use the   to obtain the result: As you notice,   prints the entire file, but the lines containing the search string are printed twice.  This is not what we want.  In order to only print those lines matching our pattern, use the   option: We use the same example text file.  Now we only want to see the lines   containing the search string: The   command results in excluding lines from being displayed. Matching lines starting with a given pattern and ending in a second pattern are showed like this: Note that the last dot needs to be escaped in order to actually match.  In our example the expression just matches any character, including the last dot. This time we want to take out the lines containing the errors.  In the example these are lines 2 to 4.  Specify this range to address, together with the   command: To print the file starting from a certain line until the end of the file, use a command similar to this: This only prints the first two lines of the example file. The following command prints the first line containing the pattern  , up to and including the next line containing the pattern  : In the example file, we will now search and replace the errors instead of only (de)selecting the lines containing the search string. As you can see, this is not exactly the desired effect: in line 4, only the first occurrence of the search string has been replaced, and there is still an 'eror' left.  Use the   command to indicate to   that it should examine the entire line instead of stopping at the first occurrence of your string: To insert a string at the beginning of each line of a file, for instance for quoting: Insert some string at the end of each line: Multiple find and replace commands are separated with individual   options: Keep in mind that by default   prints its results to the standard output, most likely your terminal window.  If you want to save the output to a file, redirect it:   Plenty of   examples can be found in the startup scripts for your machine, which are usually in   or  .  Change into the directory containing the initscripts on your system and issue the following command:   Multiple   commands can be put in a file and executed using the   option.  When creating such a file, make sure that: No trailing white spaces exist at the end of lines. No quotes are used. When entering text to add or replace, all except the last line end in a backslash. Writing output is done using the output redirection operator  .  This is an example script used to create very simple HTML files from plain text files.  holds the first argument to a given command, in this case the name of the file to convert: More on positional parameters in  . This is not really how it is done; this example just demonstrates   capabilities.  See   for a more decent solution to this problem, using     and   constructs. Advanced editors, supporting syntax highlighting, can recognize   syntax.  This can be a great help if you tend to forget backslashes and such. The   stream editor is a powerful command line tool, which can handle streams of data: it can take input lines from a pipe.  This makes it fit for non-interactive use.  The   editor uses  -like commands and accepts regular expressions. The   tool can read commands from the command line or from a script.  It is often used to perform find-and-replace actions on lines containing a pattern. These exercises are meant to further demonstrate what   can do. Print a list of files in your   directory, ending in  .  Mind that you might have to unalias  .  Put the result in a temporary file. Make a list of files in   that have the letter   as the second character.  Put the result in a temporary file. Delete the first 3 lines of each temporary file. Print to standard output only the lines containing the pattern  . Create a file holding   commands to perform the previous two tasks.  Add an extra command to this file that adds a string like   in the line preceding every occurence of the string  .  Check the results. A long listing of the root directory,  , is used for input.  Create a file holding   commands that check for symbolic links and plain files.  If a file is a symbolic link, precede it with a line like  .  If the file is a plain file, add a string on the same line, adding a comment like  . Create a script that shows lines containing trailing white spaces from a file.  This script should use a   script and show sensible information to the user. In this chapter we will discuss: What is  ? Using   commands on the command line How to format text with  How   uses regular expressions  in scripts  and variables As with  , entire books have been written about various versions of  .  This introduction is far from complete and is only intended for understanding examples in the following chapters.  For more information, best start with the documentation that comes with  :  .  is the GNU version of the commonly available UNIX   program, another popular stream editor.  Since the   program is often just a link to  , we will refer to it as  . The basic function of   is to search files for lines or other text units containing one or more patterns.  When a line matches one of the patterns, special actions are performed on that line. Programs in   are different from programs in most other languages, because   programs are  : you describe the data you want to work with and then what to do when you
find it.  Most other languages are    You have to describe, in great detail, every step the program is to take.  When working with procedural languages, it is usually much harder to clearly describe the data your program will process.  For this reason,   programs are often refreshingly easy to read and write. Back in the 1970s, three programmers got together to create this language.  Their names were Aho, Kernighan and Weinberger.  They took the first character of each of their names and put them together.  So the name of the language might just as well have been  . When you run  , you specify an     that tells   what to do.  The program consists of a series of  .  (It may also
contain function definitions, loops, conditions and other programming constructs, advanced features that we will ignore for now.)  Each rule specifies one pattern to search for and one action to perform upon finding the pattern. There are several ways to run  .  If the program is short, it is easiest to run it on the command line:   If multiple changes have to be made, possibly regularly and on multiple files, it is easier to put the   commands in a script.  This is read like this:   The   command in   outputs selected data from the input file. When   reads a line of a file, it divides the line in fields based on the specified  ,  , which is an   variable (see  ).  This variable is predefined to be one or more spaces or tabs. The variables  ,  ,  , ...,   hold the values of the first, second, third until the last field of an input line.  The variable   (zero) holds the value of the entire line.  This is depicted in the image below, where we see six colums in the output of the   command: In the output of  , there are 9 columns.  The   statement uses these fields as follows: This command printed the fifth column of a long file listing, which contains the file size, and the last column, the name of the file.  This output is not very readable unless you use the official way of referring to columns, which is to separate the ones that you want to print with a comma.  In that case, the default output separater character, usually a space, will be put in between each output field. Note that the configuration of the output of the   command might be different on your system.  Display of time and date is dependent on your locale setting. Without formatting, using only the output separator, the output looks rather poor.  Inserting a couple of tabs and a string to indicate what output this is will make it look a lot better: Note the use of the backslash, which makes long input continue on the next line without the shell interpreting this as a separate command.  While your command line input can be of virtually unlimited length, your monitor is not, and printed paper certainly isn't.  Using the backslash also allows for copying and pasting of the above lines into a terminal window. The   option to   is used for supplying humanly readable size formats for bigger files.  The output of a long listing displaying the total amount of blocks in the directory is given when a directory is the argument.  This line is useless to us, so we add an asterisk.  We also add the   option for the same reason, in case asterisk expands to a directory. The backslash in this example marks the continuation of a line. See  . You can take out any number of columns and even reverse the order.  In the example below this is demonstrated for showing the most critical partitions: The table below gives an overview of special formatting characters: Quotes, dollar signs and other meta-characters should be escaped with a backslash. A regular expression can be used as a pattern by enclosing it in slashes.  The regular expression is then tested against the entire text of each record.  The syntax is as follows:   The following example displays only local disk device information, networked file systems are not shown: Slashes need to be escaped, because they have a special meaning to the   program. Below another example where we search the   directory for files ending in   and starting with either      , using extended regular expressions: This example illustrates the special meaning of the dot in regular expressions: the first one indicates that we want to search for any character after the first search string, the second is escaped because it is part of a string to find (the end of the file name). In order to precede output with comments, use the   statement: The   statement can be added for inserting text after the entire input is processed: As commands tend to get a little longer, you might want to put them in a script, so they are reusable.  An   script contains   statements defining patterns and actions. As an illustration, we will build a report that displays our most loaded partitions.  See  .  first prints a begin message, then formats all the lines that contain an eight or a nine at the beginning of a word, followed by one other number and a percentage sign.  An end message is added. Awk is a programming language.  Its syntax is recognized by most editors that can do syntax highlighting for other languages, such as C, Bash, HTML, etc. As   is processing the input file, it uses several variables.  Some are editable, some are read-only. The  , which is either a single character or a regular expression, controls the way   splits up an input record into fields.  The input record is scanned for character sequences that match the separator definition; the fields themselves are the text between the matches. The field separator is represented by the built-in variable  .  Note that this is something different from the   variable used by POSIX-compliant shells. The value of the field separator variable can be changed in the   program with the assignment operator  .  Often the right time to do this is at the beginning of execution before any input has been processed, so that the very first record is read with the proper separator.  To do this, use the special   pattern. In the example below, we build a command that displays all the users on your system with a description: In an   script, it would look like this: Choose input field separators carefully to prevent problems.  An example to illustrate this: say you get input in the form of lines that look like this: You write a command line or a script, which prints out the name of the person in that record:   But a person might have a PhD, and it might be written like this: Your   will give the wrong output for this line.  If needed, use an extra   or   to uniform data input formats. The default input field separator is one or more whitespaces or tabs. Fields are normally separated by spaces in the output.  This becomes apparent when you use the correct syntax for the   command, where arguments are separated by commas: If you don't put in the commas,   will treat the items to output as one argument, thus omitting the use of the default  ,  . Any character string may be used as the output field separator by setting this built-in variable. The output from an entire   statement is called an  .  Each   command results in one output record, and then outputs a string called the  ,  .  The default value for this variable is  , a newline character.  Thus, each   statement generates a separate line. To change the way output fields and records are separated, assign new values to   and  : If the value of   does not contain a newline, the program's output is run together on a single line. The built-in   holds the number of records that are processed.  It is incremented after reading a new input line.  You can use it at the end to count the total number of records, or in each output record: Apart from the built-in variables, you can define your own.  When   encounters a reference to a variable which does not exist (which is not predefined), the variable is created and initialized to a null string.  For all subsequent references, the value of the variable is whatever value was assigned last.  Variables can be a string or a numeric value.  Content of input fields can also be assigned to variables. Values can be assigned directly using the   operator, or you can use the current value of the variable in combination with other operators: C-like shorthands like   are also accepted. The example from   becomes much easier when we use an   script: And the command to execute is also much more straightforward when using   instead of  : We refer again to the directory containing the initscripts on your system.  Enter a command similar to the following to see more practical examples of the widely spread usage of the   command:   For more precise control over the output format than what is normally provided by  , use  .  The   command can be used to specify the field width to use for each item, as well as various formatting choices for numbers (such as what output base to use, whether to print an exponent, whether to print a sign, and how many digits to print after the decimal point).  This is done by supplying a string, called the  , that controls how and where to print the other arguments. The syntax is the same as for the C-language   statement; see your C introduction guide.  The   info pages contain full explanations. The   utility interprets a special-purpose programming language, handling simple data-reformatting jobs with just a few lines of code.  It is the free version of the general UNIX   command. This tools reads lines of input data and can easily recognize columned output.  The   program is the most common for filtering and formatting defined fields. On-the-fly variable declaration is straightforward and allows for simple calculation of sums, statistics and other operations on the processed input stream.  Variables and commands can be put in   scripts for background processing. Other things you should know about  : The language remains well-known on UNIX and alikes, but for executing similar tasks,   is now more commonly used.  However,   has a much steeper learning curve (meaning that you learn a lot in a very short time).  In other words,   is more difficult to learn. Both   and   share the reputation of being incomprehensible, even to the actual authors of the programs that use these languages.  So document your code! These are some practical examples where   can be useful. For the first exercise, your input is lines in the following form: Make an   script that will convert such a line to an LDAP record in this format: Create a file containing a couple of test records and check. Create a Bash script using   and standard UNIX commands that will show the top three users of disk space in the   file system (if you don't have the directory holding the homes on a separate partition, make the script for the   partition; this is present on every UNIX system).  First, execute the commands from the command line.  Then put them in a script.  The script should create sensible output (sensible as in readable by the boss).  If everything proves to work, have the script email its results to you (use for instance  ). If the quota daemon is running, use that information; if not, use  . Create XML-style output from a  -separated list in the following form: The output should read: Additionally, if you know anything about XML, write a BEGIN and END script to complete the table.  Or do it in HTML. In this chapter we will discuss the use of conditionals in Bash scripts.  This includes the following topics:   The   statement Using the exit status of a command Comparing and testing input and files  constructs  constructs Using and testing the positional parameters Nested   statements Boolean expressions Using   statements 
 At times you need to specify different courses of action to be taken in a shell script, depending on the success or failure of a command.  The   construction allows you to specify such conditions. The most compact syntax of the   command is:   The   list is executed, and if its return status is zero, the   list is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true. The   often involves numerical or string comparison tests, but it can also be any command that returns a status of zero when it succeeds and some other status when it fails.  Unary expressions are often used to examine the status of a file.  If the   argument to one of the primaries is of the form  , then file descriptor   is checked.   ,   and   and their respective file descriptors may also be used for tests. The table below contains an overview of the so-called   that make up the   command or list of commands.  These primaries are put between square brackets to indicate the test of a conditional expression. Expressions may be combined using the following operators, listed in decreasing order of precedence: The   (or  ) built-in evaluates conditional expressions using a set of rules based on the number of arguments.  More information about this subject can be found in the Bash documentation.  Just like the   is closed with  , the opening square bracket should be closed after the conditions have been listed. The   list that follows the   statement can be any valid UNIX command, any executable program, any executable shell script or any shell statement, with the exception of the closing  .  It is important to remember that the   and   are considered to be separated statements in the shell.  Therefore, when issued on the command line, they are separated by a semi-colon. In a script, the different parts of the   statement are usually well-separated.  Below, a couple of simple examples. The first example checks for the existence of a file: To add in your Bash configuration files: The above example will work when entered on the command line: However, if you use testing of conditions that depend on the environment, you might get different results when you enter the same command in a script, because the script will open a new shell, in which expected variables and options might not be set automatically. The   variable holds the exit status of the previously executed command (the most recently completed foreground process). The following example shows a simple test: The following example demonstrates that   might be any UNIX command that returns an exit status, and that   again returns an exit status of zero: The same result can be obtained as follows: The examples below use numerical comparisons: This script is executed by cron every Sunday.  If the week number is even, it reminds you to put out the garbage cans: An example of comparing strings for testing the user ID: With Bash, you can shorten this type of construct.  The compact equivalent of the above test is as follows: Similar to the   expression which indicates what to do if the test proves true,   specifies what to do if the test is false. Regular expressions may also be used in comparisons: Most programmers will prefer to use the   built-in command, which is equivalent to using square brackets for comparison, like this: If you invoke the   in a subshell, it will not pass variables to the parent.  Use { and } instead of ( and ) if you do not want Bash to fork a subshell. See the info pages for Bash for more information on pattern matching with the   and   constructs. This is the construct to use to take one course of action if the   commands test true, and another if it tests false.  An example: Contrary to  ,   prevents word splitting of variable values.  So, if  , you do not need to double quote   in a test - eventhough using quotes remains a good habit.  Also,   prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames.  Using  ,   and   interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance:  . Like the   list following the   statement, the   list following the   statement can hold any UNIX-style command that returns an exit status. Another example, extending the one from  : We switch to the   account to demonstrate the effect of the   statement - your   is usually a local account while your own user account might be managed by a central system, such as an LDAP server. Instead of setting a variable and then executing a script, it is frequently more elegant to put the values for the variables on the command line. We use the positional parameters  ,  , ...,   for this purpose.    refers to the number of command line arguments.    refers to the name of the script. The following is a simple example: Here's another example, using two arguments: The following example shows how to change the previous script so that it prints a message if more or less than 2 arguments are given: The first argument is referred to as  , the second as   and so on.  The total number of arguments is stored in  . Check out   for a more elegant way to print usage messages. This test is done in a lot of scripts, because there's no use in starting a lot of programs if you know they're not going to work: Note that the file is referred to using a variable; in this case it is the first argument to the script.  Alternatively, when no arguments are given, file locations are usually stored in variables at the beginning of a script, and their content is referred to using these variables.  Thus, when you want to change a file name in a script, you only need to do it once. The above example will fail if the value of   can be parsed as multiple words.  In that case, the   command can be fixed either using double quotes around the filename, or by using   instead of  . This is the full form of the   statement:             The   list is executed, and if its return status is zero, the   list is executed.  If
  returns a non-zero status, each   list is executed in turn, and if its exit status is zero, the corresponding   is executed and the command completes.  If   is followed by an   list, and the final command in the final   or   clause has a non-zero exit status, then   is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true. This is an example that you can put in your crontab for daily execution: Inside the   statement, you can use another   statement.  You may use as many levels of nested  s as you can logically manage. This is an example testing leap years: The above script can be shortened using the Boolean operators   (&&) and   (||). We use the double brackets for testing an arithmetic expression, see  .  This is equivalent to the   statement.  You will get stuck using square brackets here, if you try something like  , because here, the square brackets don't represent an actual command by themselves. Among other editors,   is one of those supporting colour schemes according to the file format; such editors are useful for detecting errors in your code. We already briefly met the   statement in  .  It terminates execution of the entire script.  It is most often used if the input requested from the user is incorrect, if a statement did not run successfully or if some other error occurred. The   statement takes an optional argument.  This argument is the integer exit status code, which is passed back to the parent and stored in the   variable. A zero argument means that the script ran successfully.  Any other value may be used by programmers to pass back different messages to the parent, so that different actions can be taken according to failure or success of the child process.  If no argument is given to the   command, the parent shell uses the current value of the   variable. Below is an example with a slightly adapted   script, which sends its exit status back to the parent,  : This script is called upon in the next one, which therefore exports its variables   and  : As you can see, exit status codes can be chosen freely.  Existing commands usually have a series of defined codes; see the programmer's manual for each command for more information. Nested   statements might be nice, but as soon as you are confronted with a couple of different possible actions to take, they tend to confuse.  For the more complex conditionals, use the   syntax:   Each case is an expression matching a pattern.  The commands in the   for the first match are executed.  The   symbol is used for separating multiple patterns, and the   operator terminates a pattern list.  Each case plus its according commands are called a  .  Each clause must be terminated with  .  Each   statement is ended with the   statement. In the example, we demonstrate use of cases for sending a more selective warning message with the   script: Of course you could have opened your mail program to check the results; this is just to demonstrate that the script sends a decent mail with  ,   and   header lines. Many more examples using   statements can be found in your system's init script directory.  The startup scripts use   and   cases to run or stop system processes.  A theoretical example can be found in the next section. Initscripts often make use of   statements for starting, stopping and querying system services.  This is an excerpt of the script that starts  , a daemon that runs commands periodically with a frequency specified in days. The tasks to execute in each case, such as stopping and starting the daemon, are defined in functions, which are partially sourced from the   file.  See   for more explanation. In this chapter we learned how to build conditions into our scripts so that different actions can be undertaken upon success or failure of a command.  The actions can be determined using the   statement.  This allows you to perform arithmetic and string comparisons, and testing of exit code, input and files needed by the script. A simple   test often preceeds commands in a shell script in order to prevent output generation, so that the script can easily be run in the background or through the   facility.  More complex definitions of conditions are usually put in a   statement. Upon successful condition testing, the script can explicitly inform the parent using the   status.  Upon failure, any other number may be returned.  Based on the return code, the parent program can take appropriate action. Here are some ideas to get you started using   in scripts: Use an   construct that prints information about the current month.  The script should print the number of days in this month, and give information about leap years if the current month is February. Do the same, using a   statement and an alternative use of the   command. Modify   so that you get a special greeting message when you connect to your system as  . Edit the   script from   so that it requires one argument, the year.  Test that exactly one argument is supplied. Write a script called   that checks if the   and   daemons are running on your system.  If an   is running, the script should print a message like,    Use   to check on processes. Write a script that makes a backup of your home directory on a remote machine using  .  The script should report in a log file, for instance  .  If you don't have a second machine to copy the backup to, use   to test copying it to the localhost.  This requires SSH keys between the two hosts, or else you have to supply a password.  The creation of SSH keys is explained in  . Adapt the script from the first example in   to include the case of exactly 90% disk space usage, and lower than 10% disk space usage. The script should use   for the creation of the backup and   or   for compressing the   file.  Put all filenames in variables.  Put the name of the remote server and the remote directory in a variable.  This will make it easier to re-use the script or to make changes to it in the future. The script should check for the existence of a compressed archive.  If this exists, remove it first in order to prevent output generation. The script should also check for available diskspace.  Keep in mind that at any given moment you could have the data in your home directory, the data in the   file and the data in the compressed archive all together on your disk.  If there is not enough diskspace, exit with an error message in the log file. The script should clean up the compressed archive before it exits. In this chapter we will discuss how to interact with the users of our scripts:   Printing user friendly messages and explanations Catching user input Prompting for user input Using the file descriptors to read from and write to multiple files 
 Some scripts run without any interaction from the user at all.  Advantages of non-interactive scripts include: The script runs in a predictable way every time. The script can run in the background. Many scripts, however, require input from the user, or give output to the user as the script is running.  The advantages of interactive scripts are, among others: More flexible scripts can be built. Users can customize the script as it runs or make it behave in different ways. The script can report its progress as it runs. When writing interactive scripts, never hold back on comments.  A script that prints appropriate messages is much more user-friendly and can be more easily debugged.  A script might do a perfect job, but you will get a whole lot of support calls if it does not inform the user about what it is doing.  So include messages that tell the user to wait for output because a calculation is being done.  If possible, try to give an indication of how long the user will have to wait.  If the waiting should regularly take a long time when executing a certain task, you might want to consider integrating some processing indication in the output of your script. When prompting the user for input, it is also better to give too much than too little information about the kind of data to be entered.  This applies to the checking of arguments and the accompanying usage message as well. Bash has the   and   commands to provide comments for users, and although you should be familiar with at least the use of   by now, we will discuss some more examples in the next sections. The   built-in command outputs its arguments, separated by spaces and terminated with a newline character.  The return status is always zero.    takes a couple of options: : interprets backslash-escaped characters. : suppresses the trailing newline. As an example of adding comments, we will make the   and   from   a bit better: More about escape characters can be found in  .  The following table gives an overview of sequences recognized by the   command: For more information about the   command and the way it allows you to format output, see the Bash info pages.  Keep in mind that there might be differences between different versions of Bash. The   built-in command is the counterpart of the   and   commands.  The syntax of the   command is as follows:   One line is read from the standard input, or from the file descriptor supplied as an argument to the   option.  The first word of the line is assigned to the first name,  , the second word to the second name, and so on, with leftover words and their intervening separators assigned to the last name,  .  If there are fewer words read from the input stream than there are names, the remaining names are assigned empty values. The characters in the value of the   variable are used to split the input line into words or tokens; see  .  The backslash character may be used to remove any special meaning for the next character read and for line continuation. If no names are supplied, the line read is assigned to the variable  . The return code of the   command is zero, unless an end-of-file character is encountered, if   times out or if an invalid file descriptor is supplied as the argument to the   option. The following options are supported by the Bash   built-in: This is a straightforward example, improving on the   script from the previous chapter: The following example shows how you can use prompts to explain what the user should enter. Note that no output is omitted here.  The script only stores information about the people Michel is interested in, but it will always say you are added to the list, unless you are already in it. Other people can now start executing the script: After a while, the   list begins to look like this: Of course, this situation is not ideal, since everybody can edit (but not delete) Michel's files.  You can solve this problem using special access modes on the script file, see   in the Introduction to Linux guide. As you know from basic shell usage, input and output of a command may be redirected before it is executed, using a special notation - the redirection operators - interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment. Redirection can also occur in a script, so that it can receive input from a file, for instance, or send output to a file.  Later, the user can review the output file, or it may be used by another script as input. File input and output are accomplished by integer handles that track all open files for a given process.  These numeric values are known as file descriptors.  The best known file descriptors are  ,   and  , with file descriptor numbers 0, 1 and 2, respectively.  These numbers and respective devices are reserved.  Bash can take TCP or UDP ports on networked hosts as file descriptors as well. The output below shows how the reserved file descriptors point to actual devices: Note that each process has its own view of the files under  , as it is actually a symbolic link to  . You might want to check   and   for more information about   subdirectories and the way your system handles standard file descriptors for each running process. When excuting a given command, the following steps are excuted, in order: If the standard output of a previous command is being piped to the standard input of the current command, then   is updated to target the same anonymous pipe as  . If the standard output of the current command is being piped to the standard input of the next command, then   is updated to target another anonymous pipe. Redirection for the current command is processed from left to right. Redirection   or   after a command has the effect of creating or updating the symbolic link   with the same target as the symbolic link  . The redirections   and   have the effect of creating or updating the symbolic link   with the target file. File descriptor closure   has the effect of deleting the symbolic link  . Only now is the current command executed. When you run a script from the command line, nothing much changes because the child shell process will use the same file descriptors as the parent.  When no such parent is available, for instance when you run a script using the   facility, the standard file descriptors are pipes or other (temporary) files, unless some form of redirection is used.  This is demonstrated in the example below, which shows output from a simple   script: And one with  : From the previous examples, it is clear that you can provide input and output files for a script (see   for more), but some tend to forget about redirecting errors - output which might be depended upon later on.  Also, if you are lucky, errors will be mailed to you and eventual causes of failure might get revealed.  If you are not as lucky, errors will cause your script to fail and won't be caught or sent anywhere, so that you can't start to do any worthwhile debugging. When redirecting errors, note that the order of precedence is significant.  For example, this command, issued in  will redirect standard output of the   command to the file   in  .  The command will direct both standard input and standard error to the file  .  The command directs only the standard output to the destination file, because the standard error is copied to standard output before the standard output is redirected. For convenience, errors are often redirected to  , if it is sure they will not be needed.  Hundreds of examples can be found in the startup scripts for your system. Bash allows for both standard output and standard error to be redirected to the file whose name is the result of the expansion of   with this construct:   This is the equivalent of  , the construct used in the previous set of examples.  It is also often combined with redirection to  , for instance when you just want a command to execute, no matter what output or errors it gives. The   directory contains entries named  ,  ,  , and so on.  Opening the file   is equivalent to duplicating file descriptor  .  If your system provides  ,   and  , you will see that these are equivalent to  ,   and  , respectively. The main use of the   files is from the shell.  This mechanism allows for programs that use pathname arguments to handle standard input and standard output in the same way as other pathnames.  If   is not available on a system, you'll have to find a way to bypass the problem.  This can be done for instance using a hyphen ( ) to indicate that a program should read from a pipe.  An example: The   command first reads the file  , next its standard input which is the output of the   command, and last the   file.  The special meaning of the hyphen as a command-line argument to refer to the standard input or standard output is a misconception that has crept into many programs.  There might also be problems when specifying hyphen as the first argument, since it might be interpreted as an option to the preceding command.  Using   allows for uniformity and prevents confusion: In this clean example, all output is additionally piped through   to send it to the default printer. Another way of looking at file descriptors is thinking of them as a way to assign a numeric value to a file.  Instead of using the file name, you can use the file descriptor number.  The   built-in command can be used to replace the shell of the current process or to alter the file descriptors of the current shell.  For example, it can be used to assign a file descriptor to a file.  Use   for assigning file descriptor N to   for output, and   for assigning file descriptor N to   for input.  After a file descriptor has been assigned to a file, it can be used with the shell redirection operators, as is demonstrated in the following example: Using this file descriptor might cause problems, see  , chapter 16.  You are strongly advised not to use it. The following is an example that shows how you can alternate between file input and command line input: Since child processes inherit open file descriptors, it is good practice to close a file descriptor when it is no longer needed.  This is done using the   syntax.  In the above example, file descriptor 7, which has been assigned to standard input, is closed each time the user needs to have access to the actual standard input device, usually the keyboard. The following is a simple example redirecting only standard error to a pipe: Frequently, your script might call on another program or script that requires input.  The   document provides a way of instructing the shell to read input from the current source until a line containing only the search string is found (no trailing blanks).  All of the lines read up to that point are then used as the standard input for a command. The result is that you don't need to call on separate files; you can use shell-special characters, and it looks nicer than a bunch of  's: Although we talk about a  , it is supposed to be a construct within the same script.  This is an example that installs a package automatically, eventhough you should normally confirm: And this is how the script runs.  When prompted with the   string, the script answers   automatically: In this chapter, we learned how to provide user comments and how to prompt for user input.  This is usually done using the  /  combination.  We also discussed how files can be used as input and output using file descriptors and redirection, and how this can be combined with getting input from the user. We stressed the importance of providing ample message for the users of our scripts.  As always when others use your scripts, it is better to give too much information than not enough.    documents is a type of shell construct that allows creation of lists, holding choices for the users.  This construct can also be used to execute otherwise interactive tasks in the background, without intervention. These exercises are practical applications of the constructs discussed in this chapter.  When writing the scripts, you may test by using a test directory that does not contain too much data.  Write each step, then test that portion of code, rather than writing everything at once. Write a script that asks for the user's age.  If it is equal to or higher than 16, print a message saying that this user is allowed to drink alcohol.  If the user's age is below 16, print a message telling the user how many years he or she has to wait before legally being allowed to drink. As an extra, calculate how much beer an 18+ user has drunk statistically (100 liters/year) and print this information for the user. Write a script that takes one file as an argument.  Use a   document that presents the user with a couple of choices for compressing the file.  Possible choices could be  ,  ,   and  .  Write a script called   that automates   so the person executing the script always uses the desired options ( ) and backup destination directory ( ) to make a backup of his or her home directory.  Implement the following features: Test for the number of arguments.  The script should run without arguments.  If any arguments are present, exit after printing a usage message. Determine whether the   directory has enough free space to hold the backup. Ask the user whether a full or an incremental backup is wanted.  If the user does not have a full backup file yet, print a message that a full backup will be taken.  In case of an incremental backup, only do this if the full backup is not older than a week. Compress the backup using any compression tool.  Inform the user that the script is doing this, because it might take some time, during which the user might start worrying if no output appears on the screen. Print a message informing the user about the size of the compressed backup. See   or  , chapter 9:   for background information. Write a script called   that adds a local user to the system.  This script should: Take only one argument, or else exit after printing a usage message. Check   and decide on the first free user ID.  Print a message containing this ID. Create a private group for this user, checking the   file.  Print a message containing the group ID. Gather information from the operator user: a comment describing this user, choice from a list of shells (test for acceptability, else exit printing a message), expiration date for this account, extra groups of which the new user should be a member. With the obtained information, add a line to  ,   and  ; create the user's home directory (with correct permissions!); add the user to the desired secondary groups. Set the password for this user to a default known string. Rewrite the script from   so that it reads input from the user instead of taking it from the first argument. Upon completion of this chapter, you will be able to   Use  ,   and   loops, and decide which loop fits which occasion. Use the   and   Bash built-ins. Write scripts using the   statement. Write scripts that take a variable number of arguments. The   loop is the first of the three shell looping constructs.  This loop allows for specification of a list of values.  A list of commands is executed for each value in the list. The syntax for this loop is:   If   is not present, it is replaced with   and   executes the   once for each positional parameter that is set (see   and  ). The return status is the exit status of the last command that executes.  If no commands are executed because   does not expand to any items, the return status is zero.  can be any variable name, although   is used very often.    can be any list of words, strings or numbers, which can be literal or generated by any command.  The   to execute can also be any operating system commands, script, program or shell statement.  The first time through the loop,   is set to the first item in  .  The second time, its value is set to the second item in the list, and so on.  The loop terminates when   has taken on each of the values from   and no items are left in  . The first is a command line example, demonstrating the use of a   loop that makes a backup copy of each   file.  After issuing the command, it is safe to start working on your sources: This one lists the files in   that are just plain text files, and possibly scripts: The following is a specific application script for converting HTML files, compliant with a certain scheme, to PHP files.  The conversion is done by taking out the first 25 and the last 21 lines, replacing these with two PHP tags that provide header and footer lines: Since we don't do a line count here, there is no way of knowing the line number from which to start deleting lines until reaching the end.  The problem is solved using  , which reverses the lines in a file. Instead of using   to replace the   suffix with  , it would be cleaner to use the   command.  Read the man page for more info. You will run into problems if the list expands to file names containing spaces and other irregular characters.  A more ideal construct to obtain the list would be to use the shell's globbing feature, like this: The   construct allows for repetitive execution of a list of commands, as long as the command controlling the   loop executes successfully (exit status of zero).  The syntax is:    can be any command(s) that can exit with a success or failure status.  The   can be any program, script or shell construct. As soon as the   fails, the loop exits.  In a script, the command following the   statement is executed. The return status is the exit status of the last   command, or zero if none was executed. Here is an example for the impatient: The example below was written to copy pictures that are made with a webcam to a web directory.  Every five minutes a picture is taken.  Every hour, a new directory is created, holding the images for that hour.  Every day, a new directory is created containing 24 subdirectories.  The script runs in the background. Note the use of the   statement.  This means: continue execution until we are forcibly interrupted (with   or  + ). This small script can be used for simulation testing; it generates files: Note the use of the   command to generate all kinds of file and directory names.  See the man page for more. The previous example is for the sake of demonstration.  Regular checks can easily be achieved using the system's   facility.  Do not forget to redirect output and errors when using scripts that are executed from your crontab! This script can be interrupted by the user when a  +  sequence is entered: A   document is used to present the user with possible choices.  And again, the   test repeats the commands from the   list over and over again. This script calculates the average of user input, which is tested before it is processed: if input is not within range, a message is printed.  If   is pressed, the loop exits: Note how the variables in the last lines are left unquoted in order to do arithmetic. The   loop is very similar to the   loop, except that the loop executes until the   executes successfully.  As long as this command fails, the loop continues.  The syntax is the same as for the   loop:   The return status is the exit status of the last command executed in the   list, or zero if none was executed.    can, again, be any command that can exit with a success or failure status, and   can be any UNIX command, script or shell construct. As we already explained previously, the   may be replaced with one or more newlines wherever it appears. An improved   script (see  ), which tests for available disk space.  If not enough disk space is available, remove pictures from the previous months: Note the initialization of the   and   variables and the use of options with   and   in order to obtain a correct listing for  . Instead of controlling a loop by testing the result of a command or by user input, you can specify a file from which to read input that controls the loop.  In such cases,   is often the controlling command.  As long as input lines are fed into the loop, execution of the loop commands continues.  As soon as all the input lines are read the loop exits. Since the loop construct is considered to be one command structure (such as  ), the redirection should occur after the   statement, so that it complies with the form   This kind of redirection also works with other kinds of loops. In the example below, output of the   command is used as input for the   command controlling a   loop: Files are compressed before they are moved into the archive directory. The   statement is used to exit the current loop before its normal ending.  This is done when you don't know in advance how many times the loop will have to execute, for instance because it is dependent on user input. The example below demonstrates a   loop that can be interrupted.  This is a slightly improved version of the   script from  . Mind that   exits the loop, not the script.  This can be demonstrated by adding an   command at the end of the script.  This   will also be executed upon input that causes   to be executed (when the user types  ). In nested loops,   allows for specification of which loop to exit.  See the Bash   pages for more. The   statement resumes iteration of an enclosing  ,  ,   or   loop. When used in a   loop, the controlling variable takes on the value of the next element in the list.  When used in a   or   construct, on the other hand, execution resumes with   at the top of the loop. In the following example, file names are converted to lower case.  If no conversion needs to be done, a   statement restarts execution of the loop.  These commands don't eat much system resources, and most likely, similar problems can be solved using   and  .  However, it is useful to know about this kind of construction when executing heavy jobs, that might not even be necessary when tests are inserted at the correct locations in a script, sparing system resources. This script has at least one disadvantage: it overwrites existing files.  The   option to Bash is only useful when redirection occurs.  The   option to the   command provides more security, but is only safe in case of one accidental overwrite, as is demonstrated in this test: The   is part of the   package; it can perform all kinds of character transformations. The   construct allows easy menu generation.  The syntax is quite similar to that of the   loop:    is expanded, generating a list of items.  The expansion is printed to standard error; each item is preceded by a number.  If   is not present, the positional parameters are printed, as if   would have been specified.    is only printed once. Upon printing all the items, the   prompt is printed and one line from standard input is read.  If this line consists of a number corresponding to one of the items, the value of   is set to the name of that item.  If the line is empty, the items and the   prompt are displayed again.  If an   (End Of File) character is read, the loop exits.  Since most users don't have a clue which key combination is used for the EOF sequence, it is more user-friendly to have a   command as one of the items.  Any other value of the read line will set   to be a null string. The read line is saved in the   variable. The   are executed after each selection until the number representing the   is read.  This exits the loop. This is a very simple example, but as you can see, it is not very user-friendly: Setting the   prompt and adding a possibility to quit makes it better: Any statement within a   construct can be another   loop, enabling (a) submenu(s) within a menu. By default, the   variable is not changed when entering a nested   loop.  If you want a different prompt in the submenu, be sure to set it at the appropriate time(s). The   command is one of the Bourne shell built-ins that comes with Bash.  This command takes one argument, a number.  The positional parameters are shifted to the left by this number,  .  The positional parameters from   to   are renamed to variable names from   to  . Say you have a command that takes 10 arguments, and N is 4, then   becomes  ,   becomes   and so on.    becomes   and the original  ,   and   are thrown away. If N is zero or greater than  , the positional parameters are not changed (the total number of arguments, see  ) and the command has no effect.  If N is not present, it is assumed to be 1.  The return status is zero unless N is greater than   or less than zero; otherwise it is non-zero. A shift statement is typically used when the number of arguments to a command is not known in advance, for instance when users can give as many arguments as they like.  In such cases, the arguments are usually processed in a   loop with a test condition of  .  This condition is true as long as the number of arguments is greater than zero.  The   variable and the   statement process each argument.  The number of arguments is reduced each time   is executed and eventually becomes zero, upon which the   loop exits. The example below,  , uses   statements to process each file in the list generated by  : The above   command can be replaced with the following:   The   command builds and executes command lines from standard input.  This has the advantage that the command line is filled until the system limit is reached.  Only then will the command to execute be called, in the above example this would be  .  If there are more arguments, a new command line will be used, until that one is full or until there are no more arguments.  The same thing using   calls on the command to execute on the found files every time a file is found.  Thus, using   greatly speeds up your scripts and the performance of your machine. In the next example, we modified the script from   so that it accepts multiple packages to install at once: In this chapter, we discussed how repetitive commands can be incorporated in loop constructs.  Most common loops are built using the  ,   or   statements, or a combination of these commands.  The   loop executes a task a defined number of times.  If you don't know how many times a command should execute, use either   or   to specify when the loop should end. Loops can be interrupted or reiterated using the   and   statements. A file can be used as input for a loop using the input redirection operator, loops can also read output from commands that is fed into the loop using a pipe. The   construct is used for printing menus in interactive scripts.  Looping through the command line arguments to a script can be done using the   statement. Remember: when building scripts, work in steps and test each step before incorporating it in your script. Create a script that will take a (recursive) copy of files in   so that a beginning system administrator can edit files without fear. Write a script that takes exactly one argument, a directory name.  If the number of arguments is more or less than one, print a usage message.  If the argument is not a directory, print another message.  For the given directory, print the five biggest files and the five files that were most recently modified. Can you explain why it is so important to put the variables in between double quotes in the example from  ? Write a script similar to the one in  , but think of a way of quitting after the user has executed 3 loops. Think of a better solution than   for the script from   to prevent overwriting of existing files.  For instance, test whether or not a file exists.  Don't do unnecessary work! Rewrite the   script from  , so that it: Prints a list of servers to check, such as Apache, the SSH server, the NTP daemon, a name daemon, a power management daemon, and so on. For each choice the user can make, print some sensible information, like the name of the web server, NTP trace information, and so on. Optionally, build in a possibility for users to check other servers than the ones listed.  For such cases, check that at least the given process is running. Review the script from  .  Note how character input other than   is processed.  Rebuild this script so that it prints a message if characters are given as input. In this chapter, we will discuss the advanced use of variables and arguments.  Upon completion, you will be able to:   Declare and use an array of variables Specify the sort of variable you want to use Make variables read-only Use   to assign a value to a variable 
 As we already saw, Bash understands many different kinds of variables or parameters.  Thus far, we haven't bothered much with what kind of variables we assigned, so our variables could hold any value that we assigned to them.  A simple command line example demonstrates this: There are cases when you want to avoid this kind of behavior, for instance when handling telephone and other numbers.  Apart from integers and variables, you may also want to specify a variable that is a constant.  This is often done at the beginning of a script, when the value of the constant is declared.  After that, there are only references to the constant variable name, so that when the constant needs to be changed, it only has to be done once.  A variable may also be a series of variables of any type, a so-called   of variables ( ,  , ...  ). Using a   statement, we can limit the value assignment to variables. The syntax for   is the following:   The following options are used to determine the type of data the variable can hold and to assign it attributes: Using   instead of   turns off the attribute instead.  When used in a function,   creates local variables. The following example shows how assignment of a type to a variable influences the value. Note that Bash has an option to declare a numeric value, but none for declaring string values.  This is because, by default, if no specifications are given, a variable can hold any type of data: As soon as you restrict assignment of values to a variable, it can only hold that type of data.  Possible restrictions are either integer, constant or array. See the Bash info pages for information on return status. In Bash, constants are created by making a variable read-only.  The   built-in marks each specified variable as unchangeable.  The syntax is:   The values of these variables can then no longer be changed by subsequent assignment.  If the   option is given, each variable refers to a shell function; see  .  If   is specified, each variable refers to an array of variables.  If no arguments are given, or if   is supplied, a list of all read-only variables is displayed.  Using the   option, the output can be reused as input. The return status is zero, unless an invalid option was specified, one of the variables or functions does not exist, or   was supplied for a variable name instead of for a function name. An array is a variable containing multiple values.  Any variable may be used as an array.  There is no maximum limit to the size of an array, nor any requirement that member variables be indexed or assigned contiguously.  Arrays are zero-based: the first element is indexed with the number 0. Indirect declaration is done using the following syntax to declare a variable:   The   is treated as an arithmetic expression that must evaluate to a positive number. Explicit declaration of an array is done using the   built-in:   A declaration with an index number will also be accepted, but the index number will be ignored.  Attributes to the array may be specified using the   and   built-ins.  Attributes apply to all variables in the array; you can't have mixed arrays. Array variables may also be created using compound assignments in this format:   Each value is then in the form of  .  The index number is optional.  If it is supplied, that index is assigned to it; otherwise the index of the element assigned is the number of the last index that was assigned, plus one.  This format is accepted by   as well.  If no index numbers are supplied, indexing starts at zero. Adding missing or extra members in an array is done using the syntax:   Remember that the   built-in provides the   option, which allows for reading and assigning values for member variables of an array. In order to refer to the content of an item in an array, use curly braces.  This is necessary, as you can see from the following example, to bypass the shell interpretation of expansion operators.  If the index number is   or  , all members of an array are referenced. Referring to the content of a member variable of an array without providing an index number is the same as referring to the content of the first element, the one referenced with index number zero. The   built-in is used to destroy arrays or member variables of an array: Practical examples of the usage of arrays are hard to find.  You will find plenty of scripts that don't really do anything on your system but that do use arrays to calculate mathematical series, for instance.  And that would be one of the more interesting examples...most scripts just show what you can do with an array in an oversimplified and theoretical way. The reason for this dullness is that arrays are rather complex structures.  You will find that most practical examples for which arrays could be used are already implemented on your system using arrays, however on a lower level, in the C programming language in which most UNIX commands are written.  A good example is the Bash   built-in command.  Those readers who are interested might check the   directory in the Bash source tree and take a look at  , which is processed when compiling the built-ins. Another reason good examples are hard to find is that not all shells support arrays, so they break compatibility. After long days of searching, I finally found this example operating at an Internet provider.  It distributes Apache web server configuration files onto hosts in a web farm: First two tests are performed to check whether the correct user is running the script with the correct arguments.  The names of the hosts that need to be configured are listed in the array  .  Then all these hosts are provided with the Apache configuration file, after which the daemon is restarted.  Note the use of commands from the Secure Shell suite, encrypting the connections to remote hosts. Thanks, Eugene and colleague, for this contribution. Dan Richter contributed the following example.  This is the problem he was confronted with: And this was his way of solving it: This script is then used in other scripts, such as this one, which uses a   document: We discussed this already in  . Using the   syntax will calculate the number of characters in a variable.  If   is   or  , this value is substituted with the number of positional parameters or number of elements in an array in general.  This is demonstrated in the example below:   If   is not defined or null, the expansion of   is substituted; otherwise the value of   is substituted: This form is often used in conditional tests, for instance in this one: It is a shorter notation for See   for more information about this type of condition testing. If the hyphen (-) is replaced with the equal sign (=), the value is assigned to the parameter if it does not exist: The following syntax tests the existence of a variable.  If it is not set, the expansion of   is printed to standard out and non-interactive shells quit.  A demonstration: Using   instead of the exclamation mark sets the variable to the expansion of  ; if it does not exist, nothing happens. To strip a number of characters, equal to  , from a variable, use this syntax:   The   parameter defines how many characters to keep, starting from the first character after the offset point.  If   is omitted, the remainder of the variable content is taken:   and   These constructs are used for deleting the pattern matching the expansion of   in  .    is expanded to produce a pattern just as in file name expansion.  If the pattern matches the beginning of the expanded value of  , then the result of the expansion is the expanded value of   with the shortest matching pattern ( ) or the longest matching pattern (indicated with  ). If   is   or  , the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If   is an array variable subscribed with   or  , the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.  This is shown in the examples below: The opposite effect is obtained using   and  , as in this example below.    should match a trailing portion of string: This is done using the   or   syntax.  The first form replaces only the first match, the second replaces all matches of   with  : More information can be found in the Bash info pages. Normally, a variable can hold any type of data, unless variables are declared explicitly.  Constant variables are set using the   built-in command. An array holds a set of variables.  If a type of data is declared, then all elements in the array will be set to hold only this type of data. Bash features allow for substitution and transformation of variables  .  Standard operations include calculating the length of a variable, arithmetic on variables, substituting variable content and substituting part of the content. Here are some brain crackers: Write a script that does the following: Display the name of the script being executed. Display the first, third and tenth argument given to the script. Display the total number of arguments passed to the script. If there were more than three positional parameters, use   to move all the values 3 places to the left. Print all the values of the remaining arguments. Print the number of arguments. Test with zero, one, three and over ten arguments. Write a script that implements a simple web browser (in text mode), using   and   to display HTML pages to the user.  The user has 3 choices: enter a URL, enter   for back and   to quit.  The last 10 URLs entered by the user are stored in an array, from which the user can restore the URL by using the   functionality. In this chapter, we will discuss 
 What functions are Creation and displaying of functions from the command line Functions in scripts Passing arguments to functions When to use functions 
 Shell functions are a way to group commands for later execution, using a single name for this group, or  .  The name of the routine must be unique within the shell or script.  All the commands that make up a function are executed like regular commands.  When calling on a function as a simple command name, the list of commands associated with that function name is executed.  A function is executed within the shell in which it has been declared: no new process is created to interpret the commands. Special built-in commands are found before shell functions during command lookup.  The special built-ins are:  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Functions either use the syntax   or   Both define a shell function  .  The use of the built-in command   is optional; however, if it is not used, parentheses are needed. The commands listed between curly braces make up the body of the function.  These commands are executed whenever   is specified as the name of a command.  The exit status is the exit status of the last command executed in the body. The curly braces must be separated from the body by spaces, otherwise they are interpreted in the wrong way. The body of a function should end in a semicolon or a newline. Functions are like mini-scripts: they can accept parameters, they can use variables only known within the function (using the   shell built-in) and they can return values to the calling shell. A function also has a system for interpreting positional parameters.  However, the positional parameters passed to a function are not the same as the ones passed to a command or script. When a function is executed, the arguments to the function become the positional parameters during its execution.  The special parameter   that expands to the number of positional parameters is updated to reflect the change. Positional parameter   is unchanged.  The Bash variable   is set to the name of the function, while it is executing. If the   built-in is executed in a function, the function completes and execution resumes with the next command after the function call.  When a function completes, the values of the positional parameters and the special parameter   are restored to the values they had prior to the function's execution.  If a numeric argument is given to  , that status is returned.  A simple example: Note that the return value or exit code of the function is often storen in a variable, so that it can be probed at a later point.  The init scripts on your system often use the technique of probing the   variable in a conditional test, like this one: Or like this example from the   script, where Bash's optimization features are used: The commands after   are only executed when the test proves to be true; this is a shorter way to represent an   structure. The return code of the function is often used as exit code of the entire script.  You'll see a lot of initscripts ending in something like  . All functions known by the current shell can be displayed using the   built-in without options.  Functions are retained after they are used, unless they are   after use.  The   command also displays functions: This is the sort of function that is typically configured in the user's shell resource configuration files.  Functions are more flexible than aliases and provide a simple and easy way of adapting the user environment. Here's one for DOS users: There are plenty of scripts on your system that use functions as a structured way of handling series of commands.  On some Linux systems, for instance, you will find the   definition file, which is sourced in all init scripts.  Using this method, common tasks such as checking if a process runs, starting or stopping a daemon and so on, only have to be written once, in a general way.  If the same task is needed again, the code is recycled. You could make your own   file that contains all functions that you use regularly on your system, in different scripts.  Just put the line    somewhere at the start of the script and you can recycle functions. This section might be found in your   file.  The function   is defined and then used to set the path for the   and other users: The function takes its first argument to be a path name.  If this path name is not yet in the current path, it is added.  The second argument to the function defines if the path will be added in front or after the current   definition. Normal users only get   added to their paths, while   gets a couple of extra directories containing system commands.  After being used, the function is unset so that it is not retained. The following example is one that I use for making backups of the files for my books.  It uses SSH keys for enabling the remote connection.  Two functions are defined,   and  , that each make a   file, which is then compressed and sent to a remote server.  After that, the local copy is cleaned up. On Sunday, only   is executed. This script runs from cron, meaning without user interaction, so we redirect standard error from the   command to  . It might be argued that all the separate steps can be combined in a command such as   However, if you are interested in intermediate results, which might be recovered upon failure of the script, this is not what you want. The expression   is equivalent to   Functions provide an easy way of grouping commands that you need to execute repetitively.  When a function is running, the positional parameters are changed to those of the function.  When it stops, they are reset to those of the calling program.  Functions are like mini-scripts, and just like a script, they generate exit or return codes. While this was a short chapter, it contains important knowledge needed for achieving the ultimate state of laziness that is the typical goal of any system administrator. Here are some useful things you can do using functions: Add a function to your   config file that automates the printing of man pages.  The result should be that you type something like  , upon which the first appropriate man page rolls out of your printer.  Check using a pseudo printer device for testing purposes. As an extra, build in a possibility for the user to supply the section number of the man page he or she wants to print. Create a subdirectory in your home directory in which you can store function definitions.  Put a couple of functions in that directory.  Useful functions might be, amongs others, that you have the same commands as on DOS or a commercial UNIX when working with Linux, or vice versa.  These functions should then be imported in your shell environment when   is read. In this chapter, we will discuss the following subjects:   Available signals Use of the signals Use of the   statement How to prevent users from interrupting your programs 
 Your system contains a man page listing all the available signals, but depending on your operating system, it might be opened in a different way.  On most Linux systems, this will be  .  When in doubt, locate the exact man page and section using commands like   or   Signal names can be found using  . In the absence of any traps, an interactive Bash shell ignores   and  .    is caught and handled, and if job control is active,  ,   and   are also ignored.  Commands that are run as the result of a command substitution also ignore these signals, when keyboard generated.  by default exits a shell.  An interactive shell will send a   to all jobs, running or stopped; see the documentation on the   built-in if you want to disable this default behavior for a particular process.  Use the   option for killing all jobs upon receiving a   signal, using the   built-in. The following signals can be sent using the Bash shell: Check your   settings.  Suspend and resume of output is usually disabled if you are using   terminal emulations.  The standard   supports  +  and  +  by default. Most modern shells, Bash included, have a built-in   function.  In Bash, both signal names and numbers are accepted as options, and arguments may be job or process IDs.  An exit status can be reported using the   option: zero when at least one signal was successfully sent, non-zero if an error occurred. Using the   command from  , your system might enable extra options, such as the ability to kill processes from other than your own user ID and specifying processes by name, like with   and  . Both   commands send the   signal if none is given. This is a list of the most common signals:  and   can not be caught, blocked or ignored. When killing a process or series of processes, it is common sense to start trying with the least dangerous signal,  .  That way, programs that care about an orderly shutdown get the chance to follow the procedures that they have been designed to execute when getting the   signal, such as cleaning up and closing open files.  If you send a   to a process, you remove any chance for the process to do a tidy cleanup and shutdown, which might have unfortunate consequences. But if a clean termination does not work, the   or  signals might be the only way.  For instance, when a process does not die using  + , it is best to use the   on that process ID: When a process starts up several instances,   might be easier.  It takes the same option as the   command, but applies on all instances of a given process.  Test this command before using it in a production environment, since it might not work as expected on some of the commercial Unices. There might be situations when you don't want users of your scripts to exit untimely using keyboard abort sequences, for example because input has to be provided or cleanup has to be done.  The   statement catches these sequences and can be programmed to execute a list of commands upon catching those signals. The syntax for the   statement is straightforward:   This instructs the   command to catch the listed  , which may be signal names with or without the   prefix, or signal numbers.  If a signal is   or  , the   are executed when the shell exits.  If one of the signals is  , the list of   is executed after every simple command.  A signal may also be specified as  ; in that case   are executed each time a simple command exits with a non-zero status.  Note that these commands will not be executed when the non-zero exit status comes from part of an   statement, or from a   or   loop.  Neither will they be executed if a logical   (&&) or   (||) result in a non-zero exit code, or when a command's return status is inverted using the   operator. The return status of the   command itself is zero unless an invalid signal specification is encountered.  The   command takes a couple of options, which are documented in the Bash info pages. Here is a very simple example, catching  +  from the user, upon which a message is printed.  When you try to kill this program without specifying the   signal, nothing will happen: When Bash receives a signal for which a trap has been set while waiting for a command to complete, the trap will not be executed until the command completes.  When Bash is waiting for an asynchronous command via the   built-in, the reception of a signal for which a trap has been set will cause the   built-in to return immediately with an exit status greater than 128, immediately after which the trap is executed. When debugging longer scripts, you might want to give a variable the   attribute and trap   messages for that variable.  Normally you would just declare a variable using an assignment like  .  Replacing the declaration of the variable with the following lines might provide valuable information about what your script is doing: The   command relies on a database which is regularly built using the   script with cron: Signals can be sent to your programs using the   command or keyboard shortcuts.  These signals can be caught, upon which action can be performed, using the   statement. Some programs ignore signals.  The only signal that no program can ignore is the   signal. A couple of practical examples: Create a script that writes a boot image to a diskette using the   utility.  If the user tries to interrupt the script using  + , display a message that this action will make the diskette unusable. Write a script that automates the installation of a third-party package of your choice.  The package must be downloaded from the Internet.  It must be decompressed, unarchived and compiled if these actions are appropriate.  Only the actual installation of the package should be uninterruptable. This document gives an overview of common shell features (the same in every shell flavour) and differing shell features (shell specific features). 
The following features are standard in every shell.  Note that the stop, suspend, jobs, bg and fg commands are only available on systems that support job control.
 The table below shows major differences between the standard shell ( ), Bourne Again SHell ( ), Korn shell ( ) and the C shell ( ). Since the Bourne Again SHell is a superset of  , all   commands will also work in   - but not vice versa.    has many more features of its own, and, as the table below demonstrates, many features incorporated from other shells. Since the Turbo C shell is a superset of  , all   commands will work in  , but not the other way round. The Bourne Again SHell has many more features not listed here.  This table is just to give you an idea of how this shell incorporates all useful ideas from other shells: there are no blanks in the column for  .  More information on features found only in Bash can be retrieved from the Bash info pages, in the   section. More information: You should at least read one manual, being the manual of your shell.  The preferred choice would be  ,   being the GNU shell and easiest for beginners.  Print it out and take it home, study it whenever you have 5 minutes. This section contains an alphabetical overview of common UNIX commands.  More information about the usage can be found in the man or info pages. Format files for printing on a PostScript printer. PDF viewer. Create a new user or update default new user information. Create a shell alias for a command. Execute commands periodically, does not assume continuously running machine. Search the whatis database for strings. APT package handling utility. Spell checker. Queue, examine or delete jobs for later execution. Adjust audio mixer. Pattern scanning and processing language. Bourne Again SHell. Queue, examine or delete jobs for later execution. Run a job in the background. Bitmap editor and converter utilities for the X window System. A block-sorting file compressor. Concatenate files and print to standard output. Change directory. An interactive text-mode program for controlling and playing
       audio CD Roms under Linux. An audio CD reading utility which
       includes extra data verification features. Record a CD-R. Change file attributes. Change group ownership. Update or query run level information for system services. Change file access permissions. Change file owner and group. Compress files. Copy files and directories. Maintain crontab files. Open a C shell. Remove sections from each line of file(s). Print or set system date and time. Convert and copy a file (disk dump). Report file system disk usage. DHCP client daemon. Find differences between two files. Send domain name query packets to name servers. Print or control the kernel ring buffer. Estimate file space usage. Display a line of text. Diff to English translator. Extended grep. Unmount and eject removable media. Start the Emacs editor. Invoke subprocess(es). Exit current shell. Add function(s) to the shell environment. Convert a TIFF facsimile to PostScript. Format floppy disk. Partition table manipulator for Linux. Fetch mail from a POP, IMAP, ETRN or ODMR-capable server. Bring a job in the foreground. Determine file type. Find files. Mail (re)formatter. Print a random, hopefully interesting adage. Transfer files (unsafe unless anonymous account is used!)services. Graphical web browser. Gnome Display Manager. Control console devices. Image manipulation program. Print lines matching a pattern. The grub shell. A PostScript and PDF viewer. Compress or expand files. Stop the system. Output the first part of files. Display help on a shell built-in command. DNS lookup utility. Apache hypertext transfer protocol server. Print real and effective UIDs and GIDs. Configure network interface or show configuration. Read Info documents. Process control initialization. Display I/O statistics. Display/change network interface status. IP firewall administration. IP packet filter administration. Java archive tool. List backgrounded tasks. Desktop manager for KDE. Terminate process(es). Open a Korn shell. Modify an LDAP entry. LDAP search tool.  with features. Linux boot loader. Text mode WWW browser. Make links between files. Load keyboard translation tables. Find files. Close current shell. Send requests to the LP print service. Line printer control program. Print spool queue examination program. Offline print. Remove print requests. List directory content. Text mode WWW browser. Send and receive mail. Read man pages. Copy MSDOS files to/from Unix. Display an MSDOS directory. Display memory usage. Display memory usage statistics. Control write access to your terminal. Add an MSDOS file system to a low-level formatted floppy disk. Creates a stand-alone boot floppy for the running system. Create directory. Create a hybrid ISO9660 filesystem. Filter for displaying text one screen at the time. Mount a file system or display information about mounted file systems. Web browser. Control magnetic tape drive operation. Network diagnostic tool. Rename files. Internet domain name server. Browser program for ftp services (insecure!). Print network connections, routing tables, interface statistics, masquerade connections, and multi-cast memberships. Print statistics about networked file systems. Run a program with modified scheduling priority. Network exploration tool and security scanner. Simple interface for configuring run levels. Change password. Ghostscript PDF to PostScript translator. Practical Extraction and Report Language. Page through text output. Send echo request to a host. Convert text files for printing. Print all or part of environment. Autonomous mail processor. Report process status. Display a tree of processes. Print present working directory. Display disk usage and limits. Remote copy (unsafe!) Remote Desktop Protocol client. Stop and restart the system. Alter priority of a running process. Remote login (telnet, insecure!). Remove a file. Remove a directory. RPM Package Manager. Remote shell (insecure!). Secure remote copy. Screen manager with VT100 emulation. Display, set or change variable. Set terminal attributes. Secure (encrypted) ftp. Open a standard shell. Bring the system down. Wait for a given period. Security Enhanced version of the GNU Locate. text mode Usenet client. Network intrusion detection tool. Sort lines of text files. Secure shell. Authentication key generation. Change and print terminal line settings. Switch user. Concatenate and print files in reverse. Output the last part of files. Talk to a user. Archiving utility. Open a Turbo C shell. User interface to the TELNET protocol (insecure!). Text formatting and typesetting. Time a simple command or give resource usage. News reading program. Display top CPU processes. Change file timestamps. Print the route packets take to network host. A file integrity checker for UNIX systems. Tab Window Manager for the X Window System. Controll resources. Set user file creation mask. Unmount a file system. Decompress compressed files. Remove duplicate lines from a sorted file. Kernel daemon to flush dirty buffers back to disk. Display system uptime and average load. Delete a user account and related files. Start the vi (improved) editor. The Vim tutor. Report virtual memory statistics. Show who is logged on and what they are doing. Send a message to everybody's terminal. Print the number of bytes, words and lines in files. Shows the full path of (shell) commands. Show who is logged on. Print effective user ID. Query a whois or nicname database. Send a message to another user. X authority file utility. Graphical front end to cdrecord. Analog/digital clock for X. Monitor system console messages with X. X Display Manager with support for XDMCP, host chooser. DVI viewer. X font server. Server access control program for X The extended Internet services daemon. System load average display for X. Server font list displayer for X. Audio player for X. PDF viewer. Terminal emulator for X. Compress or expand files. Search possibly compressed files for a regular expression. Filter for viewing compressed text. ,  The C shell,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  Korn shell,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  Linux and Unix tutorials for new and seasoned sysadmin Linux and Unix tutorials for new and seasoned sysadmin ow do I use bash for loop to repeat certain task under Linux / UNIX operating system? How do I set infinite loops using for statement? How do I use three-parameter for loop control expression?    A ‘for loop’ is a bash programming language statement which allows code to be repeatedly executed. A for loop is classified as an iteration statement i.e. it is the repetition of a process within a bash script. For example, you can run UNIX command or task 5 times or read and process list of files using a for loop. A for loop can be used at a shell prompt or within a shell script itself. Numeric ranges for syntax is as follows: for VARIABLE in 1 2 3 4 5 .. N
do
 command1
 command2
 commandN
done OR for VARIABLE in file1 file2 file3
do
 command1 on $VARIABLE
 command2
 commandN
done OR for OUTPUT in $(Linux-Or-Unix-Command-Here)
do
 command1 on $OUTPUT
 command2 on $OUTPUT
 commandN
done  This type of for loop is characterized by counting. The range is specified by a beginning (#1) and ending number (#5). The for loop executes a sequence of commands for each member in a list of items. A representative example in BASH is as follows to display welcome message 5 times with for loop: #!/bin/bash
for i in 1 2 3 4 5
do
 echo "Welcome $i times"
done Sometimes you may need to set a step value (allowing one to count by two’s or to count backwards for instance). Latest   has inbuilt support for setting up ranges: #!/bin/bash
for i in {1..5}
do
 echo "Welcome $i times"
done Bash v4.0+ has inbuilt support for setting up a step value using { } syntax: #!/bin/bash
echo "Bash version ${BASH_VERSION}..."
for i in {0..10..2}
 do 
 echo "Welcome $i times"
 done Sample outputs: The   can be used as follows. A representative example in seq is as follows: #!/bin/bash
for i in $(seq 1 2 20)
do
 echo "Welcome $i times"
done There is no good reason to use an external command such as seq to count and increment numbers in the for loop, hence it is recommend that you avoid using seq. The builtin command are fast. This type of for loop share a common heritage with the C programming language. It is characterized by a three-parameter loop control expression; consisting of an initializer (EXP1), a loop-test or condition (EXP2), and a counting expression/step (EXP3). for (( EXP1; EXP2; EXP3 ))
do
 command1
 command2
 command3
done
## The C-style Bash for loop ##
for (( initializer; condition; step ))
do
 shell_COMMANDS
done A representative three-expression example in bash as follows: #!/bin/bash
for (( c=1; c<=5; c++ ))
do 
 echo "Welcome $c times"
done Sample output: Infinite for loop can be created with empty expressions, such as: #!/bin/bash
for (( ; ; ))
do
 echo "infinite loops [ hit CTRL+C to stop]"
done You can do early exit with break statement inside the for loop. You can exit from within a FOR, WHILE or UNTIL loop using break. General break statement inside the for loop: for I in 1 2 3 4 5
do
 statements1      #Executed for all values of ''I'', up to a disaster-condition if any.
 statements2
 if (disaster-condition)
 then
 break       	   #Abandon the loop.
 fi
 statements3              #While good and, no disaster-condition.
done Following shell script will go though all files stored in /etc directory. The for loop will be abandon when /etc/resolv.conf file found. #!/bin/bash
for file in /etc/*
do
 if [ "${file}" == "/etc/resolv.conf" ]
 then
 countNameservers=$(grep -c nameserver /etc/resolv.conf)
 echo "Total  ${countNameservers} nameservers defined in ${file}"
 break
 fi
done To resume the next iteration of the enclosing FOR, WHILE or UNTIL loop use continue statement. for I in 1 2 3 4 5
do
 statements1      #Executed for all values of ''I'', up to a disaster-condition if any.
 statements2
 if (condition)
 then
 continue   #Go to next iteration of I in the loop and skip statements3
 fi
 statements3
done This script make backup of all file names specified on command line. If .bak file exists, it will skip the cp command. #!/bin/bash
FILES="$@"
for f in $FILES
do
 # if .bak backup file exists, read next file
 if [ -f ${f}.bak ]
 then
 echo "Skiping $f file..."
 continue  # read next file and skip the cp command
 fi
 # we are here means no backup file exists, just use cp command to copy file
 /bin/cp $f $f.bak
done In this example, we use the for loop to iterate over an array of elements defined as follows: DB_AWS_ZONE=('us-east-2a', 'us-west-1a', 'eu-central-1a')  for zone in "${DB_AWS_ZONE[@]}"
do
 echo "Creating rds (DB) server in $zone, please wait ..."
 aws rds create-db-instance \
 --availability-zone "$zone"
 --allocated-storage 20 --db-instance-class db.m1.small \
 --db-instance-identifier test-instance \
 --engine mariadb \
 --master-username my_user_name \
 --master-user-password my_password_here
done Sometimes we store important data in the shell variable, and we can use for a loop as follows to read the data: _admin_ip="202.54.1.33|MUM_VPN_GATEWAY 23.1.2.3|DEL_VPN_GATEWAY 13.1.2.3|SG_VPN_GATEWAY"
for e in $_admin_ip
do
 ufw allow from "${e%%|*}" to any port 22 proto tcp comment 'Open SSH port for ${e##*|}'
done We can specify a range  in loops as follows: for i in {START..END}
do
 commands
done
## step value ##
for i in {START..END..STEP}
do
 commands
done
## example: ping cbz01, cbz02, cbz03, and cbz04 using a loop ##
for i in 0{1..4}
do
 h="cbz${i}"
 ping -c 1 -q "$h" &>/dev/null 
 if [ $? -eq 0 ]
 then
 echo "server $h alive" 
 else
 echo "server $h dead or can not ping."
 fi
done Say we have a variable named PKGS, and we need to loop through a list of strings to install those packages: PKGS="php7-openssl-7.3.19-r0  php7-common-7.3.19-r0  php7-fpm-7.3.19-r0  php7-opcache-7.3.19-r0 php7-7.3.19-r0"
for p in $PKGS
do
 echo "Installing $p package"
 sudo apk add "$p"
done  means run a shell command and store its output to a variable. For example: up=$(uptime)
echo "Server uptime is $up" The for Loop argument list also workes command substitution as follows: for var in $(command)
do
 print "$var"
done
## example ##
for f in $(ls /nas/*.pdf)
do
 print "File $f"
done A   is nothing but an argument sent to a program being called. A program can take any number of command line arguments. For example, we are going to use the   to search for user names in  :    grep is the name of an actual command and shell executed this command when you type command at shell prompt. The first word on the command line is: The for Loop argument list also accpents Command-line arguments/paramenters as follows: ## $@ expands to the positional parameters, starting from one.  ##
for i in $@
do
 echo "Script arg is $i"
done You run it as follows:   Bash for loop is useful for automating repetitive tasks in IT. Let us see how to run a simple command (such as uptime) on multiple Linux or Unix servers: for s in server1 server2 server3
do
 ssh vivek@${s} "uptime"
done OR combine the echo command along with   as follows: for s in server1 server2 server3
do
 echo "Server ${s}: $(ssh vivek@${s} uptime)"
done Sample outputs: In this standard bash for loop example we are going to update all CentOS/RHEL based servers using the   or  /  in case we have a Debian/Ubuntu based servers: ## CENTOS/RHEL example (for fedora replace yum with dnf) ##
for s in server0{1..8}
do
 echo "*** Patching and updating ${s} ***"
 ssh root@${s} -- "yum -y update"
done Here is simple but useful shell script example: #!/usr/bin/env bash
# Purpose: Update all my Linode servers powered by Debian/Ubuntu Linux
# Author: Vivek Gite under GPL v2.x+
# ----------------------------------------
log="/tmp/apt-get.log"
>"${log}"
for s in ln.cbz0{1..5}
do 
 echo "Updating and patching $s, please wait..." | tee -a "${log}"
 ssh root@${s} -- apt-get -q -y update >/dev/null
 ssh root@${s} -- DEBIAN_FRONTEND=noninteractive apt-get -y -q upgrade >>"${log}"
done
echo "Check $log file for details." See why we used   to avoid any prompts duding updates. It would be best if you   for automation purposes or running scripts from  . This tutorial is also available in a quick video format. The video shows some additional and practical examples such as converting all flac music files to mp3 format, all avi files to mp4 video format, unzipping multiple zip files or tar balls, gathering uptime information from multiple Linux/Unix servers, detecting remote web-server using domain names and much more. You learned how to use the bash for loop with various example. For loops can save time and help you with automation for tiny tasks. However, for complicated IT automation tasks, you should use tools like  , Salt, Chef,   and others. See the following resources for more info.  The author is the creator of nixCraft and a seasoned sysadmin, DevOps engineer,  and a trainer for the Linux operating system/Unix shell scripting. Get the   or  . Nice one. All the examples are explained well, thanks Vivek. seq 1 2 20  output can also be produced using jot jot – 1 20 2 The infinite loops as everyone knows have the following alternatives. while(true)  or  while : //Jadu The last example can also be produced without the ” in $FILES”: #!/bin/sh for f  do # For-Loop body done If the ” in …” is excluded, the loop will run as if “in $@” was given. Nice explanation tutorial. hey vivek i tried the following syntax for for loop suggested by u but both dint work…  1.  #!/bin/bash  for (( c=1; c<=5; c++ ))  do  echo “Welcome $c times…”  done 2.  #!/bin/bash  for i in {1..5}  do  echo “Welcome $i times”  done got error for both the syntax  1. unexpected ‘(‘  2. it printed welcome {1..5} times instead repeating it… help..? hi manish your both coding are correct… before execute you must give the execution permission for that file… so you try following steps…  1.goto terminal  2. vim simple  3.then write the following code.. for (( c=1; c<=5; c++ ))  do  echo “Welcome $c times…”  done 4.then save and quit  5.chmod 744 simple  6.    ./simple i hope surely it will help you… It works properly just check it again.. I can help you on 2. — You were not using the Bash 3.0 or higher. Upgrade your bash and it will work. Hi All, I have some ‘.gif’ and ‘.jpg’ files in a directory named Pictures in my home directory. I need to write bash script that would create 2 separate html files such as page1.html and page2.html one for gif files and the other for jpg files. And when i execute the script i need to have the html files in the Pictures directory and should have the contents as follows: filename.jpg  filename.jpg filename.gif  filename.gif Please help me out. Thanks in advance your problem is very easy to solve using the examples on the page. in addition to the for loops, you will need to use the echo command, the redirection operator >> and a basic knowledge of html. your script should do: 1. create a html file with the header, opening body tags etc.  2. have a loop for all jpg files  2.1 inside the loop, print one line with the html code for an image, using the image’s filename  3. close the loop, add closing html tags  4-6. same as 1-3, but for .gif instead of .jpg i tried the last example but i seen dint work #!/bin/bash  set -x  FILLES="$@"
CP=$(which cp)
for f in $FILES
do
 if [ -f ${f}.bak ]
 then
 echo "skiping $f file"
 continue # read netxt file and skip cp command
 fi
 $CP $f $f.bak
done i would like know where is the error Maybe correcting your misspelled variable ”FILLES” would be a step forward? Replace With hi guys . can any one help me . i need a script to check the file  /var/log/messages  every 10 minutes .and  if its has the following log :  ext3_orphan_cleanup: deleting unreferenced to apply the following command  sendsms to wut ever . thnx alot i would like to breakk a csv file depending upon two criteria. 1. SIngle file should not be more than 100 lines  2. The third column if has same value on the 100th line as that of the 101th line, the complete line should be included in the 2nd file.  so., now, 1st file will have 99 lines and 2nd file will have 100 lines, ifthe above 2nd condition does not repeats., for file in $(ls 0902*0010202.TLG); do  day=$(echo $file | cut -c 1-6)  grep ^203 $file | cut -d, -f3 | sort | uniq -c | while read line; do  cnt=$(echo $line | cut -d” ” -f1)  acct=$(echo $line | cut -d” ” -f2)  echo “Date 20${day} Account ${acct} had ${cnt} 203’s” >> Feb_report.txt  done  done when i run it it gives me a syntax error  ins@ARTMGA01> ./arc.sh  ./arc.sh: syntax error at line 4: `$’ unexpected could you help Good examples!! easily understood Hi How do I read line by line in a file, and use these in a loop? I have a file I read in (cmd max_cpu):  firefox 15  conky 1  cmds=$(cat file)  But $cmds now consist of n items, all being “equal” – it does not split on each line to a new array. I expected that by looping over $cmds, I’d get a 2D array…. I did not. Otherwise, excellent tutorial! Try: I know this is an ancient thread, but thought this trick might be helpful to someone: For the above example with all the cuts, simply do   This will split line into positional parameters and you can after the set simply say   I used this a lot many years ago on solaris with “set `date`”, it neatly splits the whole date string into variables and saves lots of messy cutting :-) … no, you can’t change the FS, if it’s not space, you can’t use this method This *is* helpful – good knowledge to have. I’ll go give it a try. Thanks! Hi Vivek,  Please help I was trying to use your code in a script similar issue trying to use a csv file with three columns (loginname,surname,firname) as input for a file that will be executed  fileA  loginN,ssn,ffn  ab1pp1,ab1,pp1  bb1oo1,bb1,oo1  cc1qq1,cc1,qq1 #file to be changed cmdch.sh  echo “your login name is $loginn, your surname is $ssn and your firname $ffn” Program  #!/bin/bash LINNUM=4  while read LINE;  do  LINNUM=`expr $LINENUM + 1`  done < smallops.csv FILE=fileA.csv  while read LINE;  do  #store field 1  F1=$(echo $line|cut -d$FS -f1)  #store field 2  F2=$(echo $line|cut -d$FS -f6)  #store field 3  F3=$(echo $line|cut -d$FS -f7)  sed '{$LINNUM  s/lgn/$F1/g; $LINNUM s/ssn/$F2/g; $LINNUM s/ffn/$F3/g; }' -i smallops.csv  done < g.csv echo @Alvin First, this code won’t work at least because it does not input fileA.csv as intended. Second, to debug, try to break down this program, piece by piece. For instance, it could read input more easily from fileA.csv this way:  (I have not included your [sed] instruction yet. Go step by step) Third, try to explain what you would like to do with you [sed] instruction. Why do you start your LINENUM at 4? What is the content of your smallops.csv? What is it for? By the way, your [sed] instruction seems to contain a mispelled search pattern, for first field $F1, should’nt it be [loginn] instead of [lgn] ? You mention only ONE csv file, but your code contains: fileA.csv, smallops.csv, and g.csv ? What are they? Typos ? Errors in your code? Sorry, (I forgot a HTML code TAG) Complete code is: Excellent! Thanks Vivek. Hi Vivek,  Thanks for this a useful topic. IMNSHO, there may be something to modify here  =======================  Latest bash version 3.0+ has inbuilt support for setting up a step value: #!/bin/bash  for i in {1..5}  =======================  1) The increment feature seems to belong to the version 4 of bash.  Reference:   Accordingly, my bash v3.2 does not include this feature. BTW, where did you read that it was 3.0+ ?  (I ask because you may know some good website of interest on the subject). 2) The syntax is {from..to..step} where from, to, step are 3 integers.  You code is missing the increment. Note that GNU Bash documentation may be bugged at this time,  because on GNU Bash manual, you will find the syntax {x..y[incr]}  which may be a typo. (missing the second “..” between y and increment). see  The Bash Hackers page  again, see   seeems to be more accurate,  but who knows ? Anyway, at least one of them may be right… ;-) Keep on the good work of your own,  Thanks a million. — Peko @ Peko, Thanks for pointing out ranges vs step value. I’ve updated the FAQ. Yes. But you mispelled the syntax with an extra dot “.” after “START’  not {START…END..INCREMENT}  but {START..END..INCREMENT} ;-)  — Peko Hello, is there a simple way to control the number formatting? I use several computers, some of which have non-US settings with comma as a decimal point. This means that    gives 0 0.1 0.2 … 1 one some machines and 0 0,1 0,2 … 1 on other.  Is there a way to force the first variant, regardless of the language settings? Can I, for example, set the keyboard to US inside the script? Or perhaps some alternative to   that would convert commas to points?  (I am sending these as parameters to another code and it won’t accept numbers with commas…) The best thing I could think of is adding   as a first line inside the loop, but there should be a better solution? (Interestingly, the sed command does not seem to be upset by me rewriting its variable.) Thanks,  Michal To Michal Kaut: Hi Michal, Such output format is configured through LOCALE settings. I tried : export LC_CTYPE=”en_EN.UTF-8″; seq 0 0.1 1 and it works as desired. You just have to find the exact value for LC_CTYPE that fits to your systems and your needs. Peko To Michal Kaus [2] Ooops – ;-)  Instead of LC_CTYPE,  LC_NUMERIC  should be more appropriate  (Although LC_CTYPE is actually yielding to the same result – I tested both) By the way, Vivek has already documented the matter :  — Peko Excellent stuff… keep up the good work. Comment 12 was really helpful. I was trying to split up a log file by date, such as  logfile.20091026 , without having to use grep a million times. I’m kind of disappointed I couldn’t find a one-liner to do so, but I will take what I can get :). @Brad, Try this without grep or cut using bash parameter expansion : HTH H i vivek, Just wondering why you don’t amend the typo I pointed out:  <> I think you misunderstood. I’m going line by line, and converting the dates at the beginning of the line, such as “Sep 12”, and copying that line from logfile to logfile.20090912. My script is   slow though, with the conversion of the month name to a number. I’ve tried using the date command, and my own function, and both take 7 seconds to process 10,000 lines. It doesn’t seem like a long time, but I’ve got a lot of log files to process on multiple machines. I don’t guess you’d know a faster trick, would you? @Brad,  yes,  I did misunderstood your post. If I were you I will try out awk. @Philippe,  Thanks for the heads up. The faq has been updated. @Peko: (I’m the operator of bash-hackers.org/wiki, that’s why I found this page): Regarding Bash documentation for brace expansion (increment syntax), actually I’m right and the documentation is wrong (a rare situation!). I reported it to the list. To Vivek:  Regarding your last example,  that is : running a loop through arguments given to the script on the command line, there is a simplier way of doing this:  # instead of:  # FILES=”$@”  # for f in $FILES # use the following syntax  for arg  do  # whatever you need here – try : echo “$arg”  done Of course, you can use any variable name, not only “arg”. To TheBonsai: Welcome Buddy!  Fine! I am happy to see 2 great FOSS web sites now related ! Command line while loop.. Very handy.. Say you wanted to rename all the files in a specific dir..  Create a file with the contents you want to rename  (ls -l | awk ‘{print $9}’ > asdf or something) Contents of asdf:  file1  file2  file3  file4 cat asdf | while read a ; do mv $a $a.new ; done ls -l  asdf  file1.new  file2.new  file3.new  file4.new I have used this while command for many things from simply renaming files to formatting and labling new SAN luns.. There are much easier ways to do this – also it works only for extensions. How do you change the middle of the file name or a few characters on the left? Here is the regular way of what you just did: for i in *; do mv $i $i.new; done There are 2 problems and one optical flaw with your code: (1) You should use read -r without any variable name given, to use the default $REPLY (due to a specific behaviour of read, see manpage)  (2) You should quote $a  (3) Useless use af cat :) To tdurden: Why would’nt you use 1) either a [for] loop  for old in * ; do mv ${old} ${old}.new; done 2) Either the [rename] command ?  excerpt form “man rename” : RENAME(1)              Perl Programmers Reference Guide              RENAME(1) NAME  rename – renames multiple files SYNOPSIS  rename [ -v ] [ -n ] [ -f ] perlexpr [ files ] DESCRIPTION  “rename” renames the filenames supplied according to the rule specified  as the first argument.  The perlexpr argument is a Perl expression  which is expected to modify the $_ string in Perl for at least some of  the filenames specified.  If a given filename is not modified by the  expression, it will not be renamed.  If no filenames are given on the  command line, filenames will be read via standard input.  For example, to rename all files matching “*.bak” to strip the  extension, you might say  rename ‘s/\.bak$//’ *.bak  To translate uppercase names to lower, you’d use  rename ‘y/A-Z/a-z/’ * — Philippe Note for rename(1): There exist two major variants on Linux system. One non-Perl originating in the RedHat area, and one Per, originating in the Debian area. To tdurden: I would also replace “ls -l | awk ‘{print $9}'” with just “ls”.  Otherwise you’ll run into issues with files that have spaces in it.  As far as using: for i in *;  vs  for i in $(ls); I personally prefer “$(ls)” or “$(find . )”.  This provides more control over what files I’m going to be looping through.  For instance: $(ls -F | grep -v “\/$”)  or  $(ls -A) #!/bin/bash  echo “Bash version ${BASH_VERSION}…”  for i in {0..10..2}  do  echo “Welcome to my new script $i times”  done help    ……………………….. :) To Sean:  CMIIAW : try the following commands:  #  touch “file with spaces in name”  # for f in *; do echo “”;done  … … which shows that there is no need to use [for f in $(ls)] instead of [ for f in *]  Doesn’t it ? — Philippe Sorry Sean, my last post was truncated,  due to limitations of this form used to post comments. (impossible to use Greater_than and Less_than caracters) I meant, use the following:  # touch “file with spaces in name”  # for f in *; do echo “:${f}:”;done  …  :file with spaces in name:  … Sorry for the confusion, I understand that “for i in *;” will not have any issues with spaces.  I was referring to the ls -l | awk ‘{print $9}’ having issues with spaces.  The reason I choose to use $(ls) instead of * is for filtering out unwanted files e.g. $(ls -F | grep -v “\/$”) To Sean: But then, that’s wrong.  [ for f in $(ls -F|grep -v “V$”) ]  won’t process appropriately spaces in filename.  Check :  # touch “file with spaces in name”  # for f in $(ls -F|grep -v “V$”); do echo “:${f}:”;done  :file:  :with:  :spaces:  :in:  :name: The best tool to filter files and process them  is [find] piped to [xargs] (with zero-ended filenames) To sean:  But if you want to exclude files from globbing,  [bash] has the [extglob] option. Let’s say you want to process every file except files ending by a “V”, just type # for f in !(*V); do echo “:${f}:”;done If you set the  shell option extglob, Bash understands some more powerful patterns. Here, a  is one or more pattern, separated by the pipe-symbol (|). ?()	Matches zero or one occurrence of the given patterns  *()	Matches zero or more occurrences of the given patterns  +()	Matches one or more occurrences of the given patterns  @()	Matches one of the given patterns  !()	Matches anything except one of the given patterns source:  I have two files here  X.a and y.a Now what i need is i need to substitute  CvfdsDisk_sdb/c/d/e  in lines of Node CvfsDisk_XXX in the order CvfsDisk_sdb/c/f/g first word of each line of x.a exists. how can i do in shell scripting i can get the first word of each line of X.a using awk /cut but to replace these in y.a i am not getting it … any help here ?  [Raj]$ cat x.a  CvfsDisk_sdb /dev/sdb # host 0 lun 1 sectors 4840746976 sector_size 512 inquiry [AMCC 9550SX-12M DISK 3.08] serial AMCC ZAJBSXJFF92A9D003C6A  CvfsDisk_sdc /dev/sdc # host 0 lun 0 sectors 3906148319 sector_size 512 inquiry [AMCC 9550SX-12M DISK 3.08] serial AMCC ZAJ8MJKFF92A9D001FEC  CvfsDisk_sdf /dev/sdf # host 0 lun 1 sectors 4840746976 sector_size 512 inquiry [AMCC 9550SX-12M DISK 3.08] serial AMCC ZAJBSXJFF92A9D003C6A  CvfsDisk_sdg /dev/sdg # host 0 lun 0 sectors 3906148319 sector_size 512 inquiry [AMCC 9550SX-12M DISK 3.08] serial AMCC ZAJ8MJKFF92A9D001FEC  [naren@Beas dxall]$ cat y.a [StripeGroup Metafiles]  Metadata Yes  Status UP  Read Enabled  Write Enabled  Journal Yes  StripeBreadth 1280K  Node CvfsDisk_sdb 0 [StripeGroup datafiles1]  Metadata Yes  Status UP  Read Enabled  Write Enabled  StripeBreadth 1024K  Node CvfsDisk_sdc 0 [StripeGroup datafiles2]  Metadata Yes  Status UP  Read Enabled  Write Enabled  StripeBreadth 1280K  Node CvfsDisk_sdd 0 [StripeGroup datafiles3]  Metadata Yes  Status UP  Read Enabled  Write Enabled  StripeBreadth 1024K  Node CvfsDisk_sde 0 @Narender, Your post is offtopic. I suggest you use our shell scripting   for question. To Philippe: You are right, # for i in $(ls) will break up files with spaces if IFS isn’t set to just the newline character.  I don’t believe this is consistent across distributions.  So the for loop should have # export IFS=$’\n’ before it.   I also use find in for loops when I want to look through the directory contents, but this isn’t always desired.  Thanks for the info about extglob, I haven’t done much with extended globbing in bash. To Sean:  Right, the more sharp a knife is, the easier it can cut your fingers… I mean: There are side-effects to the use of file globbing (like in [ for f in * ] ) , when the globbing expression matches nothing: the globbing expression is not susbtitued. Then you might want to consider using [ nullglob ] shell extension,  to prevent this.  see:  Devil hides in detail ;-) Response to the tip number 12  At thos script, It’s missing the followng line  FS=’:’  in the variables declaration  (you forgit the delimiter field, for the cut command)  :-P  The_Catalanish #! /usr/bin/ksh  for i in `cat /input`  do  bdf | grep file_system | grep -vE ‘^A|B|C’ | awk ‘{ print $4}’ | while read output;  do  file_system=$(echo $output | awk ‘{ print $1}’ | cut -d’%’ -f1  )  partition=$(echo $output | awk ‘{ print $2 }’ )  if [ $file_system -ge 60 ]; then  echo “don’t run the sync $partition ($file_system%) ”  else  rsync $i  fi  done  done  The problem with the logic I’m having is I do not want the script to exit(as it does now) the loop once the file_system area reaches 60%.   I want  it to continue to retest bdf and continue the loop once disk usage drops below 60%. Any Ideas? To Rilif: 1) I assume you use [ bdf ] on UNIX system – because Linux equivalent is [ df ] – and I cannot be of help because I cannot test your script on my Linux boxes. 2) This seems to be a specific programming debugging problem and out of this topic scope – There may be a better place to post that kind of topic – A programmer forum for instance. Best regards. do any one know how to write this script in steps?  as so /// ./ test 10 /// The first argument [1] will ex. to create a multiple users, groups, cn, dn, etc for ldap in one or two scripts but from command line. you would just enter file then the number of atrributes to build.  this is a headache for me since i’m new at this. To Dee: 0) The first part of your first sentence is incomprehensible – this may be because text that you entered is altered, it may contain HTML-like syntax that is interpreted by this comment form. (By the way, Vivek Gite would be welcomed to tell us how to prevent this. TIA  :-) ) 1) LDAP syntax is off-topic. 2) You’ll find appropriate resources in LDAP forums/sites – just find out. 3) We may be in position to help you to build a [for] loop, assuming you do your part of the job by providing the basic LDPA  instructions to create user, for instance. Try to create at least a LDAP  object by yourself on the command-line, then provide us the code, and as much as possible further explanation please. There was no html tag or anything else in comment. @dee, if you need to attach code use <pre> tags. Thanks Vivek – But I am afraid I do not get it right  – what does “pre” mean ?  (I understand you wrote the “less than” tag, and “greater than” tag – but why “pre” ? And are you sure these are the only ones two use ? @Philippe, All allowed html tags are displayed below the form itself. It is wordpress that converts those symbol and syntax is HTH first file make: create_user_idif.sh.txt ./create_user_ldif.sh.txt ./user.ldif $fname $lname $mail _____________________________________  ./mass_add.sh.txt  mass_user.txt  This ex: will pull from a list but same out come i do not know how to write another script to pull the attributes i need from the command line like ./test 100 and that command will pull only a 100 users id’s from idif.txt out of 1000 generated. This next samples of code will file in the attributes for you.  first file make: create_user_idif.sh.txt ____________________________________________________________  Then: mass_add.sh.txt _____________________________________________________________________  last:  adduserfile1.txt This is what i’m working on now ? i still do not know how to tie in C++ or bash script this code to work with command line, so i can control the out come of created users.  This script makes a 1000 users. However i can not control the out come. For example: from the command line I would like it to stop at 100 users by typing in ./test 100. Using agrv [1]. so  when I type a number after the file name it will create a list and print that record to the screen.  I do not know bash that well as C++ and it is not helping because the char.. are diff… Edited by admin. Reason:  To Dee:  1) Man, with a 3-users-sample instead of hundreds, we would have figured out, don’t you think so? 2) Well that’s a start. May be Vivek would like to wipe this post out, and create a new topic: “Of mice, LDAP and loops” ;-) ??? There is an interesting difference between the exit value for two different for looping structures (hope this comes out right):    You see that the first structure does a final increment of c, the second does not. The first is more useful IMO because if you have a conditional break in the for loop, then you can subsequently test the value of $c to see if the for loop was broken or not; with the second structure you can’t know whether the loop was broken on the last iteration or continued to completion. sorry, my previous post would have been clearer if I had shown the output of my code snippet, which is:   What if I would like to put everything into one line? Dmitry, please give a little more detail about what you are trying to achieve. You can see from my examples above that there is no problem to put a simple loop on one line. Basically you use semicolons (;) instead of line breaks. Dominic,  thaks a lot for  your quick answer. You have answered on my question but I’m still having problems. Please take a look at this.  dmitry@elastix-laptop:~/projects_cg/match_delays/source$ for i in $(seq 1 2 20)  > do  > echo “Welcome $i times”  > done  Welcome 1 times  Welcome 3 times  Welcome 5 times  Welcome 7 times  Welcome 9 times  Welcome 11 times  Welcome 13 times  Welcome 15 times  Welcome 17 times  Welcome 19 times  dmitry@elastix-laptop:~/projects_cg/match_delays/source$ for i in $(seq 1 2 20); do; echo “Welcome $i times” ; done  bash: syntax error near unexpected token `;’  dmitry@elastix-laptop:~/projects_cg/match_delays/source$  What am I missing here? @Dmitry  You are missing : Reading The Fantastic Manual.  :-)   There should not be any “;” following the [do].   Good ol’ one: “When any thing goes wrong – (re) Read the manual” @Dmitry And, again, as stated many times up there, using [seq] is counter productive, because it requires a call to an external program, when you should Keep It Short and Simple, using only bash internals functions: (and I wonder why Vivek is sticking to that old solution which should be presented only for historical reasons  when there was no way of using bash internals.  By the way, this historical recall should be placed only at topic end, and not on top of the topic, which makes newbies sticking to the not-up-to-date technique  ;-) ) Philippe, thank you, all works perfect know.  Here is the partial excuse that I was reading this thread instead of bash manual   It is strangethat a do/done loop works if there is CR (end of line) after the do, but not if there is a semi-colon. I can see why this was confusing for you Dmitry, because it’s not logical. My guess is that the acceptance of CR after do was added because people wanted to lay out code this way, but the bash coders forgot to allow the semicolon alternative. As Philippe points out, if you follow the manual strictly, it works fine. Ok. Thank you again! @Philippe, I’ve just updated the faq and also deleted large data sample posted by dee user. @ Dominic Yes, it’s not quite intuitive, right. What you mean is the semicolon or the newline as list separator (list as the grammar construct defined in the manual, respectively by ISO9945). After a `do’, a list is expected, but a list isn’t   with a list separator. After a `do’, the shell awaits more input, just like after an opening quote character. In interactive mode, it also displays the continuation prompt `PS2′ instead of `PS1′ (it would display `PS1′ for list continuation). It’s not right that the Bash coders “forgot” it. Inspecting the grammar rules of POSIX XCU Sec. 2.10.2 doesn’t show a special rule here (it would have to be a special exceptional rule that extra allows a semicolon here). Me again. From all Bourne-like shells I just “tested”, only ZSH seems to support a semicolon as a start of a list (also in the case after the `do’). This is nice, but that’s all. It’s not a bug to not do so. @ TheBonsai Interesting. I accept that it is not a bug, but I still think it is confusing. It seems logical to us lesser mortals that in bash semicolon=newline, and in other situations I think this is true, but not here.   #any number of blank lines or even comments echo $c; done  # so does this:  for (( c=1; c<=2; c++ )) do echo $c; done  # but this, where we substitute a semi-colon for the blank line(s) above, doesn't:  for (( c=1; c<=2; c++ )) do; echo $c; done @Dominic  You are missing the point. If you read our Unix pioneers, you will remember: – Rule of Optimization: Prototype before polishing. Get it working before you optimize it. [E. Raymond]  see  What’s the point of spending hours to code on one line?  – First, It does not give any optimization, it does not save any execution time. Your code will only be more difficult to read, check, debug. Defensive programming rules include this: Write one instruction per line. – Second, You still wanna code all on one line ?  Big deal. The manual gave you the right way.  So stick to it, or leave it, and skip to the next real problem, instead of wasting time and energy pointlessly, my dear Linux enthusiast. I have a comment to add about using the builtin   syntax.  I would agree the builtin method is cleaner, but from what I’ve noticed with other builtin functionality, I had to check the speed advantage for myself.  I wrote the following files: builtin_count.sh:   seq_count.sh:   And here were the results that I got:  time ./builtin_count.sh  real    0m22.122s  user    0m18.329s  sys     0m3.166s time ./seq_count.sh  real    0m19.590s  user    0m15.326s  sys     0m2.503s The performance increase isn’t too significant, especially when you are probably going to be doing something a little more interesting inside of the for loop, but it does show that builtin commands are not necessarily faster. The reason why the external seq is faster, is because it is executed only once, and returns a huge splurb of space separated integers which need no further processing, apart from the for loop advancing to the next one for the variable substitution. The internal loop is a nice and clean/readable construct, but it has a lot of overhead.  The check expression is re-evaluated on every iteration, and a variable on the interpreter’s heap gets incremented, possibly checked for overflow etc. etc. Note that the check expression cannot be simplified or internally optimised by the interpreter because the value may change inside the loop’s body (yes, there are cases where you’d want to do this, however rare and stupid they may seem), hence the variables are volatile and get re-evaluted. I.e. botom line, the internal one has more overhead, the “seq” version is equivalent to either having 1000000 integers inside the script (hard coded), or reading once from a text file with 1000000 integers with a cat.  Point being that it gets executed only once and becomes static. OK, blah blah fishpaste, past my bed time :-) Cheers,  Andi @Andi > OK, blah blah fishpaste, past my bed time :-) Interesting comments anyway! @Sean  1) Again, when your only programming concern that last will be the optimization of your loops, you could invest time into such timings.  This would be when there are no other bugs in your code, which I wish you to enjoy ASAP. 2) But then you may find that the real problem/bottleneck is not a for loop.  As Rob Pike said : “Measure. Do not tune for speed until your performance analysis tool tells you which part of the code overwhelms the rest.” [   ] 3) I agree with you when you say that your code is not relevant as a timing of real-sized programs. 4) Relating to your benchmark “builtin vs. external” commands  test the builtin [ for i in {1..1000000} ]  and you will see that it is very close to [for i in $(seq 1 1000000)] You are missing : Reading The Fantastic Manual. :-) A.. uh.. ?  The lack of examples in the bash man page is the main reason to *avoid* man page. Everyone, knowns how to use them. Syntax is all  good, only if  you know the bash and UNIX in and out. This is the main reason why most people purchase bash and shell scripting books from O’reilly or Amazon. Rest of freeloaders depends upon Google and site like this to get  information quickly. man pages are for gurus; for all new user examples are the best way to get started. @ 2012DD  I agree – I use any of resource I need, man page, –help page, info page, web pages, books.  The thing is: you should try to read man page once.  And actually, if he did, he would have find the syntax.  Vivek’s web site and contributions do not prevent you of reading the “fantastic” manual. And, as usual, the ones that issue the bitter critics will not move a finger to enhance the manual. You say man page lacks good examples?  Did you ever try to contribute to any man pages ?  Hope you did. The Bash manual page isn’t meant as tutorial. It’s a syntax, grammar and behaviour reference. However, it contains the knowledge to explain why a for loop using `seq’, one using brace expansion and one using builtin arithmetics have the performance relations they actually show when you execute them. The point is to make a relation between abstract descriptions and real execution behaviour. If such things really count, however, I suspect you code in the wrong language. @Bonsai  > The Bash manual page isn’t meant as tutorial. It’s a syntax, grammar and behaviour reference. Actually, no. A man page can/should contain a EXAMPLE section.  check :  I am pretty happy when the Example section is relevant. And when you want some more, nothing prevents you to try to add new examples… Let’s contribute! @Philippe How many examples would you place there, to show the “common usage of Bash”? I agree that manpages usually should contain examples, but I think this would be too much. Huge manpages (huge because they describe a huge set of functionality) contain very small/no examples. @Philippe, I am learning  Bash scripting and that is why I’m here and its wiki. Take a look at Solaris UNIX man page, most of them have good set of examples. Another candidate is FreeBSD, they also have good set of examples. Just discovered that our HP-UX came with printed “Posix Born Shell Scripting Manual”. >Did you ever try to contribute to any man pages ? No, I’m learning and if I *contribute* anything,  I’m dam sure most shell scripting gurus will eat me alive, as I’m not experienced coder.  Once I tried to help someone on comp.unix.shell and most of other people on list were so mean to my code that I almost stopped visiting comp.unix.shell. *Beep* those bastards! @2012 Doom Day Contribution is more than just knowing code. Alone the fact that you write here is a contribution (to the community). Translations, documentation, searching bugs, helping others, sharing expiriences, … Quite right, Bonsai,  and you can contribute to Wikibooks, Wikipedia, and Vivek’s Wiki using the books you own and all you have learnt, no one will ever prevent you of doing so, assuming you improve the content. Don’t be shy and be confident on your capacities.  See, I wrote loads of questionable comments and Vivek has not banned me [yet] ;-). Do you know why this doesn’t output anything? #!/bin/bash  for i in $(cat /$HOME/client_list.txt)  do  echo $i > /home/$i_file.log  done @Chris C If you want a good explanation, first try to ask a good question and explain:  1a) What you want to do with this program  1b) what your program is supposed to do. Second:  Mainly, it will fail because there will not be variable expansion  $i_file.log   should be ${i}_file.log  Read again about variable expansion. And:  2a) in your ” cat “, there should not be a leading slash before $HOME (because $HOME contains a leading slash) – anyway this wont prevent it from working  – but may come to bugs someday. 2c) if a line in client_list.txt does contains spaces, what do you think this would do? Use quotes. 2d) If it still fails, check your permissions to create and overwrite a file in “/home” directory 2e) As said many times, you do not need to use ” for + cat ” to use the content of a file. Just use a while loop :   Sir,  This is a new post. From a file in unix server with a column of temperature, I want to extract a number if it goes greater than 100. Normally it will be in 60 – 80 range. Can u suggest a bash script? Use our shell scripting forum  . The  {1..10} syntax is pretty usless as you can use a variable with it! You need to eval it to get it to work! ‘seq’ is not avilable on ALL system (MacOSX for example)  and BASH is not available on all systems either. You are better off either using the old  while-expr method for computer compatiblity! Alternativally use a  seq() function replacement… Edited: by Admin – added code tags. @Anthony.  Quite right – braces {start..end..step} might not be the best thing in bash. Nevertheless, I still stick to the old C-like synxtax in a for loop, which does accept variable arguments, such as: I don’t know much of this FOR loop syntax portability, functions you suggest may be the best thing to use for portability concern. (I have to read POSIX reference again :-) ) The Bash C-style for loop was taken from KSH93, thus I guess it’s at least portable towards Korn and Z. The seq-function above could use i=$((i + inc)), if only POSIX matters. expr is obsolete for those things, even in POSIX. Right Bonsai,  (   ) But FOR C-style does not seem to be POSIXLY-correct… Read on-line reference issue 6/2004,  Top is here,  and the Shell and Utilities volume (XCU) T.OC. is here    doc is:   and FOR command:   TheBonsai wrote…. “The seq-function above could use i=$((i + inc)), if only POSIX matters. expr is obsolete for those things, even in POSIX.” I am not certain it is in Posix.  It was NOT part of the original Bourne Shell, and on some machines, I deal with Bourne Shell.  Not Ksh, Bash, or anything else. Bourne Shell syntax works everywhere!  But as ‘expr’ is a builtin in more modern shells, then it is not a big loss or slow down. This is especially important if writing a replacement command, such as for “seq” where you want your “just-paste-it-in” function to work as widely as possible. I have been shell programming pretty well all the time since 1988, so I know what I am talking about!  Believe me. MacOSX has in this regard been the worse, and a very big backward step in UNIX compatibility.  2 year after it came out, its shell still did not even understand most of the normal ‘test’ functions.  A major pain to write shells scripts that need to also work on this system. Yea, the question was if it’s POSIX, not if it’s 100% portable (which is a difference). The POSIX base more or less is a subset of the Korn features (88, 93), pure Bourne is something “else”, I know. Real portability, which means a program can go wherever UNIX went, only in C ;) I’ve read the standard ;-) That {1 .. N} syntax doesn’t work with current Linux bash. $for r in {1 .. 15}; do echo $r; done  {1  ..  15} Yes, it does works, you need bash version 3.0 or up. Just tested with “GNU bash, version 4.1.5(1)-release (i486-pc-linux-gnu)”. You need to remove white space between 1 and 15, try: I gave some ‘seq’ alternatives, some simple, some more complex, mostly using shell built-ins only, depending on you needs. At the very start of the comments “jot” was mentioned as an alternative, though it does not appear to be as wide spread as “seq”.  Anyone know if it is on the ‘limited shell suport’ MacOSX? There are also however some other — off the wall — methods of generating a list of number, or just a list for looping ‘N’ times.  One of the weirdest ones I came across was using /dev/zero and “dd”!  dd 2>/dev/null if=/dev/zero bs=10 count=1 | tr \ \12 | cat -n | tr -d ‘\40\11′ This gets ’10’ null characters, converts them to line feeds, uses cat to convert them to numbers, and just to clean up, you can optionally delete the tabs and spaces. As I said real odd ball. Like I often say…  There are lots of ways to skin a cat, and what method you use depends  on what you want that skin for, and how messy you like the results! Yes,  but the code we see won’t work.  I think it needs some syntax enhancement in your first [ tr ], such as: Hell ! missed again – I hate that $%@ WordPress text entry Hi guys Ive been reading this thread cos i need some advice on a script. I need to rename some (lots) of files in a directory. they are named..  file_name.001.01  file_name.002.01  file_name.003.01… etc How can I change the names of the files to remove the ‘.01’ at the end of each filename? Im useing Ubuntu Lynx…. Ive been playing with a few examples from this thread, but cant seem to make it work. Any help is appreciated Try  : If you must use for: HTH In general, if you want to add a suffix to your files, do this (.txt in this example): ls  file1	file2	file3 for i in *; do mv $i $i.txt; done ls  file1.txt	file2.txt	file3.txt If you want to take it back off (.txt in this example again) for i in *.txt; do mv $i ${i%.*}; done ls  file1	file2	file3 Of course, if you want to worry about files with spaces in (and other things?), put quote around the arguments to mv, as in the gp. Note that is you want to append a string that does not start with a ‘.’ (for example the string “_info.txt”) then you need to delimit the variable name…. for i in *; do mv “$i” “${i}_info.txt”; done Hi,  I have  two files that contain diffrent columns. Both files have matching one column but raw oder is different. I want to combine these two files as below.  File 1:                                            file 2  x   2   7    123                               r   3   5   9  y  3   -8   124                               y   4   6   20  z  4   -2   34                                 q   3   5   70  q  5  -9    5                                   z   5  4   10  r  6    1    6                                   x    50 3  40 I want to combine each raws considering the common values in the first column  ex:  x 2 7 123 50 3 40  q 5 -9 5 3 5 70 I would be grateful if you could help me with this problem. Thank you.  Sapia @Sapia: As Vivek may say,  “Your post is off-topic. I suggest you use our shell scripting forum for question.”  Go  bash = GPL  GPL = GNU  GNU = Gnu is Not Unix UNIX logo in your web page = ??? Does it really matters? Bash runs on both certified UNIX and UNIX like (*BSD & various Linux distros) operating systems. HTH @Vivek Quite right – who cares ? Nobody. I just hope that those guys [borleand] would have better working and helping for FOSS community instead of posting those high-quality ( ;-P ) comments. Thanks for such a great web site, Vivek. Of bigger concern between  UNIX, GNU, GPL, Linux, Solaris, MacOSX, or whatever else, is what extra support programs are also available. I use to use ‘seq’ all the time in shell loops.  I don’t any more because ‘seq’ is not available on MacOSX.   In fact a lot of simple and what I would have though universal support programs are not available on MacOSX. how do i run 100 iteration using bash shell script.. i want to know how long will it take to execute one command(start and end time). I want to keep track which iteration is currently running. i want to log each iteration. I have one automated script i need to run and log it. for i in 1 2 3  do  command1  done But i want to know how long it takes to complete one iteration. and writes a log… help me please Hi naveen, 1) You should at least read thoroughly this topic. Iteration can be done with this syntax    Look above for explanation. 2) You could use [date] command and output it to a file  – as first command of the iteration (echoing something to mark start)  – as last command of the iteration (echoing something to mark end) 3) Log  What kind of log? To know what? What for? i want to write a output in text file(.txt)(log). I want to have a report saying that test ran for 100 iteration. My question i have one automated script that run 100 test file. i want to know how long it takes to complete the one iteration. And i want to keep a copy of the test result in .txt file. i know this is to log for one iteration…….  command > log.txt But when you are running iteration for 100. How wil you log it??. this is my question. Just one automated script (command) but there will be 100 test results for 100 iteration. How wil you log all this??? You really seem to be a beginner in shell – the best way to start would be to study Vivek’s Wiki first.  Go  To answer you iteration question:  1) First write the appropriate [for] loop that calls you commands and show us your code. All the information you need is located above in this page. If you cannot write this loop, you’d better learn [bash] on Vivek’s Wiki and come back when you can write a [for] loop with 100 iteration. Good luck! :) The problem with this is that csv files can contain quoted strings. which makes just comma separation usless..  For example  LoginN,ssn,ffn  “ab1,pp1″,”ab1″,”pp1”  “bb1,oo1″,”bb1″,”oo1”  “cc1,qq1″,”cc1″,”qq1” In that case use ” as delimiter. This can be done with sed or cut or any other shell built-in or utility: for loop can be used: You can skip for and use sed too. HTH It isn’t quite that simple.  But then any CSV that is more complex is getting a bit beyond   shell parsing. Nifty solution though, especially without access to a multi-character field separator. Here is another way to do it,  – in a generic way, that is without having to know number of internal fields,  – without IFS manipulation  – without external function (only builtin): Let’s say your CSV file contains 3 fields per record (per line):  “aaa bbb ccc”,”ddd eee fff”,”ggg hhh iii”,”jjj kkk lll”  “mmm nnn ooo”,”ppp qqq rrr”,”sss ttt uuu”,”vvv www xxx”  “yyy zzz 111″,”222 333 444″,”555 666 777″,”888 999 000” To break it in a one-liner, try:   The same code in a script is: And if you want to get rid of double-quotes, use: one-liner code:   script code, added of some text to better see record and field breakdown:   Does it work with your data? — PP Of course, all the above code was assuming that your CSV file is named “data”. If you want to use anyname with the script, replace:    With:   And then use your script file (named for instance “myScript”) with standard input redirection:   Enjoy! well no there is a bug, last field of each record is not read – it needs a workout and may be IFS modification ! After all that’s what it was built for… :O) Another bug is the inner loop is a pipeline, so you can’t assign variables for use later in the script. but you can use ‘<<<' to break the pipeline and avoid the echo. But this does not help when you have commas within the quotes!  Which is why you needed quotes in the first place. In any case It is a little off topic.  Perhaps a new thread for reading CVS files in shell should be created. Anthony,  Would you try this one-liner script on your CSV file? This one-liner assumes that CSV file named [data] has __every__ field double-quoted. Here is the same code, but for a script file, not a one-liner tweak. This script named here [cvs01.sh] must be used so:   @Anthony, By the way, using [REPLY] in the outer loop _and_ the inner loop is not a bug.  As long as you know what you do, this is not problem, you just have to store [REPLY] value conveniently, as this script shows. :-P Thanks for writing this article Vivek – it is very useful. In particular, I didn’t know about bash’s built-in ‘help’ command and was getting frustrated with the lack of detail in ‘man for’ Hi i need help in sorting some of the raw data actually on the unix machine. The raw data is some thing like this: So now it has to check for the time stamp T0145 is the timestamp in the below code : so finally the output should look like this for every occurance the T value: See sort command man page or our sort tutorial related FAQs:     Hi Vivek, Thanks for your reply, but this is just not only sorting but recording on of the value in the above code and then match this with other lines in the code .then display both together. @Sammeta, Just trying to help, and not to being rude or anything:  We are not willing to do your work,  anyone would help people who really try to help themselves first,  which you may have been trying already, I suppose. So, would you either submit a first version of your code,  or at least a main Algorithm you could think of? You may want to read first [awk] or [join] unix utilities man pages that you could find anywhere. –P what does FILES=”@” do? Please explain i am new to unix. See   and  One good reason to use seq instead of the {start..end..increment} idiom: #! /bin/bash  START=1  END=10  INCR=2 echo — use seq —  for x in $(seq $START $INCR $END)  do  echo $x  done  echo — bash idiom —  for x in {$START..$END..$INCR}  do  echo $x  done ———————–  — use seq —  1  3  5  7  9  — bash idiom —  {1..10..2} Wrong conclusion. This is not a reason for the seq idiom, it’s a reason to use arithmetically driven (C-like) for loops. @Bonsai: The example you gave is weird regarding shell variable usage: It works, but I thought it should not work!  Within the for (( )) instruction, you omitted “$” sign to allow variable expansion, but it works! That looks very strange to me. I wrote in an example previously (look above): xstart=1;xend=10;xstep=2  for (( x = $xstart; x <= $xend; x += $xstep)); do echo $x;done In your example, you wrote [for(( ))] without “$” : for ((x = START; x <= END; x += INCR)) I am astonished that for(()) works both with and without “$” for variable expansion! xstart=1;xend=10;xstep=2  for (( x = xstart; x <= xend; x += xstep)); do echo $x;done Does anyone know why? –PP I think it is ksh93 compatibility feature; so “START / END / INCR” will work with no “$”. See ksh93 man page. Sorry, I cannot find any evidence of such syntax on khs93 man page – and I use Bash shell.  On what URI + what chapter do you think there is an explanation of such behavior? It’s not KSH (or at least not KSH-unique). It’s how arithmetic environments (of any kind) in Bash work. Also it’s related to what POSIX specifies for the environment inside arithmetic expansion (the only a. environment POSIX knows):  If the shell variable x contains a value that forms a valid integer constant, then the arithmetic expansions “$((x))” and “$(($x))” shall return the same value. I think it was mentioned in TLDP.org’s advanced bash guide. Quite right Vivek. hi,  good tutorial.  thank you I might be going out on a limb due to a bad case of TL;DR, but I noticed the seq warning. Correct me if I’m wrong but using for instance for i in $(seq -w 1 1 20); do echo $i; done is in my oppinion quite an useful way of using seq in bash, at least when you want leading zeros before 1-9 and not from 10< Or is there a better way of doing this all "bashy"? ;) -víðir +1 for printf due to portability, but you can use bashy .. syntax too Well, it isn’t portable per se, it makes it portable to pre-4 Bash versions. I think a more or less “portable” (in terms of POSIX, at least) code would be Hi Can anybody help for this. I have two text file viz gem1.txt and gem2.txt EX. Content of gem1.txt activerecord (2.3.5, 2.2.2)  activerecord-oracle_enhanced-adapter (1.1.9)  activerecord-sqlserver-adapter (2.3.4)  activeresource (2.3.5, 2.2.2) Now i have to put all the data of these two .txt file on gem.csv. column wise. @ankit gulati This is not a place  :-P  for such questions, go and see Forum.  Anyway an answer is [paste] command. :-)   Simply use the “paste” command. Hi  can some one help in ceating a loop the problem is  i have 3 folder and name of the folder changes.  i want a loop which enter these folder one by one echo the files inside the folder Hi following this topic,  you may try to write something down first,  and then we may help you … if you help yourself first. Read and use this topic,  and the following material:  However, such request would be best posted into the forum  Anyway, a simple solution would be to use [ls] command with appropriate arguments. I didn’t see this in the article or any of the comments so I thought I’d share.  While this is a contrived example, I find that nesting two groups can help squeeze a two-liner (once for each range) into a one-liner: for num in {{1..10},{15..20}};do echo $num;done Great reference article! @Philip  Nice thing to think of, using brace nesting, thanks for sharing. Hi guys.  I was wondering whether it is possible to run a for loop through rsh (now before you start protesting that I use rsh instead of ssh; I know that it is extremely insecure. Thanks.) like this:?  rsh -l dev 192.168.x.x “for file in /PackSun/distills/*; do if [[ ${file} =~ “3\.6\.76″ ]]; echo $file; fi; done” Because when I type this it doesn’t work, $file is always the same file and it comes from the pwd on the local machine, not on the remote.  Thanks in advance.  D damn, sorry, didn’t close the code tag: rsh -l dev 192.168.x.x “for file in /PackSun/distills/*; do if [[ ${file} =~ “3\.6\.76” ]]; echo $file; fi; done” First — you should not use rsh.  It is an old and insecure network protocol.  ssh is its replacement. As for your question  YES it is posible,  Wrap it in a ‘shell’ command. rsh -l dev 192.168.x.x  ‘sh -c ‘\”for file in /PackSun/distills/*; do if [[ ${file} =~ “3\.6\.76″ ]]; echo $file; fi; done’\’ Watch the quoting as you want to use single quotes for both the outside and inside commands. If you use ” quotes you will need to escape the $ characters instead! And that may in turn lead to escapes of escapes (not pretty). I have actually done this to execute a very very large shell script on a remote server.  However I don’t recommend it for things beyond what you have.  If need be copy (update) a shell script on the remote server (scp, rsync, etc) then execute that.  It works better, you do not have constant quote handling problems, and not command line length limits. I do this for a   (written for my own use, using rsync hardlinks backup directories), that can backup to a remote account.   You are free to download and look at the copy/execute remote script that the main script performs for its sub-scripts (like backup cycle rolls). Anthony, You forgot to include URI for you script, your  > a < tag  is empty. PS: the reason for the ‘sh -c …’ is beause you may nto have control of the login shell of the remote account.  If you did not have it and the remote accoutn used tcsh or zsh, you will have problems. PPS; you are missing a then.  I tested it with this ssh version (a shell-builtin only ‘ls’ of the remote account).  ssh remote_machine  ‘sh -c ‘\”for file in *; do echo $file; done’\’ Hello I am using bash V4+ and this loop works fine: for i in {1..10}; do echo $i; done But when I put variables in the loop max=10; for i in {1..$max}; do echo $i; done I see one line as output: {1..10} Could anybody explain me what’s wrong ? Cheers. Sanya Hello Sanya, That would be because brace expansion does not support variables. I have to check this.  Anyway, Keep It Short and Simple: (KISS) here is a simple solution I already gave above: xstart=1;xend=10;xstep=1  for (( x = $xstart; x <= $xend; x += $xstep)); do echo $x;done Actually, POSIX compliance allows to forget $ in for quotes, as said before, you could also write: xstart=1;xend=10;xstep=1  for (( x = xstart; x <= xend; x += xstep)); do echo $x;done Sanya, Actually brace expansion happens __before__ $ parameter exapansion, so you cannot use it this way. Nevertheless, you could overcome this this way: max=10; for i in $(eval echo {1..$max}); do echo $i; done Hello, Philippe Thanks for your suggestions  You basically confirmed my findings, that bash constructions are not as simple as zsh ones.  But since I don’t care about POSIX compliance, and want to keep my scripts “readable” for less experienced people, I would prefer to stick to zsh where my simple for-loop works Cheers, Sanya Sanya, First, you got it wrong: solutions I gave are not related to POSIX, I just pointed out that POSIX allows not to use $ in for (( )), which is just a little bit more readable – sort of. Second, why do you see this less readable than your [zsh] [for loop]? for (( x = start; x <= end; x += step)) do  echo "Loop number ${x}"  done It is clear that it is a loop, loop increments and limits are clear. IMNSHO, if anyone cannot read this right, he should not be allowed to code. :-D BFN If you are going to do…  $(eval echo {1..$max});  You may as well use “seq” or one of the many other forms.  See all the other comments on doing for loops. I am trying to use the variable I set in the for line on to set another variable with a different extension.  Couldn’t get this to work and couldnt find it anywhere on the web…  Can someone help. Example: my goal is to take the values from the ALL Tokens file and set a new variable with A1_ infront of it…  This tells be that A1_ is not a command… could you please help me in write a bash script do the following:  1- read an input file contains IP Port  2- check the connectivity for every IP and its Port via telnet  3- if the telnet not connected send email to alert me. thanks in advance  atef fawzy No problem.  Would you first send me 1000USD payment?  Thanks in advance. ;-) dear Philippe Petrinko  thank you a lot for you value site  the below is my script and i don’t know what is the wrong?can you help me #!/bin/sh  for ip in $(cat iplist); do  # check for open ports # connTest=`echo ” ” | telnet $ip` if [ “`echo $ip | awk ‘{ print $3 }`  = “Connected” ]  then  echo “$ip is up” else #echo “$connTest port is down”  echo $ip is down fi  done Lucky You! Atef fawzy, Vivek has already written necessary  training material for you: Read  please tell me what is the wrong? #!/bin/sh  for ip in $(cat iplist); do  # check for open ports # connTest=`echo ” ” | telnet $ip` if [ “`echo $ip | awk ‘{ print $3 }`  = “Connected” ]  then echo “$ip is up” else echo $ip is down fi  done dear Philippe Petrinko  thank you a lot for your value site  the below is my script and i don’t know what is the wrong? can you hep me please #!/bin/sh  for ip in $(cat iplist); do  # check for open ports # connTest=`echo ” ” | telnet $ip` #if [ “`echo $connTest | awk ‘{ print $3 }` ” = “Connected” ]  if [ “`echo $ip | awk ‘{ print $3 }`  = “Connected” ]  then #echo “$connTest port is up”  echo “$ip is up” else #echo “$connTest port is down”  echo “$ip is down” fi  done Your request is off-topic.  Your [for] loop works fine, so this is not a point to be discussed here, Your [if] test is buggy – not to be discussed here but there  please send me the full URL to post the error i got You can go where I already offered you =>  You can go there and figure out what topic is appropriate to your needs. #!/bin/sh  How can I do this using infinite loops? thanks for you example, It`s help me very much. hey, Thanks a lot. Example are in the way they should be…some of the examples are very new to me. It has increased by knowledge.  keep posting these things and let us increase our knowledge. Hi, I have to read a file line by line  and do the iteration and apply the condition parameter for each input . Please share your ideas @Brian  You could google “awk” to proceed a file line by line, of use example in Vivek’s blog.   Hi, I’m a beginner and I was writing a very simple script : #!/bin/sh  clear  echo “Enter username:”  read username  if [ “$username” = “newbay” ]  then  echo “Username correct,”  else  echo “Incorrect username, try again:” fi echo “Now enter password:”  read password  if [ “$password” = “welcome” ]  then  echo “You are now logged in.”  else  echo “Sorry, incorrect password. Please try again.” fi  and I was wondering how to loop the incorrect username try again part ? Can anyone help me, if they understand my awful script .. Start a new thread! Haha ok thanks :) You could start learning shell scripting: About [for] loops:  ( from that excellent   ) Enjoy! Spot on. Included all examples that form a good base. Thanks for sharing. This post is 3 yrs old but still RockS.\m/ Very handful tutorial! : ) But i’ve got a problem on my Ubuntu linux box, a strange problem.. Executing the example code #!/bin/bash  for i in {1..5}  do  echo “Welcome $i times”  done i get as output Welcome {1..5} times. So the bash doesn’t understand the range {1..5}…Have any idea? My bash version is GNU bash, version 4.2.8(1)-release (x86_64-pc-linux-gnu). Thank u : ) This code has to be written into a text file, which must be made executable.  Did you do that? GNU/Bash v4.2.8 does supports {1..5} syntax. What is the output of the following commands? Great weblog right here! Additionally your web site quite a bit up very fast! What host are you the usage of? Can I get your associate hyperlink for your host? I want my website loaded up as fast as yours lol Hi all… I have a question about using for loops.  Basically, I have a file containing a list of protein ID numbers.  what I want to do is create a for loop that can go into this file, grab each protein ID number, and then search the NCBI database to get the fasta sequence of each protein… and then create another file containing all of the fasta sequences…. In general, my problem is that I can’t figure out how to get the protein ID numbers from the output file (ex. $1 in file1) into the for loop script. This is what I have so far: for gi in file1  do  fastacmd -d /data/nr -s gi  done but I need to specify that the gi (protein ID number) is the first column ($1) of file1. Does this make sense? Hi…  Thanks for the article, it is helpful really. I want to know one thing.  Let’s say there is file with content  1  2  3  4  5 how can I use for loop and print these numbers?  If you are understanding what I am trying to tell. I want to use the contents of these files and stored in the variable. Hello!  i am beginner and i have to make a bash script in which i have to show the number of lines that were added by the analized commits(in git).can you help me?Thanks. Dear andreea 1) I quote Vivek: “You are free to use our shell scripting forum for questions.”   2) You can learn for free shell scripting with the infamous Vivek’s collaborative Linux Shell Scripting Tutorial   Enjoy! — Philippe “infamous” was a private joke-understatement  Sorry, no offense intended!  Vivek website roxxxxs ! — Philippe Thanks for your quick answer.  I have another problem.i have to use this script by using git.can you explain me or give some advices how can i use it?thank you very much. I have this code that shows the first column  which represents the number of insertions of a commit and calculate the sum of all numbers of each line.  if [ $# -eq 2 ]; then  if [ $2 = “added_lines” ]; then  tmpfile=$(mktemp)  sum=0  git log –pretty=tformat: –numstat | tr -s “\n” | cut -f 1 > $tmpfile  for i in $(cat $tmpfile); do  sum=$(($sum + $i))  done  echo “$sum”  rm $tmpfile  But with ‘cut -f 1’ it takes too much time to calculate and to show the result.Can you help me saying how can i do this with ‘awk’ or ‘gawk’?  Please help me.Thanks Hi Vivek,  i am trying to run the below code as ram.sh in server as $ sh ./ram.sh code: ————————-  #!/bin/bash  for i in 1 2 4  do  echo “Welcome $i times”  done  ————————- It fails saying  ram.sh: line 3: syntax error near unexpected token `do  ram.sh: line 3: `do is that something i need to check which version is the sh and bash used in the server. how to check that.  it is a pretty simple code and it is not workign.  i am running this script in Linux server 64 bit server. What’s the easiest way to have a loop from N to N, when the numbers are dictated by variables? Something like what one could/would expect from “for i in {$a..$b}”, but something that actually works of course. What I do is: a=0 ; b=5 ; until ((a==b)) ; do echo $a ;  a=$(($a+1)) ; done But it seems kind of dumb, somewhat like echoing a huge set of spaces instead of “clear”, to clear the screen. But perhaps it’s the only way to do it. And it works anyway, so perhaps it’s good enough and worthy as an addition rather than a question. Funnily enough you can make an alphabetic countdown with “for i in {a..z}” Hi Ram, Since you are a real beginner, you would really take great benefit self-training on this course free of charge by vivek & contributors:   –P Hi,  I have this code in NetBeens:  #include  #include  using namespace std;  int main() {  int a,i,j;  cout << "inter your number of row " <>a;  for (i=0; i<=a; i++)  {  for(j=0; j<=i; j++)  {  cout << "*";  }  cout << '\n';  }  return 0;  } but I want to run it in ubuntu so at first I made a " nano file.sh" aftaer that I wrote this code in it:  #!/bin/sh  echo “Enter your number of rows”  Read a  for((i=0; i<=a; i++))  do  for((j=0; j<=i; j++))  do  echo “*”  done  echo –n  done  exit 0 after that " chmod +x file.sh", but my code didn't run, my code in ubuntu has problem,  I don't know how can I solve it, Thanks a lot if you answer my question,  Regards hi, am having problem to write a program using For statement. Please help if you know something about using For statement This is what I was looking for. TLDP advanced guide is also good one. Vivek,  It seems that WordPress was hungry, it has eaten your text ;-) [for] code sample is broken after sentence: “A representative three-expression example in bash as follows” –P nice write up. very useful i try the infinite variable, but it tells me that: Syntax error: Bad for loop variable :< Hello,  Nice post. Please help me in below code. we are getting syntax error. Please resolve the syntax issue. Error: Thanks  Ramana You are a ‘help troll’.. You posted in the wrong section.  you would have been better of starting a new topic. try with if [ $1 ] ; then  LIB=${1}/lib  if -d ${_LIB} ; then  for jar in $(cd ${_LIB}; ls *.jar)  do  EXISTS=$(echo ${CP} | grep “/${jar}”)  if [ “${_EXISTS}” != “” ]; then  logger “WARN: Classpath will contain multiple files named ${jar}”  else  CP=${CP}${CP_DELIM}${LIB}/${jar}  fi  done  fi  cd $1  fi hi if I use it with a imput variable like: echo “enter the numbers of repetitions :”  read variable tthe variable represent the number example 15 times to repeat !!!???/ how could it be ??? nice and clear thx a lot.  What I am dreaming of is this clear kind of webpage in which each box has a tab in which you can select any language…. I’m sure it exists already but where ??? and I mean it needs to be clear and simple !! Thank you so Much! hi i have a problem i want to write a shell script for siesta.  i want to make diffrent directories and want to change lattice constants n then run it with siesta n want to chck total energy  cn u tell m how cn i do this no w cnt  sry w dnt 1drstnd w U sd I want to write a shell script  for diffrent values of lattice constants .  If i do manually i first make a directorie i.e for 3.80 then i copy *.psf and fdf file there open the fdf file and change lattice constant to 3.80 and the execute file with siesta and note the total energy.  n again i repeat the same process for let say 3.90,4.10.4.20 etc.  now i want to write a code in shell so that i dnt need to make directory every time and change lattice constant.  I want to use looping for this purpose……..but how??  anybody have the little code for this?or anything? #!/bin/bash  # changing lattice constants  for 3.80 3.90 in $inp3.70.fdf  do  echo 3.80 3.90  mkdir  mv inp3.70.fdf inp*.fdf.old  mv *.psf *.psf.old  sed ‘s/inp*.fdf/&, lattice constant/’  inp*.fdf  done  # Now comes the commands to be executed  ~/code/sanabin/siesta  3.70.out &  ~  as i write this but not working…….. ../ Well, it seems that you do not understand the basics of shell scripting, even a simple [mkdir] command. Anyway, you are very lucky, because this web site and Internet offer you _free_ training material. The good news is : all you have to do is learn and work, using for instance these links.    and of course this page  nice you used “c++” in “A representative three-expression example in bash” but that is a programing language. @matthias : What’s your point? Is it a humorous play of words on “C++” language and increment of c variable in this script? In that case it would have been more convenient to append a smiling smiley, because otherwise, there is no coding issue in “A representative three-expression example in bash”. :-/ wondering… — Philippe Hi..  check it  why came this error in ubuntu please tell me  reply please  ./for3: 1: ./for3: Syntax error: Bad for loop variable Hi, It works for BASH only. Check you have given the right interpretor at the top of the script.  You can give it by placing #! /bin/bash at the top. –Vamsi Thanks. Solved my coding issue. Can anyone advise how to write a for loop statement to run commands from a .sh when an event comes up like users uploading new files to the server. My issue is that I am using a soft link to mirror an external disk drive in the .www/ and the soft link never updates when a new content is added to the drive within a session. Hi.  Nice overview of for loops.  I have a question, however:  Using the old “seq” command, one could perform zero padding via “seq -f “%05g” 1 100″.  How would this work with the {1..100} (or other) syntax? Hi Dai, simple: 1) for x in {0001..10} ; do echo “padding :$x:”; done 2)  Actually it works specifying padding on first argument (here 0001). No need to specify padding on second argument, but it will either work. for x in {0001..0010} ; do echo “padding :$x:”; done 3) but beware: you can specify different padding on both arguments, but only the _longuest_ will be used ! so this will use 6 digits padding, not 3 ! for x in {001..000010} ; do echo “padding :$x:”; done ok ? Vivek, would improve this topic on for loop adding this information on padding? It seems to be useful and at least informative and relevant to this topic. — Philippe Marvelous.  Cheers! You cannot completely abandon seq for the new bash syntax. Apparently, all variables in bash are integers. I tried using the new syntax with negative and float numbers with disastrous results. Seq, in turn, does it wonderfully. Ooops, forget it, someone else said the same thing. Didn’t see that, I’m not sure why… 1 line loop, for example curling:  for i in {1..500}; do curl “https://localhost:8040”; done; How do we do something like:  for file in /etc/* /bin/* Useful information! thank you! Can somebody explain me what  this loop “for i in circles[0,:]:” means? HI: I use seq when I need variables in the loop limits, because as far as I remember for y in {$x1..$x2}… is not allowed. Cheers Sasha   Hi i would like to know how to loop numbers using terminal but i tant seem to find how to so it would be gréât if one of you can help me sorry i ment i cant seem to find…. #!/bin/bash  for ((i=1;i<=100;i++));  do  echo $i  while excute the above program the below errors comes please check revert hi  i would like to know how i write a shell script to search a 100 user home directory by certain file  can you help me?  thx output is username und the file Hey I hope you can help me here. I’m stuck. down vote  favorite Trying to bind 20 x /24 subnets in Ubuntu 14 Server but I’m stuck here. These are diversified /24 subnets. I tried the below method via script called addips.sh for i in $(seq 3 254); do echo “auto em1:$i  iface em1:$i inet static  address xxx.xxx.16.$i  netmask 255.255.255.0  ” >> virthosts; done But, I noticed that this happened now: Each /24 subnet it outputted started off at #1 again instead of 255, 256, 257, etc all the way through consecutively for all 20 x /24 subnets auto em1:1  auto em1:254 Then again… auto em1:1  … How can I properly change this so it does reset at #1? em1 is the NIC Ethernet port (primary) and only port used too. I also want to make sure these are permanent, they stick after a server reboot. Hello There, I want to make one scipt which shall change multiple file name as per below example 1) if file name contains *abc* then file name should be change to *xyz*  2) if file name contains *def* then file name should be change to *iop*  3) if file name contains *(any file name except above name) then file name should be change to *qwe* Kindly help me to make the script as mentioned above requirement Thanks!! Very useful.Simple and easy. These are great examples, although I am hoping someone can help me with an easy one. Below is a simple script, but I would like for it to ask for another hash or give the option to break instead of just breaking. I would like to know how can i use for loop to pick up first few files from directory do something and then run with next batch.  Currently, I am able to for each file it takes one file at a time however i want to launch a command against 4 files at a time and then move on to next set in same directory. Arrays start at 0. Kill yourself     
The Bourne-Again SHell (Bash) was developed by the Free
Software Foundation (FSF) under the GNU Project, which
gives it a somewhat special reputation within the
Open Source community. Today, Bash is the default user shell on
most Linux installations. Although Bash is just one of
several well known UNIX shells, its wide distribution with
Linux makes it an important tool to know.
 
The main purpose of a UNIX shell is to allow users to
interact effectively with the system through the command
line. A common shell action is to invoke an executable,
which in turn causes the kernel to create a new running
process. Shells have mechanisms to send the output of one
program as input into another and facilities to interact
with the filesystem. For example, a user can traverse the
filesystem or direct the output of a program to a file.
 
Although Bash is primarily a command interpreter, it's
also a programming language. Bash supports variables,
functions and has control flow constructs, such as
conditional statements and loops. However, all of this comes
with some unusual quirks. This is because Bash
attempts to fulfill two roles at the same time: to be
a command interpreter and a programming language—and
there is tension between the two.
 
All UNIX shells, including Bash, are primarily command
interpreters. This trait has a deep history, stretching
all the way to the very first shell and the first UNIX
system. Over time, UNIX shells acquired the programming
capabilities by evolution, and this has led to some
unusual solutions for the programming environment. As
many people come to Bash already having some background
in traditional programming languages, the unusual
perspective that Bash takes with programming constructs
is a source of much confusion, as evidenced by many
questions posted on Bash forums.
 
In this article, I discuss how programming constructs
in Bash differ from traditional programming languages.
For a true understanding of Bash, it's useful to understand
how UNIX shells evolved, so I first review the relevant
history, and then introduce several Bash features.
The majority of this
article shows how the unusual aspects of Bash programming
originate from the need to blend the command
interpreter function seamlessly with the capabilities of a programming
language.
 
The term "shell" originated from the MULTICS project, a
collaboration between Massachusetts Institute of Technology
(MIT), General Electric and Bell Telephone Laboratories
(henceforth Bell Labs) to develop a next-generation
time-sharing operating system. Unhappy with the progress,
Bell Labs withdrew from the project in 1969, and the Bell
Labs team who worked on MULTICS went on to develop their
own operating system: UNIX.
 
The ancestor of Bash is the Thompson shell, the first
UNIX command interpreter, developed by Ken Thompson
in 1971. Figure 1 shows an excerpt from the  , 1st edition, that describes the Thompson shell.
 
 
 
Between 1973–1975, John R. Mashey extended the original
Thompson shell and added several programming capabilities,
making it a high-level programming language. In Mashey's
own words:
 
Modifications have been aimed at improving the use of the
shell...and making it even more convenient to use as
a high-level programming language. In line with the
philosophy of much existing UNIX software, an attempt has
been made to add new features only when they are shown
necessary by actual user experience in order to avoid
contaminating a compact, elegant system through "creeping
featurism". (From J. Mashey, "Using a Command Language as a
High-level Programming Language", CSE '76 Proceedings
of the 2nd International Conference on Software
engineering, 1976.)
 
Stephen Bourne started working on a new shell early
in 1976. The Bourne shell benefited from the concepts
introduced by the Mashey shell, and it brought some new
ideas of its own. The Bourne shell officially
was introduced in UNIX Version 7, released in 1979.
 
The original Thompson shell, the Mashey shell and
the Bourne shell were all called sh, and they overlapped
or replaced one another in the years 1970–1976 as
they were refined and gained additional capabilities.
Throughout 1970s, UNIX was mostly being developed
at Bell Labs and, in parallel, at the University of
California at Berkeley (the variant known as BSD).
With the development of UNIX, shells were constantly
developed and refined. At the time when the Bourne shell
already was in use, Bill Joy at Berkeley developed
the C shell (csh). The C shell was the first truly
alternative UNIX shell, and it was incorporated in the
2BSD release of Berkeley UNIX. In the early 1980s,
David Korn developed the Korn shell (ksh). Compared
to the Bourne shell, the C shell emphasized the
command interpreter mode, and the Korn shell came
with more extensive programming capabilities.
 
UNIX development efforts at Bell Labs and Berkeley
enriched each other, and the two versions were
later merged. In the 1980s, AT&T licensed UNIX to a number of
commercial vendors, and this resulted in the disruptive
wars for the UNIX market domination. In 1985, Richard
Stallman established the Free Software Foundation (FSF),
whose main initiative was to build a free-to-use
UNIX-like system, one that is not encumbered by the
intellectual property issues surrounding UNIX. This
is the famous GNU Project ("GNU's not UNIX"). In fact,
the original letter from Stallman, sent on the
net.unix-wizards mailing list in September 1983,
started with the cry: "Free Unix!"
 
Since it's impossible to have free UNIX without a shell,
that was a priority for the GNU Project. Brian Fox, the
Free Software Foundation's first paid programmer,
started working on a shell 1988. This became
Bash, first released as beta in 1989. Bash is
mostly a clone of the Bourne shell (hence
"Bourne-Again"), but it also includes additional
features inspired by the C shell and Korn shell. Brian Fox was the official maintainer of
Bash until 1992. At the time, Chet Ramey already
was involved with the work on Bash, and he became the official
maintainer in 1993. Chet Ramey continued to maintain
and develop Bash for the next 25 years, and he's still
Bash's current maintainer.
 
The original Thompson shell was a simple command interpreter
whose mode of operation was as follows:

 
where   is the name of the executable file (that is, a
command to be executed), and the optional arguments
  are passed to the command. The Thompson shell
had no programming capabilities. This changed with the
development of the Mashey shell (and later the Bourne shell).
In his seminal paper "The UNIX Shell", published in 1978,
Stephen Bourne wrote:
 
The UNIX shell is both a programming language and a command
language. As a programming language, it contains control-flow
primitives and string-valued variables. As a command language,
it provides a user interface to the process-related facilities
of the UNIX operating system. (S.R Bourne, "The UNIX Shell",  , Vol 56, No 6, July–August 1978.)
 
Note the emphasis on the different functionality: a programming
language and a command language. In fact, it was the Mashey
and Bourne shells that extended the capabilities of the
Thompson shell beyond the command interpreter. The shell's
original role was a command interpreter, and the programming
capabilities of shells were added later. UNIX shells evolved
some ingenious ways of consolidating the programming
capabilities with the original command interpreter role.
 
Today's Bash is more powerful compared to the original Mashey
shell and the Bourne shell. However, the purpose of the shell
remains exactly the same. Arguably, the most important
function of the shell is running commands (that is, submitting
an executable file to the kernel for execution). This has several
profound ramifications. For a start, Bash treats (almost)
anything that is given to it as a command. Consider the
following Bash session:

 
This shows that Bash splits the input into words,
then attempts to execute the first word as a command (the "words"
  and  ). Here, a "command" may be either a
Bash built-in command (such as  ), a utility (such as
 ) or some other executable file. When the string
  was given on input, Bash split it into three
"words":  ,   and  . It's important
to note that
Bash keeps all words as strings and has no concept of
numbers until forced to do an arithmetic evaluation. As
a rather simplified summary, Bash operates as follows:
 
This view ignores several intermediate steps. For example,
Bash scans the input line and performs all sorts of expansions
and replacements. It also checks for a built-in command
with the name given, and executes that, if it exists. Not to
lose sight of the big picture, I often ignore these details.
 
So, Bash's most essential purpose is
to execute commands, and this has some profound implications.
Notably, the programming constructs in Bash, which at
first sight may look like a programming language, are
derived from this mode of operation. And, that is the central
theme of this article.
 
The point that's often confusing to Bash newcomers is the
difference between Bash built-in commands and external
commands. On a typical Linux/UNIX system, a
number of common commands are both built-in in Bash
and   exist as independent executables with the
same name. Examples of this include   (built-in)
and  ,   (built-in) and
 ,
  (built-in) and   (and there are
more). Consider how the Bash built-in   and
  behave very similarly:

 
However, there are also subtle differences (try  ).
Why this duplication of commands? There are several reasons.
The built-in version typically exists for performance
reasons: Bash built-ins execute within the shell process that's
already running. In contrast, executing an external utility
involves loading and executing the external binary by the
kernel, which is a much slower process.
 
At this point, it's useful to note that some shell commands, by
their nature, cannot be external utilities (in other words, they
must be shell built-ins). Consider the   command that changes
the current working directory. An external utility wouldn't be
able to change the shell's current working directory, so
  must be a Bash built-in. Why? Because invoking a command
as an external utility would make the shell its parent process,
and a child process cannot change the current working directory
of the parent process.
 
You could turn this question around and ask, "if   is already
built in to the shell, why does the external utility  
exist?" That's because one doesn't always work through the shell
and may need to invoke   without the mediating shell process.
Second, in principle, there's nothing to enforce that a UNIX shell
must have   as a built-in, and therefore, it's important to
have the external utility   as a fallback.
 
A practical problem users often face is this: how do you know whether
the command you just called is the shell built-in or an external
utility with the same name? The Bash command   (which is
itself a shell built-in) indicates what command would be used
if executed. For example:

 
The basic rule is as follows: if the built-in command with a
given name exists, it will be executed. If the built-in command
doesn't exist, Bash will search for an external program, and
if found, will execute it. If you want to be sure to use the
executable, which happens to have the same name as a shell
built-in, calling the executable with the full path will do.
 
When a command is entered in Bash, Bash expects that the
first word it encounters is a command. However, there's
one exception: if the first word contains  , Bash will
attempt to execute a variable assignment. For example:

 
This has assigned the value 7 to the variable named  .
To retrieve the value of a variable, you need to prefix the
variable name with the dollar sign. Thus, to view the value
of a variable, you can combine the dollar-sign prefix with
 :

 
For a variable assignment, a contiguous string that contains
  is important. The following will fail:

 
In this case, Bash splits the input   into three "words"
( ,   and  ) and then attempts to execute the first
word as a command. This clearly isn't what was intended here.
 
Although Bash allows you to create arbitrary variables on the fly
simply by assigning the values to them, it also has a number
of built-in variables. An example of a built-in variable is
 . This contains the process ID of the Bash shell
itself:

 
Another built-in variable (and one that I cover
extensively here) is  . At any point in a Bash session,
this variable contains the return value of the last
executed command. The return value is always an integer.
(And specifically, this is the return value of the C
program function  . Note: in any C program the
function   must return an integer.) By the UNIX
convention, the return value of 0 denotes success, and
any other value denotes failure. For example, consider
the utility  :

 
As per the convention, the utility   returned 0 on
success, which you can see by inspecting the value of  .
If   is unable to execute (for example, unable to access
the file), it returns the value  :

 
In the last example, note that the first   was set to 2,
and the second   was set to 0. Why? Because the second
  contains the exit status of the   command (which
executed successfully). Remember, the
  variable contains the exit status of the last executed
command. You can use the commands   and   to
set the value of   to 0 or 1, respectively:

 
That might look rather silly at first, but keep reading.
 
Now let's consider how Bash provides an
impression of a seamlessly integrated command
environment, even when the tasks it executes are
inherently quite different. First, note that running
a Bash built-in command produces the same effect on
the   variable as running an external program:

 
This example shows that calling the built-in command
  changed   to 0 (to confirm this, first
run the   command, which sets   to 1). The
point is that it behaves the same as calling the
external program  :

 
Yet, these two scenarios are quite different. In the
first scenario, Bash invoked an internal command
 ; in the second example, Bash requested from
the kernel to run an external executable ( )
and suspended itself waiting for the executable to
complete. The effect on the   variable is exactly
the same.
 
Even for a variable assignment, Bash will set the
  variable accordingly:

 
From this, you can see that Bash treats a variable
assignment as a command. If the variable assignment
is not successful,   is set to a value >0. For
example, the built-in variable   is read-only,
and you can't change it (that is, Bash can't change
its own process ID). So this will fail:

 
Attempting to execute a non-existent command would
also set   to indicate a failure:

 
In this case, Bash filled the special variable   with
the number 127. This number is hard-wired in Bash, and
it specifically means "command not found".
 
To summarize, the above examples show three completely
different scenarios: invoking an internal Bash command,
running an external program and variable assignment. Yet,
Bash views all three as command execution and provides
a common behavior with respect to the   special variable.
Armed with these insights, now let's examine
three basic programming constructs in Bash: the  
statement, the   loop and the   loop.
 
The fundamental element of almost every programming language
is the conditional   statement. In the C language, it
looks like this:

 
Here   is a test that evaluates true or false
according to the rules of the C language. This is sometimes
called "truth value testing". Here's an example of this in Python:

 
In Bash, the same example looks like this:

 
You can reformat this by using ; to provide a handy one-liner
to type in:

 
This looks very much like the   conditional statement
in any programming language. However, it's not. In the
above example,   is a command. In fact,   is
a shell built-in:

 
Let that sink in:   is a command. In fact, that's the
same   command that was run above from the command line
to set the value of the   variable. What then is the
 
statement evaluating? It's evaluating the return value of
the   command. If you're not convinced, consider that
  can be replaced with the external utility
 :

 
Where:

 
If   is a command, you can put any command there,
right? Indeed:

 
Notice how the blank line was printed before the string
 . That's because the   statement actually
executed the command  , and without any
arguments, this prints a newline character. You
actually can give an argument to the   command:

 
The two   commands executed here are different: the
first is the external utility  ; the second,
an   that appears in the body of the   statement,
is the shell built-in. Clearly, the second   could
be replaced with the external utility too.
 
Moving on,
I mentioned previously that Bash will treat the
variable assignment as a command. Thus, variable assignment
can be used in the same place as the built-in command
or external executable:

 
To sum up, the general form of the   conditional statement
is:   where   and
  are commands.
The   statement controls flow by evaluating the exit code
of the command  : if   was successful (judging by
the exit status of 0), then   is executed. This is
rather different compared to truth value testing in most
traditional programming languages, and it's the source of much
confusion. I shall call this the  .
 
I just described how   is a command. So not surprisingly,
there is a  , the exact opposite of  .
For the Bash built-in:

 
And, there is an external utility with the same function:

 
The commands   and   do nothing, but exit with
the status 0 or 1, respectively. Since the   statement
evaluates the exit code when deciding whether to execute
the body,   always succeeds, and  
always fails. Note that the exit value of   is 0, and
the exit value of   is 1. This is somewhat
counterintuitive, and it's the exact opposite of most programming
languages. For example, in Python truth value testing, 0 is
equated with False (boolean), and 1 is equated with True
(boolean).
 
Let's confirm that the   statement in Bash is merely
testing the value of the program's exit value by writing a
simple C program, true.c, that returns 1 (note, the real
utility   returns 0, or success!):

 
This program doesn't do much; it merely returns 1 as the exit
status. According to the UNIX convention, the exit status
of 1 indicates a failure (no matter that the program may run
just fine!). Let's compile and execute this program, and
confirm that it returns an "unsuccessful" exit status to the
shell:

 
So, if you use this program in the   statement, the output
won't be what you may expect:

 
In other words, the   command has "failed". This example
confirms that all the   statement does is evaluate the exit
status. It doesn't matter that the program runs just fine,
exactly as intended; from the Bash perspective, a non-zero exit
status indicates failure. This I shall call the  
Consider the following task: test if the file exists, and if
it does, delete it. For this you can use the Bash built-in
  command with the   flag:

 
Therefore, to test if the file exists, and if yes, delete it:


 
The key to note here is that  
actually executes the command  . In this case,
  is a Bash built-in. As you might suspect, there is a
  utility that does the same thing and could be used to the
same effect:

 
Now, Bash implements   as a synonym for the built-in
  command:


 
Note,   is a command. And this, of course,
returns 0 on success and 1 on failure. Let's confirm:

 
With this understanding, you can repeat the above example with
the   construct:

 
The last construct looks even more like the   control
statement in most traditional programming languages.
However, it's not.   is a command—basically another
way to call the built-in   command.
 
The surprises don't quite end there. In Bash, the  
statement can take any number of commands separated
by a semicolon, after the keyword   and before the
body denoted with the keyword  . Something like
this:  . The   statement evaluates all commands
sequentially and executes the body of the loop only
if the exit status of the last command is 0 (a success
by convention). Consider the following example:

 
So in Bash, it's completely legal to write something
like this:

 
This executes three commands given after  , and it
never will execute the body ( ) because the last command
is  , which always fails (more precisely, returns a
non-zero status). In summary, in place of a single command,
you can use a list of commands. The overall exit status of
such a command list is given by the exit status of the last
command in the list. This I shall call the  .
 
Understanding the behavior of the   statement is rather
useful because the same behavior applies to   and
  loops. Consider the following example:

 
Let's understand exactly what happened here. First, the  
loop executed the   command and evaluated its exit status.
Since the exit status of   is always 0, it executed the
body of the loop ( ). Then it went
back for another cycle of the same. Because the   command
always runs with success, this created an infinite loop (which
was broken with Ctrl-C). Since   is a command, you can replace
it with any command. For example:

 
Thus, this   loop merely alternates the execution of the
two   commands:  , the external
executable, and
 , the Bash built-in.
 
As you might suspect, the   construct can accept a
command list, and in such a case, it would proceed to execute
the body of the loop based on the exit status of the last
command in the list. In other words, the general form of
the   loop is as follows:  . For example:

 
In this example, the body of the loop is not executed because
the last command is   (which always fails). The
 
loop works similarly:

 
In the case of the   loop, the body of the loop
executes as long as the command listed after the keyword
  is returning a non-zero exit status. Since the
command   returns a non-zero exit status every
time, the above example resulted in an infinite loop.
And of course, in the general form, the   loop can
accept command lists:  .
 
You may ask, if these loops merely execute two commands
(or two command lists), how is it useful in practice
at all? The commands that are tested
in the loop may depend on some dynamic condition (for
example, the number of bytes written to a file, or the
type of network traffic and so on). The change in
conditions may cause the command to fail or succeed.
Also you can modify the Bash variable in the body of
the loop, which leads to the use of loops similarly as
shown here:

 
Here   forces Bash arithmetic evaluation, and
  returns the resulting value; the construct
  is a synonym for   that performs arithmetic comparison. Note that
from the perspective of Bash, this is a command
that executes successfully or not:

 
This is why the   construct can be used after
the   keyword, which expects a command (or a
command list).
 
Bash is an independently implemented derivative of the
Bourne shell produced by the GNU Project, with enhancements
inspired by the C shell and the Korn shell. The original
UNIX shell (the Thompson shell) was a simple command
interpreter. Subsequently, the Mashey shell and the Bourne
shell blended in programming capabilities. Since Bash is
a direct descendant of the Bourne shell, it inherited
all the key ideas of how a programming environment works.
This includes how it blends the programming language
with the command interpreter. And for that purpose, UNIX
shells have evolved some ingenious solutions.
 
In Bash, the programming constructs look similar to
those found in traditional programming languages.
However, how those programming constructs inherently
work is quite different. This can be rather confusing
to people coming with some knowledge of the traditional
programming languages (which is usually the case for
Bash users). Here are the three main sources
of confusion with Bash programming:
 
My sincere thanks to Chet Ramey for his feedback on
the draft of this article. I would also like to thank
Isidora C. Likic for checking the text and examples.
 Too many articles and books on this topic exist to list in this space,
but if you're interested in learning more, we recommend these   articles (and there are actually too many   articles to list here
as well, but here are some to get you started):
 
 
Vladimir Likic holds a PhD in bioinformatics, and he has been using
UNIX since 1991 and Linux since 1995. Originally from Europe,
he lived in the US for a number of years and now calls Australia home.
Follow Vladimir on Twitter: @unix_byte.
   Sign up to get all the good stuff delivered to your inbox every week. 
Subscribe and support our coverage for technology's biggest thinkers – with up to 52% savings.
 Linux Journal, representing 25+ years of publication, is the original magazine of the global Open Source community.  Commands marked • are bash  
Many commands particularly the Core Utils
are also available under alternate   (C shell, Korn shell etc).  More bash commands:   from O'Reilly, GNU  . 
 
  |   |  Simply put, the shell is a program that takes
	commands from the keyboard and gives them to
	the operating system to perform. In the old days,
	it was the only user interface available on a Unix-like
	system such as Linux. Nowadays, we have   in addition to   such as the shell. On most Linux systems a program called   (which stands
	for Bourne Again SHell, an enhanced version of the
	original Unix shell program,  , written by Steve Bourne) acts as the
	shell program. Besides  , there are other shell programs
	that can be installed in a Linux system. These
	include:  ,   and  . It's a program called a  . This is a
	program that opens a window and lets you interact
	with the shell. There are a bunch of different
	terminal emulators you can use. Most Linux
	distributions supply several, such as:
	 ,
	 ,
	 ,
	 ,
	 ,
	 ,
	and  . Your window manager probably has a way to launch
	a terminal from the menu. Look through the list of
	programs to see if anything looks like a terminal
	emulator. If you are a KDE user, the terminal program is
	called "konsole," in Gnome it's called "gnome-terminal."
	You can
	start up as many of these as you want and play with
	them. While there are a number of different
	terminal emulators, they all do the same thing.
	They give you access to a shell session. You will
	probably develop a preference for one, based on the
	different bells and whistles each one provides. OK, let's try some typing. Bring up a terminal
	window. You should see a   that contains
	your user name and the name of the machine followed
	by a dollar sign. Something like this: Excellent! Now type some nonsense characters and
	press the enter key.   If all went well, you should have gotten an
	error message complaining that it cannot understand
	you:   Wonderful! Now press the up-arrow key. Watch how
	our previous command "kdkjflajfks" returns. Yes, we
	have  . Press the down-arrow
	and we get the blank line again. Recall the "kdkjflajfks" command using the
	up-arrow key if needed. Now, try the left and
	right-arrow keys. You can position the text cursor
	anywhere in the command line. This allows you to
	easily correct mistakes. If the last character of your shell
	prompt is # rather than $, you are
	operating as the  . This means that you
	have administrative privileges. This can be potentially
	dangerous, since you are able to delete or overwrite
	any file on the system. Unless you absolutely need
	administrative privileges, do not operate as the
	superuser. Even though the shell is a command line
	interface, the mouse is still handy. Besides using the mouse to scroll the contents
	of the terminal window, you can copy text with the mouse. Drag
	your mouse over some text (for example,
	"kdkjflajfks" right here on the browser window)
	while holding down the left button. The text should
	highlight. Release the left button and move your mouse
	pointer to the terminal window and press the middle 
	mouse button (alternately, you can press both the left
	and right buttons at the same time if you are working on a
	touch pad).
	The text you highlighted in the browser window
	should be copied into the command line. When you installed your Linux system and its
	window manager (most likely Gnome or KDE), it was
	configured to behave in some ways like that legacy
	operating system. In particular, it probably has its   set to "click to focus." This means that
	in order for a window to gain focus (become active)
	you have to click in the window. This is contrary
	to traditional X Window behavior. You should consider
	setting the focus policy to "focus follows mouse". 
	You may find it strange
	at first that windows don't raise to the front when
	they get focus (you have to click on the window
	to do that), but you will enjoy being able to work
	on more than one window at once without having the
	active window obscuring the the other. Try it and
	give it a fair trial; I think you will like it. You
	can find this setting in the configuration tools
	for your window manager.  |   |   |  
		© 2000-2020,
		 
		Verbatim copying and distribution of this entire article is
		permitted in any medium, provided this copyright notice is preserved. Linux® is a registered trademark of Linus Torvalds. This is a quick reference to getting started with Bash scripting. See  See:  See:  See:  See:  See:  Omitting the   removes the (non)nullity checks, e.g.   expands to   if unset otherwise  . See  . Note that   is actually a command/program that returns either   (true) or   (false). Any program that obeys the same logic (like all base utils, such as   or  ) can be used as condition, see examples. Declares   as a Dictionary object (aka associative array). Set   as a colon-separated list of patterns to be removed from glob
matches.  and   can be replaced with any valid expansion.  can be replaced with any valid expansion i.e.  ,  ,  , etc. or See  . This lesson will teach you how to enter commands using a command-line interface, rather than through a graphical interface. Command-line interfaces have advantages for computer users who need more precision in their work, such as digital historians. They allow for more detail when running some programs, as you can add modifiers to specify exactly how you want your program to run. Furthermore, they can be easily automated through scripts, which are essentially recipes of text-based commands. 
  Peer-reviewed
                    
                 Great Open Access tutorials cost money to produce. Join the growing number of people   so we can continue to share knowledge free of charge. Many of the lessons at the   require you to enter commands through a  . The usual way that computer users today interact with their system is through a  , or GUI. This means that when you go into a folder, you click on a picture of a file folder; when you run a program, you click on it; and when you browse the web, you use your mouse to interact with various elements on a webpage. Before the rise of GUIs in the late 1980s, however, the primary way to interact with a computer was through a command-line interface. GUI of Ian Milligan’s Computer Command-line interfaces have advantages for computer users who need more precision in their work – such as digital historians. They allow for more detail when running some programs, as you can add modifiers to specify   how you want your program to run. Furthermore, they can be easily automated through  , which are essentially recipes of text-based commands. There are two main command-line interfaces, or ‘shells,’ that many digital historians use. On OS X or many Linux installations, the shell is known as  , or the ‘Bourne-again shell.’  For users on Windows-based systems, the command-line interface is by default  , which uses different commands and  , but can often achieve similar tasks. This tutorial provides a basic introduction to the   terminal, and Windows users can follow along by installing popular shells such as   or Git Bash (see below). This lesson uses a  , which is a command-line interpreter that provides a user interface for the   operating system and for Unix-like systems. This lesson will cover a small number of basic commands. By the end of this tutorial you will be able to navigate through your file system and find files, open them, perform basic data manipulation tasks such as combining and copying files, as well as both reading them and making relatively simple edits. These commands constitute the building blocks upon which more complex commands can be constructed to fit your research data or project. Readers wanting a reference guide that goes beyond this lesson are recommended to read Deborah S. Ray and Eric J. Ray,  , 4th edition (2009). For those on OS X, and most Linux installations, you’re in luck — you already have a bash shell installed. For those of you on Windows, you’ll need to take one extra step and install Git Bash. This can be installed by downloading the most recent ‘Full installer’ at  . Instructions for installation are available at  . Let’s start up the shell. In Windows, run Git Bash from the directory that you installed it in. You will have to run it as an administrator - to do so, right click on the program and select ‘Run as Administrator.’ In OS X, by default the shell is located in: The Terminal.app program on OS X When you run it, you will see this window. A blank terminal screen on our OS X workstation You might want to change the default visual appearance of the terminal, as eyes can strain at repeatedly looking at black text on a white background. In the default OS X application, you can open the ‘Settings’ menu in ‘Preferences’ under Terminal. Click on the ‘Settings’ tab and change it to a new colour scheme. We personally prefer something with a bit less contrast between background and foreground, as you’ll be staring at this a great deal. ‘Novel’ is a soothing one as is the popular   suite of colour palettes. For Windows users, a similar effect can be achieved using the Git Bash   tab. To reach this, right-click anywhere in the top bar and select  . The Settings Screen on the OS X Terminal Shell Application Once you are happy with the interface, let’s get started. If, when opening a command window, you are unsure of where you are in a computer’s file system, the first step is to find out what directory you are in. Unlike in a graphical system, when in a shell you cannot be in multiple directories at once. When you open up your file explorer on your desktop, it’s revealing files that are within a directory. You can find out what directory you are in through the   command, which stands for “print working directory.” Try inputing: and hitting enter. If you’re on OS X or Linux, your computer will probably display   with your own user name in place of USERNAME. For example, Ian’s path on OS X is  . Here is where you realize that those on Windows and those on OS X/Linux will have slightly different experiences. On Windows, James is at: There are minor differences, but fear not; once you’re moving and manipulating files, these platform divergences can fade into the background. To orient ourselves, let’s get a listing of what files are in this directory. Type and you will see a list of every file and directory within your current location. Your directory may be cluttered or it may be pristine, but you will at a minimum see some familiar locations. On OS X, for example, you’ll see  ,  ,  ,  ,  ,  , etc. You may want more information than just a list of files. You can do this by specifying various   to go with our basic commands. These are additions to a command that provide the computer with a bit more guidance of what sort of output or manipulation you want. To get a list of these, OS X/Linux users can turn to the built-in help program. OS X/Linux users type The Manual page for the LS command Here, you see a listing of the name of the command, the way that you can format this command and what it does.   You can explore this page in a variety of ways: the spacebar moves down a page, or you can arrow down and arrow up throughout the document. To leave the manual page, press and you will be brought back to the command line where you were before entering the manual page. Try playing around with the   page for the other command you have learned so far,  . Windows users can use the   command, though this command has fewer features than   on OS X/Linux. Enter   to see the help available, and   for an example of the command’s output. Let’s try using a few of those options you saw in the   page for ls. Perhaps you only want to see TXT files that are in our home directory. Type which returns a list of text files, if you have any in your home directory (you may not, and that is OK as well). The * command is a   — it stands for ‘anything.’ So, in this case, you’re indicating that anything that fits the pattern: [anything.txt] will be displayed. Try out different combinations. If, for example, you had several files in the format  ,  , and so forth, the command   would display them all but exclude all other files (those that do not match the pattern). Say you want more information. In that long   page, you saw an option that might be useful: So, if you type the computer returns a long list of files that contains information similar to what you’d find in your finder or explorer: the size of the files in bites, the date it was created or last modified, and the file name. However, this can be a bit confusing: you see that a file test.html is ‘6020’ bits large. In commonplace language, you are more used to units of measurement like bytes, kilobytes, megabytes, and gigabytes. Luckily, there’s another flag: When you want to use two flags, you can just run them together. So, by typing you receive output in a human-readable format; you learn that that 6020 bits is also 5.9KB, that another file is 1 megabyte, and so forth. These options are   important. In other lessons within the  , you’ll see them.  ,  , and   all use the same syntax. Luckily, you do not need to memorize syntax; instead, keep these lessons handy so you can take a quick peek if you need to tweak something. These lessons can all be done in any order. You’ve now spent a great deal of time in your home directory. Let’s go somewhere else. You can do that through the   or Change Directory command. If you type you are now on your desktop. This is akin to you ‘double-clicking’ on the ‘desktop’ folder within a file explorer. To double check, type   and you should see something like: Try playing around with those earlier commands: explore your current directory using the   command. If you want to go back, you can type This moves us ‘up’ one directory, putting us back in  . If you ever get completely lost, the command will bring you right back to the home directory, right where you started. Try exploring: visit your documents directory, your pictures, folders you might have on your desktop. Get used to moving in and out of directories. Imagine that you are navigating a  . If you’re on the desktop, you won’t be able to   as it is a ‘child’ of your home directory, whereas your Desktop is a ‘sibling’ of the Documents folder. To get to a sibling, you have to go back to the common parent. To do this, you will have to back up to your home directory ( ) and then go forward again to  . Being able to navigate your file system using the bash shell is very important for many of the lessons at the  . As you become more comfortable, you’ll soon find yourself skipping directly to the directory that you want. In our case, from anywhere on our system, you could type or, on Windows, something like and be brought to our MALLET directory for  . Finally, try in OS X or in Windows. That command will open up your GUI at the current directory. Make sure to leave a space between   or   and the period. As well as navigating directories, you can interact with files on the command line: you can read them, open them, run them, and even edit them, often without ever having to leave the interface. There is some debate over why one would do this. The primary reason is the seamless experience of working on the command line: you never have to pick up your mouse or touch your track pad, and, although it has a steep learning curve it can eventually become a sole writing environment. Furthermore, many programs require you to use the command line to operate with them. Since you’ll be using programs on the command line, it can often be quicker to make small edits without switching into a separate program. For some of these arguments, see Jon Beltran de Heredia’s  . Here’s a few basic ways to do interact with files. First, you can create a new directory so you can engage with text files. We will create it on your desktop, for convenience’s sake. You can always move it later. Navigate to your desktop using your shell, and type: This creates a directory named, you guessed it, ‘ProgHist-Text.’ In general, it’s good to avoid putting spaces in your filenames and directories when using the command line (there are workarounds, of course, but this approach is simpler). You can look at your desktop to verify it has worked. Now, move into that directory (remember, that would be  ). But wait! There’s a trick to make things a bit quicker. Go up one directory (  - which will take you back to the Desktop). To navigate to the   directory you could type  . Alternatively, you could type   and then hit tab. You will notice that the interface completes the line to  .  Now you need to find a basic text file to help us with the example. Why don’t you use a book that you know is long, such as Leo Tolstoy’s epic  . The text file is availiable via  . If you have already installed  , you can just type If you do not have wget installed, download the text itself using your browser. Go to the link above, and, in your browser, use the ‘Save Page as..’ command in your ‘file menu.’ Save it in your new ‘ProgHist-Text directory.’ Now, when you type you see -rw-r–r–+ 1 ianmilligan1  staff   3.1M  1 May 10:03 pg2600.txt You can read the text within this file in a few different ways. First, you can tell our computer that you want to read it using the standard program that you use to open text files. By default, this may be TextEdit on OS X or Notepad in Windows. To open a file, just type on OS X, or in Windows. This selects the default program to open that type of file, and opens it. However, you often want to just work on the command line without leaving it. You can read files within this environment as well. To try this, type: The terminal window erupts and   cascades by. That’s great, in theory, but you can’t really make any sense of that amount of text? Instead, you may want to just look at the first or the last bit of the file. Provides a view of the first ten lines, whereas provides a perspective on the last ten lines. This is a good way to quickly determine the contents of the file. You could add a command to change the amount of lines displayed:  , for example, would show the first twenty lines. You may also want to change the file name to something more descriptive. You can ‘move’ it to a new name by typing Afterwards, when you perform a   command, you will see that it is now  . Had you wanted to duplicate it, you could also have run the copy command by typing you will revisit these commands shortly. Now that you have used several new commands, it’s time for another trick. Hit the up arrow on your keyboard. Notice that   appears before your cursor. You can continue pressing the up arrow to cycle through your previous commands. The down arrow cycles back toward your most recent command. After having read and renamed several files, you may wish to bring their text together into one file. To combine, or concatenate, two or more files, you can use the   command. First, let’s duplicate the Tolstoy file (  ). Now that you have two copies of  , let’s put them together to make an   book. To combine, or concatenate, two or more files use the   command. Type and press enter. This prints, or displays, the combined files within the shell. However, it is too long to read on this window! Luckily, by using the   command, you can send the output to a new file, rather than the terminal window. Type . Now, when you type   you’ll see   appear in your directory. When combining more than two files, using a wildcard can help avoid having to write out each filename individually. As you have seen above,  , is a place holder for zero or more characters or numbers. So, if you type and hit enter, a combination of all the .txt files in the current directory are combined in alphabetical order as  . This can be very useful if you need to combine a large number of smaller files within a directory so that you can work with them in a text analysis program. Another wildcard worth remembering is   which is a place holder for a single character or number. If you want to read a file in its entirety without leaving the command line, you can fire up  . Vim is a very powerful text editor, which is perfect for using with programs such as   to do word processing, or for editing your code without having to switch to another program. Best of all, it comes included with bash on both OS X and Windows. Vim has a fairly steep learning curve, so we will just touch on a few minor points. Type You should see vim come to life before you, a command-line based text editor. Vim If you really want to get into Vim, there is a   available. Using Vim to read files is relatively simple. You can use the arrow keys to navigate around and could theoretically read   through the command line (one should get an achievement for doing that). Some quick basic navigational commands are as follows:  (that is, holding down your ‘control key’ and pressing the letter F) will move you down a page (  for Windows).  will move you up a page. (  for Windows users). If you want to rapidly move to the end of a line, you can press:   and to move to the start of one,  . You can also move between sentences by typing   (forward) or   (backwards). For paragraphs, use   and  . Since you are doing everything with your keyboard, rather than having to hold your arrow key down to move around a document, this lets you zip quickly back and forth. Let’s scroll to the top and do a minor change, such as adding a   field in the heading. Move your cursor in between   and  , like so: About to Insert a Field If you just start typing, you’ll get an error message or the cursor will begin jumping around. This is because you have to specify that you want to do an edit. Press the letter At the bottom of the screen, you will see This means you are in insert mode. You can now type and edit text as if you are in a standard text editor. Press   twice, then  , and type When you are done, press   to return to reading mode. To leave vim or to make saves, you have to enter a series of commands. Press   and you’ll move to the command input line of Vim. you can enter a variety of commands here. If you want to save the file, type   to ‘write’ the file. If you execute that command, you will see “tolstoy.txt” [dos] 65009L, 3291681C written After Writing the File, with Our Minor Change If you want to quit, type   again and then  . It will return you to the command line. As with the rest of bash, you could have also combined the two commands. Pressing   and then typing   would have written the file and then quit. Or, if you wanted to exit   saving,   would have quit vim and overriden the default preference to save your changes. Vim is different than you are likely used to and will require more work and practice to become fluent with it. But if you are tweaking minor things in files, it is a good way to get started. As you become more comfortable, you might even find yourself writing term papers with it, by harnessing the  . Let’s say you are done with this directory, and you would like to move   somewhere else. First, you should create a backup copy. The shell is quite unforgiving with mistakes, and backing up is even more important than with GUIs. If you delete something here, there’s no recycling bin to fish it out of. To create a backup, you can type Now when you run a   command you will see five files, two of which are the same:   and  . Let’s move the first of these somewhere else. By way of example, let’s create a second directory on your desktop. Move up to your desktop ( ) and   another directory. Let’s call it  . To copy   you have a few different options. you could run these commands from anywhere in the shell, or you could visit either the origin or destination directories. For this example, let’s just run it from here. The basic format of the copy command is  . That is, you type   first, and then enter the file or files that you want to copy followed by where they should go. In this case, the command will copy Tolstoy from the first directory to the second directory. You will have to insert your own username in place of ‘ianmilligan1’. This means you now have three copies of the novel on our computer. The original, the backup and the new copy in the second directly. If you wanted to   the file, that is, not leave a copy behind, you could run the command again, swapping   for  ; let’s not do this yet. You can also copy multiple files with a single command. If you wanted to copy   the original and the backup file, you could use the wildcard command. This command copies   the text files from the origin directory into the destination directory. Note: If you are in the directory that you either want to move things to or from, you do not have to type out the whole directory structure. Let’s do two quick examples. Change your directory to the   directory. From this location, if you wanted to copy these two files to  , this command would work:  (on OS X, substitute the directory on Windows) Alternatively, if you were in the   directory, this command would work: The   command refers to the   directory you’re in.  Finally, if you want to delete a file, for whatever reason, the command is  , or remove.  , as you don’t want to delete files that you do not mean to. Unlike deleting from within your GUI, there is   recycling bin or undo options. For that reason, if you are in doubt, you may want to exercise caution or maintain a regular backup of your data. Move to   and delete the original file by typing Check that the file is gone using the   command. If you wanted to delete an entire directory, you have two options. you can use  , the opposite of  , to delete an   directory. To delete a directory with files, you could use from the desktop: You may want to take a break from the terminal at this point. To do so, enter   and you’ll close your session. There are more commands to try as you get more comfortable with the command line. Some of our other favourites are  , which is a way to find out how much memory is being used (  makes it human readable — as with other commands). For those of you on OS X,   provides an overview of what processes are running (  on Windows) and   can create a basic text file on both systems By this point, we hope you have a good, basic understanding of how to move around using the command line, move basic files, and make minor edits here and there. This beginner-level lesson is designed to give you some basic fluency and confidence. In the future, you may want to get involved with scripting. Have fun! Before you know it, you may find yourself liking the convenience and precision of the command line - for certain applications, at least - far more than the bulkier GUI that your system came with. Your toolkit just got bigger. For your convenience, here are the commands that you have learned in this lesson: Ian Milligan is an associate professor of history at the University
of Waterloo.
 
 James Baker is a Senior Lecturer in Digital History and Archives at the University of Sussex
and a historian of interactions between people and things.
  
 



Ian Milligan and James Baker,
        "Introduction to the Bash Command Line,"
          3 (2014),
        https://doi.org/10.46430/phen0037. Great Open Access tutorials cost money to produce. Join the growing number of people   so we can continue to share knowledge free of charge.  (ISSN: 2397-2068) is released under a   license. This project is administered by ProgHist Limited, Company Number  . 
 
 
 
 
 
 Short for "Bourne-Again Shell,"   is a    . Originally released in   as a free replacement for the  ,   is part of the  . Bash is the default shell in  ,  , and the majority of   operating systems.  is an  -compatible command language   that executes commands read from the   or from a file.   also incorporates useful features from the   and     (  and  ).  is intended to be a conformant implementation of the Shell and Utilities portion of the     specification (IEEE Standard 1003.1).   can be configured to be POSIX-conformant by default. All of the single-  shell options documented in the description of the   builtin command can be used as options when invoking  . The following options are also available:   If the   option is present, then commands are read from  . If there are   after the string, they are assigned to the positional  , starting with  . If the   option is present, the shell is interactive. For more information about interactive shells, see  , below. Make   act as if it had been invoked as a   shell. See the " " section below for more details. If the   option is present, the shell becomes restricted (see the " " section below for more details. If the   option is present, or if no arguments remain after option processing, then commands are read from the  . This option allows the positional parameters to be set when invoking an interactive shell. A list of all double-quoted strings preceded by   is printed on the standard output. These are the strings that are subject to language translation when the current locale is not C or POSIX. This implies the   option; no commands will be executed. [ ]  [ ]  is one of the shell options accepted by the   builtin (see the section " " for details). If   is present,   sets the value of that option;   unsets it. If   is not supplied, the names and values of the shell options accepted by shopt are printed on the standard output. If the invocation option is  , the output is displayed in a format that may be reused as input. A   signals the end of options and disables further option processing. Any arguments after the   are treated as filenames and arguments. An argument of   is equivalent to  .  also interprets a number of multi-character options. These options must appear on the command line before the single-character options to be recognized: Arrange for the debugger profile to be executed before the shell starts. Turns on extended debugging mode (see the description of the   option to the   builtin below). Equivalent to  , but the output is in the     (portable object) file format. equivalent to  . Display a usage message and exit.   ,  Execute commands from   instead of the system-wide initialization file   and the standard personal initialization file   if the shell is interactive (see the " " section below for details). Equivalent to  Do not use the GNU   library to read command lines when the shell is interactive. Do not read either the system-wide startup file   or any of the personal initialization files  ,  , or  . By default,   reads these files when it is invoked as a login shell (see the " " section below for details). Do not read and execute the system-wide initialization file   and the personal initialization file   if the shell is interactive. This option is on by default if the shell is invoked as  . Change the behavior of   where the default operation differs from the POSIX standard to match the standard. The shell becomes restricted (see the " " section below for details). Equivalent to  . Show version information for this instance of   and exit. If arguments remain after option processing, and neither the   nor the   option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If   is invoked in this fashion,   is set to the name of the file, and the positional parameters are set to the remaining arguments.   reads and executes commands from this file, then exits.  's exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and if no file is found, the shell searches the directories in   for the script. A login shell is one whose first character of argument zero is a  , or one started with the   option. An interactive shell is one started without non-option arguments and without the   option whose standard input and error are both connected to terminals (as determined by  ), or one started with the   option.   (  string) is set and   includes   if   is interactive, allowing a shell script or a startup file to test this state. The following paragraphs describe how   executes its startup files. If any of the files exist but cannot be read,   reports an error. Tildes are expanded in filenames as described below under " " in the " " section. When   is invoked as an interactive login shell, or as a non-interactive shell with the   option, it first reads and executes commands from the file  , if that file exists. After reading that file, it looks for  ,  , and  , in that order, and reads and executes commands from the first one that exists and is readable. The   option may be used when the shell is started to inhibit this behavior. When a login shell exits,   reads and executes commands from the file  , if it exists. When an interactive shell that is not a login shell is started,   reads and executes commands from   and  , if these files exist. This may be inhibited by using the   option. The   file option will force   to read and execute commands from file instead of   and  . When   is started non-interactively, to run a shell  , for example, it looks for the variable   in the environment, expands its value if it appears there, and uses the expanded value as the name of a file to read and execute.   behaves as if the following command were executed: but the value of the   variable is not used to search for the file name. If   is invoked with the name  , it tries to mimic the startup behavior of historical versions of   as closely as possible, while conforming to the   standard as well. When invoked as an interactive login shell, or a non-interactive shell with the   option, it first attempts to read and execute commands from   and  , in that order. The   option may be used to inhibit this behavior. When invoked as an interactive shell with the name  ,   looks for the variable  , expands its value if it is defined, and uses the expanded value as the name of a file to read and execute. Since a shell invoked as   does not attempt to read and execute commands from any other startup files, the   option has no effect. A non-interactive shell invoked with the name   does not attempt to read any other startup files. When invoked as  ,   enters posix mode after the startup files are read. When   is started in posix mode, as with the   command line option, it follows the POSIX standard for startup files. In this mode, interactive shells expand the   variable and commands are read and executed from the file whose name is the expanded value. No other startup files are read.  attempts to determine when it is being run with its standard input connected to a network connection, as when executed by the    , usually  , or the   daemon  . If   determines it is being run in this fashion, it reads and executes commands from   and  , if these files exist and are readable. It will not do this if invoked as  . The   option may be used to inhibit this behavior, and the   option may be used to force another file to be read, but   does not generally invoke the shell with those options or allow them to be specified. If the shell is started with the effective user (or group) id not equal to the real user (or group) id, and the   option is not supplied, no startup files are read, shell functions are not inherited from the environment, the  ,  ,  , and   variables, if they appear in the environment, are ignored, and the effective user id is set to the real user id. If the   option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset. In the following sections, these terms are defined as follows: a blank space or tab. a sequence of characters considered as a single unit by the shell. Also known as a  a   consisting only of   characters and underscores, and beginning with alphabetic character or an underscore. Also referred to as an  . a character that, when unquoted, separates words. A   metacharacter is one of the following:  ,  ,  ,  ,  ,  ,  ,  , or  . a   that performs a control function. It is one of the following symbols:  ,  ,  ,  ,  ,  ,  ,  ,  , or a newline.  are words that have special meaning to the shell. The following words are recognized as reserved when unquoted and either the first word or a simple command (see the " " section below), or the third word of a   or   command: Simple Commands A   is an optional sequence of variable assignments followed by blank-separated words and redirections, and terminated by a control operator. The first word specifies the command to be executed, and is passed as argument zero. The remaining words are passed as arguments to the invoked command. The return value of a simple command is its exit status, or   if the command is terminated by signal  . Pipelines A   is a sequence of one or more commands separated by one of the control operators   or  . The format for a pipeline is: The standard output of   is connected via a pipe to the standard input of  . This connection is performed before any redirections specified by the command (see the " " section below for details). If   is used, the standard error of   is connected to  's standard input through the pipe; it is shorthand for  . This implicit redirection of the standard error is performed after any redirections specified by the command. The return status of a pipeline is the exit status of the last command, unless the   option is enabled. If   is enabled, the pipeline's return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. If the reserved word   precedes a pipeline, the exit status of that pipeline is the logical negation of the exit status as described above. The shell waits for all commands in the pipeline to terminate before returning a value. If the   reserved word precedes a pipeline, the elapsed as well as user and system time consumed by its execution are reported when the pipeline terminates. The   option changes the output format to that specified by POSIX. When the shell is in posix mode, it does not recognize   as a reserved word if the next token begins with a ' '. The   variable may be set to a format string that specifies how the timing information should be displayed; see the description of   in the " " section below for details. When the shell is in posix mode,   may be followed by a newline. In this case, the shell displays the total user and system time consumed by the shell and its children. The   variable may be used to specify the format of the time information. Each command in a pipeline is executed as a separate process (a subshell). Lists A   is a sequence of one or more pipelines separated by one of the operators  ,  ,  , or  , and optionally terminated by one of  ,  , or  . Of these list operators,   and   have equal precedence, followed by   and  , which have equal precedence. A sequence of one or more newlines may appear in a list instead of a semicolon to delimit commands. If a command is terminated by the control operator  , the shell executes the command in the background in a subshell. The shell does not wait for the command to finish, and the return status is 0. Commands separated by a   are executed sequentially; the shell waits for each command to terminate in turn. The return status is the exit status of the last command executed.  and   lists are sequences of one of more pipelines separated by the   and   control operators, respectively.   and   lists are executed with left associativity. An   list has the form  is executed if, and only if,   returns an exit status of zero. An   list has the form  is executed if and only if   returns a non-zero exit status. The return status of   and   lists is the exit status of the last command executed in the list. Compound Commands A   is one of the following:  is executed in a subshell environment (see the " " section below for details). Variable assignments and builtin commands that affect the shell's environment do not remain in effect after the command completes. The return status is the exit status of list.    is executed in the current shell environment. The   must be terminated with a newline or semicolon. This is known as a  . The return status is the exit status of  . Note that unlike the metacharacters   and  ,   and   are reserved words and must occur where a reserved word is permitted to be recognized. Since they do not cause a word break, they must be separated from list by whitespace or another shell metacharacter. The   is evaluated according to the rules described below in the section " ". If the value of the expression is non-zero, the return status is 0; otherwise the return status is 1. This is exactly equivalent to  .     Return a status of 0 or 1 depending on the evaluation of the conditional expression  . Expressions are composed of the primaries described below under the section " ." Word splitting and   expansion are not performed on the words between the   and  ; tilde expansion, parameter and variable expansion, arithmetic expansion, command substitution, process substitution, and quote removal are performed. Conditional operators such as   must be unquoted to be recognized as primaries. When used with  , the   and   operators sort lexicographically using the current locale. See the description of the   builtin command (in the section " " below) for the handling of parameters (i.e. missing parameters). When the   and   operators are used, the string to the right of the operator is considered a pattern and matched according to the rules described below under Pattern Matching. If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. The return value is 0 if the string matches ( ) or does not match ( ) the pattern, and 1 otherwise. Any part of the pattern may be quoted to force it to be matched as a string. An additional binary operator,  , is available, with the same precedence as   and  . When it is used, the string to the right of the operator is considered an extended regular expression and matched accordingly (as in  ). The return value is 0 if the string matches the pattern, and 1 otherwise. If the regular expression is syntactically incorrect, the conditional expression's return value is 2. If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. Any part of the pattern may be quoted to force it to be matched as a string. Substrings matched by parenthesized subexpressions within the regular expression are saved in the array variable  . The element of BASH_REMATCH with index 0 is the portion of the string matching the entire regular expression. The element of BASH_REMATCH with index   is the portion of the string matching the  th parenthesized subexpression. Expressions may be combined using the following operators, listed in decreasing order of precedence: Returns the value of  . This may be used to override the normal precedence of operators. True if   is false. True if both   and   are true. True if either   or   is true. The   and   operators do not evaluate   if the value of   is sufficient to determine the return value of the entire conditional expression. The list of  s following   is expanded, generating a list of items. The variable   is set to each element of this list in turn, and   is executed each time. If the   word is omitted, the   command executes   once for each positional parameter that is set (see the " " section below). The return status is the exit status of the last command that executes. If the expansion of the items following   results in an empty list, no commands are executed, and the return status is  . First, the arithmetic expression   is evaluated according to the rules described below under " ". The arithmetic expression   is then evaluated repeatedly until it evaluates to zero. Each time   evaluates to a non-zero value,   is executed and the arithmetic expression   is evaluated. If any expression is omitted, it behaves as if it evaluates to 1. The return value is the exit status of the last command in   that is executed, or false if any of the expressions is invalid. The list of  s following   is expanded, generating a list of items. The set of expanded words is printed on the standard error, each preceded by a number. If the in word is omitted, the positional parameters are printed (see the " " section below). The   prompt is then displayed and a line read from the standard input. If the line consists of a number corresponding to one of the displayed words, then the value of   is set to that word. If the line is empty, the words and prompt are displayed again. If   is read, the command completes. Any other value read causes name to be set to  . The line read is saved in the variable  . The list is executed after each selection until a   command is executed. The exit status of   is the exit status of the last command executed in  , or zero if no commands were executed. A   command first expands  , and tries to match it against each   in turn, using the same matching rules as for pathname expansion (see the " " section, below). The   is expanded using tilde expansion, parameter and variable expansion, arithmetic substitution, command substitution, process substitution and quote removal. Each pattern examined is expanded using tilde expansion, parameter and variable expansion, arithmetic substitution, command substitution, and process substitution. If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. When a match is found, the corresponding   is executed. If the   operator is used, no subsequent matches are attempted after the first pattern match. Using   in place of   causes execution to continue with the   associated with the next set of  s. Using   in place of   causes the shell to test the next   in the statement, if any, and execute any associated   on a successful match. The exit status is zero if no   matches. Otherwise, it is the exit status of the last command executed in  . The     is executed. If its exit status is zero, the     is executed. Otherwise, each     is executed in turn, and if its exit status is zero, the corresponding     is executed and the command completes. Otherwise, the     is executed, if present. The exit status is the exit status of the last command executed, or zero if no condition tested true. The   command continuously executes the list   as long as the last command in the list   returns an exit status of zero. The   command is identical to the   command, except that the test is negated;   is executed as long as the last command in   returns a non-zero exit status. The exit status of the   and   commands is the exit status of the last command executed in  , or zero if none was executed. Coprocesses A "coprocess" is a shell command preceded by the   reserved word. A   is executed asynchronously in a subshell, as if the command had been terminated with the   control operator, with a two-way pipe established between the executing shell and the coprocess. The format for a coprocess is: This creates a coprocess named  . If   is not supplied, the default name is  . The   must not be supplied if   is a simple command (see  ); otherwise, it is interpreted as the first word of the simple command. When the   is executed, the shell creates an array variable (see the " " section below) named   in the context of the executing shell. The standard output of   is connected via a pipe to a file descriptor in the executing shell, and that file descriptor is assigned to  [0]. The standard input of   is connected via a pipe to a file descriptor in the executing shell, and that file descriptor is assigned to  [1]. This pipe is established before any redirections specified by the command (see the " " section below). The file descriptors can be utilized as arguments to shell commands and redirections using standard word expansions. The   of the shell spawned to execute the coprocess is available as the value of the variable  . The   builtin command may be used to wait for the coprocess to terminate. The return status of a coprocess is the exit status of command. Shell Function Definitions A   is an object that is called like a simple command and executes a   with a new set of positional parameters. Shell functions are declared as follows: This defines a function named  . The reserved word   is optional. If the   reserved word is supplied, the parentheses are optional. The body of the function is the compound command   (see " " section above). That command is usually a list of commands between   and  , but may be any command listed under Compound Commands above. The   is executed whenever   is specified as the name of a simple command. Any redirections (see " " section below) specified when a function is defined are performed when the function is executed. The exit status of a function definition is zero unless a syntax error occurs or a readonly function with the same name already exists. When executed, the exit status of a function is the exit status of the last command executed in the body. See " " section below. In a non-interactive shell, or an interactive shell in which the   option to the   builtin is enabled (see " " section below), a word beginning with   causes that word and all remaining characters on that line to be ignored. An interactive shell without the   option enabled does not allow comments. The   option is on by default in interactive shells.  is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. Each of the metacharacters listed above under the " " section has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used (see the " " section below), the history expansion character, usually  , must be quoted to prevent history expansion. There are three quoting mechanisms: the escape character, single quotes, and double quotes. A non-quoted backslash ( ) is the escape character. It preserves the literal value of the next character that follows, with the exception of  . If a   pair appears, and the backslash is not itself quoted, the   is treated as a line continuation (that is, it is removed from the input stream and effectively ignored). Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash. Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of  ,  ,  , and, when history expansion is enabled,  . The characters   and   retain their special meaning within double quotes. The backslash retains its special meaning only when followed by one of the following characters:  ,  ,  ,  , or  . A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an   appearing in double quotes is escaped using a backslash. The backslash preceding the   is not removed. The special parameters   and   have special meaning when in double quotes (see the section " " below). Words of the form   are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the   C standard. Backslash escape sequences, if present, are decoded as follows: alert (bell) backspace ,  an escape character form feed new line carriage return horizontal tab vertical tab backslash single quote double quote the eight-bit character whose value is the   value   (one to three digits) the eight-bit character whose value is the   value   (one or two hex digits) the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value   (one to four hex digits) the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value   (one to eight hex digits) a control-  character The expanded result is single-quoted, as if the dollar sign had not been present. A double-quoted string preceded by a dollar sign ( ) will cause the string to be translated according to the current locale. If the current locale is   or  , the dollar sign is ignored. If the string is translated and replaced, the replacement is double-quoted. A   is an entity that stores values. It can be a name, a number, or one of the special characters listed below under Special Parameters. A variable is a parameter denoted by a name. A variable has a value and zero or more attributes. Attributes are assigned using the   builtin command (see   below in the " " section). A parameter is set if it has been assigned a value. The null string is a valid value. Once a variable is set, it may be unset only by using the   builtin command (also documented in the " " section). A variable may be assigned by a statement of the form: If   is not given, the variable is assigned the null string. All values undergo tilde expansion, parameter and variable expansion, command substitution, arithmetic expansion, and quote removal (see the section " " below). If the variable has its integer attribute set, then value is evaluated as an arithmetic expression even if the   expansion is not used (see the section " " below). Word splitting is not performed, with the exception of " " as explained below under  . Pathname expansion is not performed. Assignment statements may also appear as arguments to the  ,  ,  ,  ,  , and   builtin commands. In the context where an assignment statement is assigning a value to a shell variable or array index, the   operator can be used to append to or add to the variable's previous value. When   is applied to a variable for which the integer attribute has been set,   is evaluated as an arithmetic expression and added to the variable's current value, which is also evaluated. When   is applied to an array variable using compound assignment (see " " below), the variable's value is not unset (as it is when using  ), and new values are appended to the array beginning at one greater than the array's maximum index (for indexed arrays) or added as additional key-value pairs in an associative array. When applied to a string-valued variable, value is expanded and appended to the variable's value. Positional parameters A   is a parameter denoted by one or more digits, other than the single digit 0. Positional parameters are assigned from the shell's arguments when it is invoked, and may be reassigned using the   builtin command. Positional parameters may not be assigned to with assignment statements. The positional parameters are temporarily replaced when a shell function is executed (see the section " " below). When a positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces (see the section " " below). Special parameters The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed. Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, it expands to a single word with the value of each parameter separated by the first character of the IFS special variable. That is, " " is equivalent to " ", where   is the first character of the value of the   variable. If IFS is unset, the parameters are separated by spaces. If IFS is null, the parameters are joined without intervening separators. The   Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, each parameter expands to a separate word. That is, " " is equivalent to " " " " ... If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the original word, and the expansion of the last parameter is joined with the last part of the original word. When there are no positional parameters, " " and   expand to nothing (i.e., they are removed). Expands to the number of positional parameters in decimal. Expands to the exit status of the most recently executed foreground pipeline. Expands to the current option flags as specified upon invocation, by the   builtin command, or those set by the shell itself (such as the   option). The   Expands to the process ID of the shell. In a   subshell, it expands to the process ID of the current shell, not the subshell. Expands to the process ID of the most recently executed background (asynchronous) command. Expands to the name of the shell or shell script. This is set at shell initialization. If   is invoked with a file of commands,   is set to the name of that file. If bash is started with the   option, then   is set to the first argument after the string to be executed, if one is present. Otherwise, it is set to the file name used to invoke bash, as given by argument zero. At shell startup, set to the absolute pathname used to invoke the shell or shell script being executed as passed in the environment or argument list. Subsequently, expands to the last argument to the previous command, after expansion. Also set to the full pathname used to invoke each command executed and placed in the environment exported to that command. When checking mail, this parameter holds the name of the mail file currently being checked. Shell variables The following variables are set by the shell: Expands to the full file name used to invoke this instance of bash. A colon-separated list of enabled shell options. Each word in the list is a valid argument for the   option to the   builtin command (see the section " " below). The options appearing in   are those reported as on by  . If this variable is in the environment when bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is read-only. Expands to the process ID of the current bash process. This differs from   under certain circumstances, such as subshells that do not require bash to be re-initialized. An associative array variable whose members correspond to the internal list of aliases as maintained by the alias builtin. Elements added to this array appear in the alias list;  ting array elements cause aliases to be removed from the alias list. An array variable whose values are the number of parameters in each frame of the current bash execution call stack. The number of parameters to the current subroutine (shell function or script executed with . or source) is at the top of the stack. When a subroutine is executed, the number of parameters passed is pushed onto  . The shell sets   only when in extended debugging mode (see the description of the   option to the   builtin below) An array variable containing all of the parameters in the current bash execution call stack. The final parameter of the last subroutine call is at the top of the stack; the first parameter of the initial call is at the bottom. When a subroutine is executed, the parameters supplied are pushed onto  . The shell sets   only when in extended debugging mode (see the description of the   option to the   builtin below) An associative array variable whose members correspond to the internal hash table of commands as maintained by the   builtin. Elements added to this array appear in the hash table;  ting array elements cause commands to be removed from the hash table. The command currently being executed or about to be executed, unless the shell is executing a command as the result of a trap, in which case it is the command executing at the time of the trap. The command argument to the   invocation option. An array variable whose members are the line numbers in source files where each corresponding member of   was invoked. The   is the line number in the source file ( ) where   was called (or   if referenced within another shell function). Use   to obtain the current line number. An array variable whose members are assigned by the   binary operator to the   conditional command. The element with index 0 is the portion of the string matching the entire regular expression. The element with index   is the portion of the string matching the nth parenthesized subexpression. This variable is read-only. An array variable whose members are the source filenames where the corresponding shell function names in the   array variable are defined. The shell function   is defined in the file   and called from  Incremented by one each time a subshell or subshell environment is spawned. The initial value is 0. A readonly array variable whose members hold version information for this instance of bash. The values assigned to the array members are as follows: : The major version number (the release). : The minor version number (the version). : The patch level. : The build version. : The release status (e.g., beta1). : The value of MACHTYPE. Expands to a string describing the version of this instance of bash. An index into   of the word containing the current cursor position. This variable is available only in shell functions invoked by the programmable completion facilities (see " " below). The key (or final key of a key sequence) used to invoke the current completion function. The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see "  below). The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to  . This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see the section " " below). Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called:  , for normal completion,  , for listing completions after successive tabs,  , for listing alternatives on partial word completion,  , to list completions if the word is not unmodified, or  , for menu completion. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see the section " " below). The set of characters that the readline library treats as word separators when performing word completion. If   is unset, it loses its special properties, even if it is subsequently reset. An array variable (see " " below) consisting of the individual words in the current command line. The line is split into words as   would split it, using   as described above. This variable is available only in shell functions invoked by the programmable completion facilities (see the section " " below). An array variable (see " " below) created to hold the file descriptors for output from and input to an unnamed coprocess (see the section " " above). An array variable (see the section " " below) containing the current contents of the directory stack. Directories appear in the stack in the order they are displayed by the   builtin. Assigning to members of this array variable may be used to modify directories already in the stack, but the   and   builtins must be used to add and remove directories. Assignment to this variable will not change the current directory. If   is unset, it loses its special properties, even if it is subsequently reset. Expands to the effective user ID of the current user, initialized at shell startup. This variable is readonly. An array variable containing the names of all shell functions currently in the execution call stack. The element with index 0 is the name of any currently-executing shell function. The bottom-most element (the one with the highest index) is "main". This variable exists only when a shell function is executing. Assignments to   have no effect and return an error status. If   is unset, it loses its special properties, even if it is subsequently reset. This variable can be used with   and  . Each element of   has corresponding elements in   and   to describe the call stack. For instance,   was called from the file   at line number  . The   builtin displays the current call stack using this information. An array variable containing the list of groups of which the current user is a member. Assignments to   have no effect and return an error status. If   is unset, it loses its special properties, even if it is subsequently reset. The history number, or index in the history list, of the current command. If   is unset, it loses its special properties, even if it is subsequently reset. Automatically set to the name of the current host. Automatically set to a string that uniquely describes the type of machine on which bash is executing. The default is system-dependent. Each time this parameter is referenced, the shell substitutes a decimal number representing the current sequential line number (starting with 1) within a script or function. When not in a script or function, the value substituted is not guaranteed to be meaningful. If   is unset, it loses its special properties, even if it is subsequently reset. Automatically set to a string that fully describes the system type on which bash is executing, in the standard GNU cpu-company-system format. The default is system- dependent. An array variable (see the " " section below) created to hold the text read by the   builtin when no variable name is supplied. The previous working directory as set by the   command. The value of the last option argument processed by the   builtin command (see the section " " below). The index of the next argument to be processed by the   builtin command (see the section " " below). Automatically set to a string that describes the operating system on which bash is executing. The default is system-dependent. An array variable (see the section " " below) containing a list of exit status values from the processes in the most-recently-executed foreground pipeline (which may contain only a single command). The process ID of the shell's parent. This variable is readonly. The current working directory as set by the   command. Each time this parameter is referenced, a random integer between 0 and 32767 is generated. The sequence of random numbers may be initialized by assigning a value to  . If   is unset, it loses its special properties, even if it is subsequently reset. The contents of the   line buffer, for use with " " (see the section " " below). The position of the insertion point in the   line buffer, for use with " " (see the section " " below). Set to the line of input read by the read builtin command when no arguments are supplied. Each time this parameter is referenced, the number of seconds since shell invocation is returned. If a value is assigned to  , the value returned upon subsequent references is the number of seconds since the assignment plus the value assigned. If   is unset, it loses its special properties, even if it is subsequently reset. A colon-separated list of enabled shell options. Each word in the list is a valid argument for the   option to the   builtin command (see the section " " below). The options appearing in   are those reported as on by set  . If this variable is in the environment when bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is read-only. Incremented by one each time an instance of bash is started. Expands to the user ID of the current user, initialized at shell startup. This variable is readonly. The following variables are used by the shell. In some cases, bash assigns a default value to a variable; these cases are noted below. If this parameter is set when bash is executing a shell script, its value is interpreted as a filename containing commands to initialize the shell, as in  . The value of   is subjected to parameter expansion, command substitution, and arithmetic expansion before being interpreted as a file name.   is not used to search for the resultant file name. If set to an integer corresponding to a valid file descriptor, bash will write the trace output generated when set   is enabled to that file descriptor. The file descriptor is closed when   is unset or assigned a new value.  ting   or assigning it the empty string causes the trace output to be sent to the standard error. Note that setting   to 2 (the standard error file descriptor) and then  ting it will result in the standard error being closed. The search path for the   command. This is a colon-separated list of directories in which the shell looks for destination directories specified by the   command. A sample value is " ". Used by the select compound command to determine the terminal width when printing selection lists. Automatically set upon receipt of a  . An array variable from which bash reads the possible completions generated by a shell function invoked by the programmable completion facility (see " " below). If bash finds this variable in the environment when the shell starts with value " ", it assumes that the shell is running in an Emacs shell buffer and disables line editing. Similar to  ; used when the shell is invoked in POSIX mode. The default editor for the   builtin command. A colon-separated list of suffixes to ignore when performing filename completion (see the section " " below). A filename whose suffix matches one of the entries in   is excluded from the list of matched filenames. A sample value is " " (Quoting is needed when assigning a value to this variable, which contains tildes). If set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed this nesting level will cause the current command to abort. A colon-separated list of patterns defining the set of filenames to be ignored by pathname expansion. If a filename matched by a pathname expansion pattern also matches one of the patterns in  , it is removed from the list of matches. A colon-separated list of values controlling how commands are saved on the history list. If the list of values includes  , lines which begin with a space character are not saved in the history list. A value of   causes lines matching the previous history entry to not be saved. A value of   is shorthand for   and  . A value of   causes all previous lines matching the current line to be removed from the history list before that line is saved. Any value not in the above list is ignored. If   is unset, or does not include a valid value, all lines read by the shell parser are saved on the history list, subject to the value of  . The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of  . The name of the file in which command history is saved (see the section " " below). The default value is  . If unset, the command history is not saved when an interactive shell exits. The maximum number of lines contained in the history file. When this variable is assigned a value, the history file is truncated, if necessary, by removing the oldest entries, to contain no more than that number of lines. The default value is 500. The history file is also truncated to this size after writing it when an interactive shell exits. A colon-separated list of patterns used to decide which command lines should be saved on the history list. Each pattern is anchored at the beginning of the line and must match the complete line (no implicit ' ' is appended). Each pattern is tested against the line after the checks specified by   are applied. In addition to the normal shell pattern matching characters, ' ' matches the previous history line. ' ' may be escaped using a backslash; the backslash is removed before attempting a match. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of  . The number of commands to remember in the command history (see the section " " below). The default value is 500. If this variable is set and not null, its value is used as a format string for   to print the time stamp associated with each history entry displayed by the   builtin. If this variable is set, time stamps are written to the history file so they may be preserved across shell sessions. This uses the history comment character to distinguish timestamps from other history lines. The home directory of the current user; the default argument for the   builtin command. The value of this variable is also used when performing tilde expansion. Contains the name of a file in the same format as   that should be read when the shell needs to complete a  . The list of possible hostname completions may be changed while the shell is running; the next time hostname completion is attempted after the value is changed, bash adds the contents of the new file to the existing list. If   is set, but has no value, or does not name a readable file, bash attempts to read   to obtain the list of possible hostname completions. When   is unset, the   list is cleared. The Internal Field Separator that is used for word splitting after expansion and to split lines into words with the   builtin command. The default value is " ". Controls the action of an interactive shell on receipt of an EOF character as the sole input. If set, the value is the number of consecutive EOF characters which must be typed as the first characters on an input line before bash exits. If the variable exists but does not have a numeric value, or has no value, the default value is 10. If it does not exist, EOF signifies the end of input to the shell. The filename for the   startup file, overriding the default of   (see the section " " below). Used to determine the locale category for any category not specifically selected with a variable starting with  . This variable overrides the value of   and any other   variable specifying a locale category. This variable determines the collation order used when sorting the results of pathname expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within pathname expansion and pattern matching. This variable determines the interpretation of characters and the behavior of character classes within pathname expansion and pattern matching. This variable determines the locale used to translate double-quoted strings preceded by a  . This variable determines the locale category used for number formatting. Used by the select compound command to determine the column length for printing selection lists. Automatically set upon receipt of a  . If this parameter is set to a file or directory name and the   variable is not set, bash informs the user of the arrival of mail in the specified file or Maildir-format directory. Specifies how often (in seconds) bash checks for mail. The default is 60 seconds. When it is time to check for mail, the shell does so before displaying the primary prompt. If this variable is unset, or set to a value that is not a number greater than or equal to zero, the shell disables mail checking. A colon-separated list of file names to be checked for mail. The message to be printed when mail arrives in a particular file may be specified by separating the file name from the message with a ' '. When used in the text of the message,   expands to the name of the current  . Example:  Bash supplies a default value for this variable, but the location of the user mail files that it uses is system dependent (e.g.,  ). If set to the value 1, bash displays error messages generated by the   builtin command (see the section " " below).   is initialized to 1 each time the shell is invoked or a shell script is executed.   The search path for commands. It is a colon-separated list of directories in which the shell looks for commands (see the section " " below). A zero-length (null) directory name in the value of   indicates the current directory. A null directory name may appear as two adjacent colons, or as an initial or trailing colon. The default path is system-dependent, and is set by the administrator who installs bash. A common value is " ". If this variable is in the environment when bash starts, the shell enters posix mode before reading the startup files, as if the   invocation option had been supplied. If it is set while the shell is running, bash enables posix mode, as if the command set   had been executed. If set, the value is executed as a command before issuing each primary prompt. If set to a number greater than zero, the value is used as the number of trailing directory components to retain when expanding the   and   prompt string escapes (see the section " " below). Characters removed are replaced with an ellipsis. The value of this parameter is expanded (see " " below) and used as the primary prompt string. The default value is "  ". The value of this parameter is expanded as with   and used as the secondary prompt string. The default is "  ". The value of this parameter is used as the prompt for the select command (see the section " " above). The value of this parameter is expanded as with   and the value is printed before each command bash displays during an execution trace. The first character of   is replicated multiple times, as necessary, to indicate multiple levels of indirection. The default is "  ". The full pathname to the shell is kept in this environment variable. If it is not set when the shell starts, bash assigns to it the full pathname of the current user's login shell. The value of this parameter is used as a format string specifying how the timing information for pipelines prefixed with the time reserved word should be displayed. The   character introduces an escape sequence that is expanded to a time value or other information. The escape sequences and their meanings are as follows; the braces denote optional portions. : A literal  . : The elapsed time in seconds. : The number of CPU seconds spent in user mode. : The number of CPU seconds spent in system mode. : The CPU percentage, computed as (  +  ) /  . The optional   is a digit specifying the precision, the number of fractional digits after a decimal point. A value of 0 causes no decimal point or fraction to be output. At most three places after the decimal point may be specified; values of   greater than 3 are changed to 3. If   is not specified, the value 3 is used. The optional   specifies a longer format, including minutes, of the form  . The value of   determines whether or not the fraction is included. If this variable is not set, bash acts as if it had the value  . If the value is null, no timing information is displayed. A trailing newline is added when the format string is displayed. If set to a value greater than zero,   is treated as the default timeout for the   builtin. The select command terminates if input does not arrive after   seconds when input is coming from a terminal. In an interactive shell, the value is interpreted as the number of seconds to wait for input after issuing the primary prompt. Bash terminates after waiting for that number of seconds if input does not arrive. If set, bash uses its value as the name of a directory in which bash creates temporary files for the shell's use. This variable controls how the shell interacts with the user and job control. If this variable is set, single word simple commands without redirections are treated as candidates for resumption of an existing stopped job. There is no ambiguity allowed; if there is more than one job beginning with the string typed, the job most recently accessed is selected. The name of a stopped job, in this context, is the command line used to start it. If set to the value exact, the string supplied must match the name of a stopped job exactly; if set to substring, the string supplied needs to match a substring of the name of a stopped job. The substring value provides functionality analogous to the   job identifier (see the section " " below). If set to any other value, the supplied string must be a prefix of a stopped job's name; this provides functionality analogous to the   job identifier. The two or three characters which control history expansion and tokenization (see the section " " below). The first character is the history expansion character, the character that signals the start of a history expansion, normally ' '. The second character is the quick substitution character, which is used as shorthand for re-running the previous command entered, substituting one string for another in the command. The default is ' '. The optional third character is the character that indicates that the remainder of the line is a comment when found as the first character of a word, normally ' '. The history comment character causes history substitution to be skipped for the remaining words on the line. It does not necessarily cause the shell parser to treat the rest of the line as a comment. Bash provides one-dimensional indexed and associative   variables. Any variable may be used as an indexed array; the   builtin will explicitly declare an array. There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously. Indexed arrays are referenced using integers (including arithmetic expressions) and are zero-based; associative arrays are referenced using arbitrary strings. An indexed array is created automatically if any variable is assigned to using the syntax  . The subscript is treated as an arithmetic expression that must evaluate to a number. If subscript evaluates to a number less than zero, it is used as an offset from one greater than the array's maximum index (so a subscript of   refers to the last element of the array). To explicitly declare an indexed array, use declare   name (see the section " " below).     is also accepted; the subscript is ignored. Associative arrays are created using declare   name. Attributes may be specified for an array variable using the   and   builtins. Each attribute applies to all members of an array. Arrays are assigned to using compound assignments of the form   ...  , where each value is of the form  . Indexed array assignments do not require the bracket and subscript. When assigning to indexed arrays, if the optional brackets and subscript are supplied, that index is assigned-to; otherwise the index of the element assigned is the last index assigned to by the statement plus one. Indexing starts at zero. When assigning to an associative array, the subscript is required. This syntax is also accepted by the   builtin. Individual array elements may be assigned to using the   syntax introduced above. Any element of an array may be referenced using  . The braces are required to avoid conflicts with pathname expansion. If subscript is   or  , the word expands to all members of name. These subscripts differ only when the word appears within double quotes. If the word is double-quoted,   expands to a single word with the value of each array member separated by the first character of the   special variable, and   expands each element of name to a separate word. When there are no array members,   expands to nothing. If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the original word, and the expansion of the last parameter is joined with the last part of the original word. This is analogous to the expansion of the special parameters   and   (see the section " " above).   expands to the length of  . If   is   or  , the expansion is the number of elements in the array. Referencing an array variable without a subscript is equivalent to referencing the array with a subscript of 0. An array variable is considered set if a subscript has been assigned a value. The null string is a valid value. The   builtin is used to destroy arrays.     destroys the array element at index  . Care must be taken to avoid unwanted side effects caused by pathname expansion.    , where   is an array, or    , where   is   or  , removes the entire array. The  ,  , and   builtins each accept a   option to specify an indexed array and a   option to specify an associative array. If both options are supplied,   takes precedence. The   builtin accepts a   option to assign a list of words read from the standard input to an array. The   and   builtins display array values in a way that allows them to be reused as assignments.  is performed on the command line after it has been split into words. There are seven kinds of expansion performed: brace expansion, tilde expansion, parameter and variable expansion, command substitution, arithmetic expansion, word splitting, and pathname expansion. The order of expansions is: brace expansion, tilde expansion, parameter, variable and arithmetic expansion and command substitution (done in a left-to-right fashion), word splitting, and pathname expansion. On systems that can support it, there is an additional expansion available: process substitution. Only brace expansion, word splitting, and pathname expansion can change the number of words of the expansion; other expansions expand a single word to a single word. The only exceptions to this are the expansions of " " and " " as explained above (see the section " "). Brace expansion is a mechanism by which arbitrary strings may be generated. This mechanism is similar to pathname expansion, but the filenames generated need not exist. Patterns to be brace expanded take the form of an optional preamble, followed by either a series of comma-separated strings or a sequence expression between a pair of braces, followed by an optional postscript. The preamble is prefixed to each string contained within the braces, and the postscript is then appended to each resulting string, expanding left to right. Brace expansions may be nested. The results of each expanded string are not sorted; left to right order is preserved. For example,   expands into ' '. A sequence expression takes the form  .. [.. ] , where   and   are either integers or single characters, and  , an optional increment, is an integer. When integers are supplied, the expression expands to each number between   and  , inclusive. Supplied integers may be prefixed with 0 to force each term to have the same width. When either   or   begins with a zero, the shell attempts to force all generated terms to contain the same number of digits, zero-padding where necessary. When characters are supplied, the expression expands to each character lexicographically between   and  , inclusive. Note that both   and   must be of the same type. When the increment is supplied, it is used as the difference between each term. The default increment is 1 or -1 as appropriate. Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result. It is strictly textual. Bash does not apply any syntactic interpretation to the context of the expansion or the text between the braces. A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma or a valid sequence expression. Any incorrectly formed brace expansion is left unchanged. A   or   may be quoted with a backslash to prevent its being considered part of a brace expression. To avoid conflicts with parameter expansion, the string   is not considered eligible for brace expansion. This construct is typically used as shorthand when the common prefix of the strings to be generated is longer than in the above example: or Brace expansion introduces a slight incompatibility with historical versions of  .   does not treat opening or closing braces specially when they appear as part of a word, and preserves them in the output. Bash removes braces from words as a consequence of brace expansion. For example, a word entered to sh as   appears identically in the output. The same word is output as   after expansion by bash. If strict compatibility with   is desired, start bash with the   option or disable brace expansion with the   option to the set command (see the section " " below). If a word begins with an unquoted tilde character (' '), all of the characters preceding the first unquoted slash (or all characters, if there is no unquoted slash) are considered a tilde-prefix. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login name. If this login name is the null string, the tilde is replaced with the value of the shell parameter  . If   is unset, the home directory of the user executing the shell is substituted instead. Otherwise, the tilde-prefix is replaced with the home directory associated with the specified login name. If the tilde-prefix is a ' ', the value of the shell variable   replaces the tilde-prefix. If the tilde-prefix is a ' ', the value of the shell variable  , if it is set, is substituted. If the characters following the tilde in the tilde-prefix consist of a number  , optionally prefixed by a ' ' or a ' ', the tilde-prefix is replaced with the corresponding element from the directory stack, as it would be displayed by the   builtin invoked with the tilde-prefix as an argument. If the characters following the tilde in the tilde-prefix consist of a number without a leading ' ' or ' ', ' ' is assumed. If the login name is invalid, or the tilde expansion fails, the word is unchanged. Each variable assignment is checked for unquoted tilde-prefixes immediately following a   or the first  . In these cases, tilde expansion is also performed. Consequently, one may use file names with tildes in assignments to  ,  , and  , and the shell assigns the expanded value. The ' ' character introduces parameter expansion, command substitution, or arithmetic expansion. The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name. When braces are used, the matching ending brace is the first ' ' not escaped by a backslash or within a quoted string, and not within an embedded arithmetic expansion, command substitution, or parameter expansion.  Here is table briefly describing each bash parameter expansion form, and how it behaves depending on the value of  . As you can see, if the expansion form includes a colon (" "), there is an alternate behavior when   is set, but its value is Null (which is equivalent to the single-quoted empty string,  ). If   is not set at all, behavior is the same with or without a colon. The following descriptions go into a bit more detail: Here, the value of   is substituted. The braces are required when   is a positional parameter with more than one digit, or when   is followed by a character that is not to be interpreted as part of its name. If the first character of   is an exclamation point ( ), a level of variable indirection is introduced. Bash uses the value of the variable formed from the rest of   as the name of the variable; this variable is then expanded and that value is used in the rest of the substitution, rather than the value of   itself. This is known as  . The exceptions to this are the expansions of   and   described below. The exclamation point must immediately follow the left brace to introduce indirection. In each of the cases below,   is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. When not performing substring expansion, using the forms documented below, bash tests for a parameter that is unset or null. Omitting the colon results in a test only for a parameter that is unset, bypassing the test if the parameter is null. Use Default Values. If   is unset or null, the expansion of   is substituted. Otherwise, the value of   is substituted. Assign Default Values. If   is unset or null, the expansion of   is assigned to  . The value of   is then substituted. Positional parameters and special parameters may not be assigned to in this way. Display Error if Null or Unset. If   is null or unset, the expansion of   (or a message to that effect if   is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of   is substituted. Use Alternate Value. If   is null or unset, nothing is substituted, otherwise the expansion of   is substituted. Substring Expansion. Expands to up to   characters of   starting at the character specified by  . If   is omitted, expands to the substring of   starting at the character specified by  . The   and   are arithmetic expressions (see the section " " below). If   evaluates to a number less than zero, the value is used as an offset from the end of the value of  . Arithmetic expressions starting with a   must be separated by whitespace from the preceding   to be distinguished from the Use Default Values expansion. If length evaluates to a number less than zero, and parameter is not   and not an indexed or associative array, it is interpreted as an offset from the end of the value of parameter rather than a number of characters, and the expansion is the characters between the two offsets. If   is  , the result is   positional parameters beginning at  . If   is an indexed array name subscripted by   or  , the result is the   members of the array beginning with  [ ] . A negative offset is taken relative to one greater than the maximum index of the specified array. Substring expansion applied to an associative array produces undefined results. Note that a negative offset must be separated from the colon by at least one space to avoid being confused with the   expansion. Substring indexing is zero-based unless the positional parameters are used, in which case the indexing starts at 1 by default. If offset is 0, and the positional parameters are used,   is prefixed to the list. Names matching  . Expands to the names of variables whose names begin with  , separated by the first character of the   special variable. When   is used and the expansion appears within double quotes, each variable name expands to a separate word. List of array keys. If   is an array variable, expands to the list of array indices (keys) assigned in name. If   is not an array, expands to 0 if name is set and null otherwise. When   is used and the expansion appears within double quotes, each key expands to a separate word. Parameter length. The length in characters of the value of   is substituted. If parameter is   or  , the value substituted is the number of positional parameters. If   is an array name subscripted by   or  , the value substituted is the number of elements in the array. Remove matching prefix pattern. The   is expanded to produce a pattern just as in pathname expansion. If the pattern matches the beginning of the value of  , then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the " " case) or the longest matching pattern (the " " case) deleted. If parameter is   or  , the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with   or  , the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list. Remove matching suffix pattern. The   is expanded to produce a pattern just as in pathname expansion. If the pattern matches a trailing portion of the expanded value of  , then the result of the expansion is the expanded value of   with the shortest matching pattern (the " " case) or the longest matching pattern (the " " case) deleted. If parameter is   or  , the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with   or  , the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list. Pattern substitution. The   is expanded to produce a pattern just as in pathname expansion. The   is expanded and the longest match of   against its value is replaced with string. If   begins with  , all matches of   are replaced with  . Normally only the first match is replaced. If   begins with  , it must match at the beginning of the expanded value of  . If   begins with  , it must match at the end of the expanded value of  . If   is null, matches of   are deleted and the   following pattern may be omitted. If   is   or  , the substitution operation is applied to each positional parameter in turn, and the expansion is the resultant list. If   is an array variable subscripted with   or  , the substitution operation is applied to each member of the array in turn, and the expansion is the resultant list. Case modification. This expansion modifies the case of alphabetic characters in  . The   is expanded to produce a pattern just as in pathname expansion. The   operator converts lowercase letters matching pattern to uppercase; the   operator converts matching uppercase letters to lowercase. The   and   expansions convert each matched character in the expanded value; the   and   expansions match and convert only the first character in the expanded value. If   is omitted, it is treated like a  , which matches every character. If   is   or  , the case modification operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with   or  , the case modification operation is applied to each member of the array in turn, and the expansion is the resultant list.  allows the output of a command to replace the command name. There are two forms: or Bash performs the expansion by executing   and replacing the command substitution with the standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but they may be removed during word splitting. The command substitution   can be replaced by the equivalent but faster  . When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by  ,  , or  . The first backquote not preceded by a backslash terminates the command substitution. When using the   form, all characters between the parentheses make up the command; none are treated specially. Command substitutions may be nested. To nest when using the backquoted form, escape the inner backquotes with backslashes. If the substitution appears within double quotes, word splitting and pathname expansion are not performed on the results.  allows the evaluation of an arithmetic expression and the substitution of the result. The format for arithmetic expansion is: The old format   is deprecated and will be removed in upcoming versions of bash. The   is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially. All tokens in the expression undergo parameter expansion, string expansion, command substitution, and quote removal. Arithmetic expansions may be nested. The evaluation is performed according to the rules listed below under the section " ." If   is invalid, bash prints a message indicating failure and no substitution occurs. Process substitution is supported on systems that support named pipes ( s) or the   method of naming open files. It takes the form of   or  . The process   is run with its input or output connected to a FIFO or some file in  . The name of this file is passed as an argument to the current command as the result of the expansion. If the   form is used, writing to the file will provide input for list. If the   form is used, the file passed as an argument should be read to obtain the output of list. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion. The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. The shell treats each character of   as a  , and splits the results of the other expansions into words on these characters. If   is unset, or its value is exactly  , the default, then sequences of  ,  , and   at the beginning and end of the results of the previous expansions are ignored, and any sequence of IFS characters not at the beginning or end serves to delimit words. If IFS has a value other than the default, then sequences of the whitespace characters space and tab are ignored at the beginning and end of the word, as long as the whitespace character is in the value of IFS (an IFS whitespace character). Any character in IFS that is not IFS whitespace, along with any adjacent IFS whitespace characters, delimits a field. A sequence of IFS whitespace characters is also treated as a delimiter. If the value of IFS is null, no word splitting occurs. Explicit null arguments (  or  ) are retained. Unquoted implicit null arguments, resulting from the expansion of parameters that have no values, are removed. If a parameter with no value is expanded within double quotes, a null argument results and is retained. Note that if no expansion occurs, no splitting is performed. After word splitting, unless the   option has been set, bash scans each word for the characters  ,  , and  . If one of these characters appears, then the word is regarded as a pattern, and replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are found, and the shell option   is not enabled, the word is left unchanged. If the   option is set, and no matches are found, the word is removed. If the   shell option is set, and no matches are found, an error message is printed and the command is not executed. If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. Note that when using range expressions like   (see the next section, " "), letters of the other case may be included, depending on the setting of  . When a pattern is used for pathname expansion, the character " " at the start of a name or immediately following a slash must be matched explicitly, unless the shell option   is set. When matching a pathname, the slash character must always be matched explicitly. In other cases, the " " character is not treated specially. See the description of   below under the section " " for a description of the  ,  ,  , and   shell options. The   shell variable may be used to restrict the set of file names matching a pattern. If   is set, each matching file name that also matches one of the patterns in   is removed from the list of matches. The file names " " and "  are always ignored when   is set and not null. However, setting   to a non-null value has the effect of enabling the   shell option, so all other file names beginning with a " " will match. To get the old behavior of ignoring file names beginning with a " ", make " " one of the patterns in  . The   option is disabled when   is unset. Any character that appears in a pattern, other than the special pattern characters described below, matches itself. The   character may not occur in a pattern. A backslash escapes the following character; the escaping backslash is discarded when matching. The special pattern characters must be quoted if they are to be matched literally. The special pattern characters have the following meanings: Matches any string, including the null string. When the   shell option is enabled, and   is used in a pathname expansion context, two adjacent  s used as a single pattern will match all files and zero or more directories and subdirectories. If followed by a  , two adjacent  s will match only directories and subdirectories. Matches any single character. Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a range expression; any character that sorts between those two characters, inclusive, using the current locale's collating sequence and character set, is matched. If the first character following the   is a   or a   then any character not enclosed is matched. The sorting order of characters in range expressions is determined by the current locale and the value of the   shell variable, if set. A   may be matched by including it as the first or last character in the set. A   may be matched by including it as the first character in the set. Within   and  , character classes can be specified using the syntax  , where   is one of the following classes defined in the POSIX standard: A character class matches any character belonging to that class. The word character class matches letters, digits, and the character  . Within   and  , an equivalence class can be specified using the syntax  , which matches all characters with the same collation weight (as defined by the current locale) as the character  . Within   and  , the syntax   matches the collating symbol  . If the   shell option is enabled using the   builtin, several extended pattern matching operators are recognized. In the following description, a   is a list of one or more patterns separated by a  . Composite patterns may be formed using one or more of the following sub-patterns: Matches zero or one occurrence of the given patterns Matches zero or more occurrences of the given patterns Matches one or more occurrences of the given patterns Matches one of the given patterns Matches anything except one of the given patterns After the preceding expansions, all unquoted occurrences of the characters  ,  , and   that did not result from one of the above expansions are removed. Before a command is executed, its input and output may be   using a special notation interpreted by the shell. Redirection may also be used to open and close files for the current shell execution environment. The following redirection operators may precede or appear anywhere within a simple command or may follow a command. Redirections are processed in the order they appear, from left to right. Each redirection that may be preceded by a file descriptor number may instead be preceded by a word of the form  . In this case, for each redirection operator except   and  , the shell will allocate a file descriptor greater than 10 and assign it to  . If   or   is preceded by  , the value of   defines the file descriptor to close. In the following descriptions, if the file descriptor number is omitted, and the first character of the redirection operator is  , the redirection refers to the standard input (file descriptor 0). If the first character of the redirection operator is  , the redirection refers to the standard output (file descriptor 1). The word following the redirection operator in the following descriptions, unless otherwise noted, is subjected to brace expansion, tilde expansion, parameter expansion, command substitution, arithmetic expansion, quote removal, pathname expansion, and word splitting. If it expands to more than one word, bash reports an error. Note that the order of redirections is significant. For example, the command directs both standard output and standard error to the file  , while the command directs only the standard output to file  , because the standard error was duplicated from the standard output before the standard output was redirected to  . Bash handles several filenames specially when they are used in redirections, as described in the following table: If   is a valid integer, file descriptor   is duplicated. File descriptor 0 is duplicated. File descriptor 1 is duplicated. File descriptor 2 is duplicated. If   is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a   connection to the corresponding socket. If   is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a   connection to the corresponding socket. A failure to open or create a file causes the redirection to fail. Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally. Note that the exec builtin command can make redirections take effect in the current shell. Redirection of input causes the file whose name results from the expansion of   to be opened for reading on file descriptor  , or the standard input (file descriptor 0) if   is not specified. The general format for redirecting input is: Redirection of output causes the file whose name results from the expansion of   to be opened for writing on file descriptor  , or the standard output (file descriptor 1) if   is not specified. If the file does not exist it is created; if it does exist it is truncated to zero size. The general format for redirecting output is: If the redirection operator is  , and the   option to the   builtin has been enabled, the redirection will fail if the file whose name results from the expansion of   exists and is a regular file. If the redirection operator is  , or the redirection operator is   and the   option to the   builtin command is not enabled, the redirection is attempted even if the file named by word exists. Redirection of output in this fashion causes the file whose name results from the expansion of   to be opened for appending on file descriptor  , or the standard output (file descriptor 1) if   is not specified. If the file does not exist it is created. The general format for appending output is: This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of  . There are two formats for redirecting standard output and standard error: and Of the two forms, the first is preferred. This is semantically equivalent to This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be appended to the file whose name is the expansion of  . The format for appending standard output and standard error is: This is semantically equivalent to This type of redirection instructs the shell to read input from the current source until a line containing only delimiter (with no trailing blanks) is seen. All of the lines read up to that point are then used as the standard input for a command. The format of here-documents is: No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word. If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded. If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence   is ignored, and   must be used to quote the characters  ,  , and  . If the redirection operator is  , then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion. A variant of here documents, the format is: The word is expanded and supplied to the command on its standard input. The redirection operator is used to duplicate input file descriptors. If   expands to one or more digits, the file descriptor denoted by   is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If   evaluates to  , file descriptor   is closed. If   is not specified, the standard input (file descriptor 0) is used. The operator is used similarly to duplicate output file descriptors. If   is not specified, the standard output (file descriptor 1) is used. If the digits in   do not specify a file descriptor open for output, a redirection error occurs. As a special case, if   is omitted, and word does not expand to one or more digits, the standard output and standard error are redirected as described previously. The redirection operator moves the file descriptor   to file descriptor  , or the standard input (file descriptor 0) if   is not specified. The   is closed after being duplicated to  . Similarly, the redirection operator moves the file descriptor digit to file descriptor  , or the standard output (file descriptor 1) if   is not specified. The redirection operator causes the file whose name is the expansion of   to be opened for both reading and writing on file descriptor  , or on file descriptor 0 if   is not specified. If the file does not exist, it is created.  allow a string to be substituted for a word when it is used as the first word of a simple command. The shell maintains a list of aliases that may be set and unset with the   and   builtin commands (see the section " " for details). The first word of each simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The characters  ,  ,  , and   and any of the shell metacharacters or quoting characters listed above may not appear in an alias name. The replacement text may contain any valid shell input, including shell metacharacters. The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time. This means that one may alias   to  , for instance, and bash does not try to recursively expand the replacement text. If the last character of the alias value is a blank, then the next command word following the alias is also checked for alias expansion. Aliases are created and listed with the   command, and removed with the   command. There is no mechanism for using arguments in the replacement text. If arguments are needed, a shell function should be used (see the section " " below). Aliases are not expanded when the shell is not interactive, unless the   shell option is set using   (see the description of   under the section " " below). The rules concerning the definition and use of aliases are somewhat confusing. Bash always reads at least one complete line of input before executing any of the commands on that line. Aliases are expanded when a command is read, not when it is executed. Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read. The commands following the alias definition on that line are not affected by the new alias. This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command. As a consequence, aliases defined in a function are not available until after that function is executed. To be safe, always put alias definitions on a separate line, and do not use alias in compound commands. For almost every purpose, aliases are superseded by shell functions. A  , defined as described above under the section " ", stores a series of commands for later execution. When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Functions are executed in the context of the current shell; no new process is created to interpret them (contrast this with the execution of a shell script). When a function is executed, the arguments to the function become the positional parameters during its execution. The special parameter   is updated to reflect the change. Special parameter 0 is unchanged. The first element of the   variable is set to the name of the function while the function is executing. All other aspects of the shell execution environment are identical between a function and its caller with these exceptions: the   and   traps (see the description of the   builtin under the section " " below) are not inherited unless the function has been given the   attribute (see the description of the   builtin below) or the   shell option has been enabled with the   builtin (in which case all functions inherit the   and   traps), and the   trap is not inherited unless the   shell option has been enabled. Variables local to the function may be declared with the   builtin command. Ordinarily, variables and their values are shared between the function and its caller. The   variable, if set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed the limit cause the entire command to abort. If the builtin command   is executed in a function, the function completes and execution resumes with the next command after the function call. Any command associated with the   trap is executed before execution resumes. When a function completes, the values of the positional parameters and the special parameter   are restored to the values they had before the function's execution. Function names and definitions may be listed with the   option to the   or   builtin commands. The   option to   or   will list the function names only (and optionally the source file and line number, if the   shell option is enabled). Functions may be exported so that subshells automatically have them defined with the   option to the   builtin. A function definition may be deleted using the   option to the   builtin. Note that shell functions and variables with the same name may result in multiple identically-named entries in the environment passed to the shell's children. Care should be taken in cases where this may cause a problem. Functions may be recursive. The   variable may be used to limit the depth of the function call stack and restrict the number of function invocations. By default, no limit is imposed on the number of recursive calls. The shell allows   to be  , under certain circumstances (see the   and   builtin commands and the section " "). Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error. The operators and their precedence, associativity, and values are the same as in the  . The following list of operators is grouped into levels of equal-precedence operators. The levels are listed in order of decreasing precedence. ,  variable post-increment and post-decrement ,  variable pre-increment and pre-decrement ,  unary minus and plus ,  logical and bitwise negation exponentiation ,  ,  multiplication, division, remainder ,  addition, subtraction ,  left and right bitwise shifts ,  ,  ,  comparison ,  equality and inequality bitwise AND bitwise exclusive OR bitwise OR logical AND logical OR conditional operator ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  assignment   comma Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated. Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax. A shell variable that is null or unset evaluates to 0 when referenced by name without using the parameter expansion syntax. The value of a variable is evaluated as an arithmetic expression when it is referenced, or when a variable which has been given the integer attribute using   is assigned a value. A null value evaluates to 0. A shell variable need not have its integer attribute turned on to be used in an expression. Constants with a leading 0 are interpreted as octal numbers. A leading   or   denotes hexadecimal. Otherwise, numbers take the form  , where the optional base is a decimal number between 2 and 64 representing the arithmetic base, and   is a number in that base. If   is omitted, then base 10 is used. The digits greater than 9 are represented by the lowercase letters, the uppercase letters,  , and  , in that order. If base is less than or equal to 36, lowercase and uppercase letters may be used interchangeably to represent numbers between 10 and 35. Operators are evaluated in order of precedence. Sub-expressions in parentheses are evaluated first and may override the precedence rules above. Conditional expressions are used by the   compound command and the   and   builtin commands to test file attributes and perform string and arithmetic comparisons. Expressions are formed from the following unary or binary primaries. If any file argument to one of the primaries is of the form  , then file descriptor   is checked. If the file argument to one of the primaries is one of  ,  , or  , file descriptor 0, 1, or 2, respectively, is checked. Unless otherwise specified, primaries that operate on files follow   and operate on the target of the link, rather than the link itself. When used with  , the   and   operators sort lexicographically using the current locale. The test command sorts using   ordering.   True if   exists.   True if   exists and is a block special file.   True if   exists and is a character special file.   True if   exists and is a directory.   True if   exists.   True if   exists and is a regular file.   True if   exists and is set-group-id.   True if   exists and is a symbolic link.   True if   exists and its "sticky" bit is set.   True if   exists and is a named pipe (FIFO).   True if   exists and is readable.   True if   exists and has a size greater than zero.   True if file descriptor   is open and refers to a terminal.   True if   exists and its set-user-id bit is set.   True if   exists and is writable.   True if   exists and is executable.   True if   exists and is owned by the effective group id.   True if   exists and is a symbolic link.   True if   exists and has been modified since it was last read.   True if   exists and is owned by the effective user id.   True if   exists and is a socket.     True if   and   refer to the same device and   numbers.     True if   is newer (according to modification date) than  , or if   exists and   does not.     True if   is older than  , or if   exists and   does not.   True if the shell option   is enabled. See the list of options under the description of the   option to the   builtin below.   True if the shell variable   is set (has been assigned a value).   True if the length of   is zero. ,    True if the length of   is non-zero.     ,      True if the strings are equal.   should be used with the   command for POSIX conformance.     True if the strings are not equal.     True if   sorts before   lexicographically.     True if   sorts after   lexicographically.      is one of  ,  ,  ,  ,  , or  . These arithmetic binary operators return true if   is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to  , respectively. The   and   may be positive or negative integers. When a   is executed, the shell performs the following expansions, assignments, and redirections, from left to right. If no command name results, the variable assignments affect the current shell environment. Otherwise, the variables are added to the environment of the executed command and do not affect the current shell environment. If any of the assignments attempts to assign a value to a readonly variable, an error occurs, and the command exits with a non-zero status. If no command name results, redirections are performed, but do not affect the current shell environment. A redirection error causes the command to exit with a non-zero status. If there is a command name left after expansion, execution proceeds as described below. Otherwise, the command exits. If one of the expansions contained a command substitution, the exit status of the command is the exit status of the last command substitution performed. If there were no command substitutions, the command exits with a status of zero. After a command has been split into words, if it results in a simple command and an optional list of arguments, the following actions are taken. If the command name contains no slashes, the shell attempts to locate it. If there exists a shell function by that name, that function is invoked as described above in the section " ." If the name does not match a function, the shell searches for it in the list of shell builtins. If a match is found, that builtin is invoked. If the name is neither a shell function nor a builtin, and contains no slashes, bash searches each element of the PATH for a directory containing an executable file by that name. Bash uses a hash table to remember the full pathnames of executable files (see   under the section " " below). A full search of the directories in PATH is performed only if the command is not found in the hash table. If the search is unsuccessful, the shell searches for a defined shell function named  . If that function exists, it is invoked with the original command and the original command's arguments as its arguments, and the function's exit status becomes the exit status of the shell. If that function is not defined, the shell prints an error message and returns an exit status of 127. If the search is successful, or if the command name contains one or more slashes, the shell executes the named program in a separate execution environment. Argument 0 is set to the name given, and the remaining arguments to the command are set to the arguments given, if any. If this execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a shell script, a file containing shell commands. A subshell is spawned to execute it. This subshell reinitializes itself, so that the effect is as if a new shell had been invoked to handle the script, with the exception that the locations of commands remembered by the parent (see   below under the section " ") are retained by the child. If the program is a file beginning with  , the remainder of the first line specifies an interpreter for the program. The shell executes the specified interpreter on operating systems that do not handle this executable format themselves. The arguments to the interpreter consist of a single optional argument following the interpreter name on the first line of the program, followed by the name of the program, followed by the command arguments, if any. The shell has an  , which consists of the following: When a simple command other than a builtin or shell function is to be executed, it is invoked in a separate execution environment that consists of the following. Unless otherwise noted, the values are inherited from the shell. A command invoked in this separate environment cannot affect the shell's execution environment. Command substitution, commands grouped with parentheses, and asynchronous commands are invoked in a subshell environment that is a duplicate of the shell environment, except that traps caught by the shell are reset to the values that the shell inherited from its parent at invocation. Builtin commands that are invoked as part of a pipeline are also executed in a subshell environment. Changes made to the subshell environment cannot affect the shell's execution environment. Subshells spawned to execute command substitutions inherit the value of the   option from the parent shell. When not in posix mode, bash clears the   option in such subshells. If a command is followed by a   and job control is not active, the default standard input for the command is the empty file  . Otherwise, the invoked command inherits the file descriptors of the calling shell as modified by redirections. When a program is invoked it is given an array of strings called the  . This is a list of name-value pairs, of the form  . The shell provides several ways to manipulate the environment. On invocation, the shell scans its own environment and creates a parameter for each name found, automatically marking it for export to child processes. Executed commands inherit the environment. The   and   commands allow parameters and functions to be added to and deleted from the environment. If the value of a parameter in the environment is modified, the new value becomes part of the environment, replacing the old. The environment inherited by any executed command consists of the shell's initial environment, whose values may be modified in the shell, less any pairs removed by the unset command, plus any additions via the   and   commands. The environment for any simple command or function may be augmented temporarily by prefixing it with parameter assignments, as described above in the section " ." These assignment statements affect only the environment seen by that command. If the   option is set (see the   builtin command below), then all parameter assignments are placed in the environment for a command, not just those that precede the command name. When   invokes an external command, the variable   is set to the full file name of the command and passed to that command in its environment. The   of an executed command is the value returned by the   system call or equivalent function. Exit statuses fall between 0 and 255, though, as explained below, the shell may use values above 125 specially. Exit statuses from shell builtins and compound commands are also limited to this range. Under certain circumstances, the shell will use special values to indicate specific failure modes. For the shell's purposes, a command which exits with a zero exit status has succeeded. An exit status of zero indicates success. A non-zero exit status indicates failure. When a command terminates on a fatal signal  , bash uses the value of   as the exit status. If a command is not found, the child process created to execute it returns a status of 127. If a command is found but is not executable, the return status is 126. If a command fails because of an error during expansion or redirection, the exit status is greater than zero. Shell builtin commands return a status of 0 (true) if successful, and non-zero (false) if an error occurs while they execute. All builtins return an exit status of 2 to indicate incorrect usage. Bash itself returns the exit status of the last command executed, unless a syntax error occurs, in which case it exits with a non-zero value. See also the exit builtin command below. When bash is interactive, in the absence of any traps, it ignores   (so that kill 0 does not kill an interactive shell), and   is caught and handled (so that the wait builtin is interruptible). In all cases, bash ignores  . If job control is in effect, bash ignores  ,  , and  . Non-builtin commands run by bash have signal handlers set to the values inherited by the shell from its parent. When job control is not in effect, asynchronous commands ignore   and   in addition to these inherited handlers. Commands run as a result of command substitution ignore the keyboard-generated job control signals  ,  , and  . The shell exits by default upon receipt of a  . Before exiting, an interactive shell resends the   to all jobs, running or stopped. Stopped jobs are sent   to ensure that they receive the  . To prevent the shell from sending the signal to a particular job, it should be removed from the jobs table with the   builtin (see the section " " below) or marked to not receive   using  . If the   shell option has been set with  , bash sends a   to all jobs when an interactive login shell exits. If bash is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command completes. When bash is waiting for an asynchronous command via the   builtin, the reception of a signal for which a trap has been set will cause the wait builtin to return immediately with an exit status greater than 128, immediately after which the trap is executed.  refers to the ability to selectively stop (suspend) the execution of processes and continue (resume) their execution at a later point. A user typically employs this facility via an interactive interface supplied jointly by the operating system  's terminal driver and bash. The shell associates a job with each pipeline. It keeps a table of currently executing jobs, which may be listed with the   command. When bash starts a job asynchronously (in the background), it prints a line that looks like: indicating that this job is job number   and that the process ID of the last process in the pipeline associated with this job is  . All of the processes in a single pipeline are members of the same job. Bash uses the job abstraction as the basis for job control. To facilitate the implementation of the user interface to job control, the operating system maintains the notion of a current terminal process group ID. Members of this process group (processes whose process group ID is equal to the current terminal process group ID) receive keyboard-generated signals such as  . These processes are said to be in the foreground. Background processes are those whose process group ID differs from the terminal's; such processes are immune to keyboard-generated signals. Only foreground processes are allowed to read from or, if the user so specifies with stty tostop, write to the terminal. Background processes which attempt to read from (write to when stty tostop is in effect) the terminal are sent a   ( ) signal by the kernel's terminal driver, which, unless caught, suspends the process. If the operating system on which bash is running supports job control, bash contains facilities to use it. Typing the suspend character (typically  ,  ) while a process is running causes that process to be stopped and returns control to bash. Typing the delayed suspend character (typically  ,  ) causes the process to be stopped when it attempts to read input from the terminal, and control to be returned to bash. The user may then manipulate the state of this job, using the   command to continue it in the background, the   command to continue it in the foreground, or the   command to kill it. A   takes effect immediately, and has the additional side effect of causing pending output and typeahead to be discarded. There are a number of ways to refer to a job in the shell. The character   introduces a job specification ( ). Job number   may be referred to as  . A job may also be referred to using a prefix of the name used to start it, or using a substring that appears in its command line. For example,   refers to a stopped   job. If a prefix matches more than one job, bash reports an error. Using  , on the other hand, refers to any job containing the string   in its command line. If the substring matches more than one job, bash reports an error. The symbols   and   refer to the shell's notion of the current job, which is the last job stopped while it was in the foreground or started in the background. The previous job may be referenced using  . If there is only a single job,   and   can both be used to refer to that job. In output pertaining to jobs (e.g., the output of the   command), the current job is always flagged with a  , and the previous job with a  . A single   (with no accompanying job specification) also refers to the current job. Naming a job can be used to bring it into the foreground:   is a synonym for "fg %1", bringing job 1 from the background into the foreground. Similarly, " " resumes job 1 in the background, equivalent to " ". The shell learns immediately whenever a job changes state. Normally, bash waits until it is about to print a prompt before reporting changes in a job's status so as to not interrupt any other output. If the   option to the   builtin command is enabled, bash reports such changes immediately. Any trap on   is executed for each child that exits. If an attempt to exit bash is made while jobs are stopped (or, if the   shell option has been enabled using the   builtin, running), the shell prints a warning message, and, if the   option is enabled, lists the jobs and their statuses. The jobs command may then be used to inspect their status. If a second attempt to exit is made without an intervening command, the shell does not print another warning, and any stopped jobs are terminated. When executing interactively, bash displays the primary prompt   when it is ready to read a command, and the secondary prompt   when it needs more input to complete a command. Bash allows these prompt strings to be customized by inserting a number of backslash-escaped special characters that are decoded as follows: an ASCII bell character (07) the date in "Weekday Month Date" format (e.g., "Tue May 26") the format is passed to   and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required. an ASCII escape character (033) the hostname up to the first '.' the hostname the number of jobs currently managed by the shell the   of the shell's terminal device name the name of the shell, the   of   (the portion following the final slash) the current time in 24-hour   format the current time in 12-hour   format the current time in 12-hour am/pm format the current time in 24-hour   format the username of the current user the version of bash (e.g., 2.00) the release of bash, version + patch level (e.g., 2.00.0) the current working directory, with   abbreviated with a tilde (uses the value of the   variable) the   of the current working directory, with   abbreviated with a tilde the history number of this command the command number of this command if the effective UID is 0, a  , otherwise a  the character corresponding to the octal number  a backslash begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt. end a sequence of non-printing characters The command number and the history number are usually different: the   of a command is its position in the history list, which may include commands restored from the history file (see the section " ", below), while the   is the position in the sequence of commands executed during the current shell session. After the string is decoded, it is expanded via parameter expansion, command substitution, arithmetic expansion, and quote removal, subject to the value of the   shell option (see the description of the   command under " " section below). This is the library that handles reading input when using an interactive shell, unless the   option is given at shell invocation. Line editing is also used when using the   option to the   builtin. By default, the line editing commands are similar to those of  . A  -style line editing interface is also available. Line editing can be enabled at any time using the   or   options to the   builtin (see the section " " below). To turn off line editing after the shell is running, use the   or   options to the   builtin. In this section, the  -style notation is used to denote keystrokes. Control keys are denoted by  -key, e.g.,   means  . Similarly, meta keys are denoted by  -key, so   means  . On keyboards without a meta key,   means  , i.e., press the   key then the   key. This makes   the meta prefix. The combination   means  , or press the   key then hold the   key while pressing the   key.  commands may be given numeric arguments, which normally act as a repeat count. Sometimes, however, it is the sign of the argument that is significant. Passing a negative argument to a command that acts in the forward direction (e.g.,  ) causes that command to act in a backward direction. Commands whose behavior with arguments deviates from this are noted below. When a command is described as killing text, the text deleted is saved for possible future retrieval (yanking). The killed text is saved in a kill ring. Consecutive kills cause the text to be accumulated into one unit, which can be yanked all at once. Commands which do not kill text separate the chunks of text on the kill ring. Readline is customized by putting commands in an initialization file (the   file). The name of this file is taken from the value of the   variable. If that variable is unset, the default is  . When a program which uses the   library starts up, the initialization file is read, and the key bindings and variables are set. There are only a few basic constructs allowed in the   initialization file. Blank lines are ignored. Lines beginning with a   are comments. Lines beginning with a   indicate conditional constructs. Other lines denote key bindings and variable settings. The default key-bindings may be changed with an   file. Other programs that use this library may add their own commands and bindings. For example, placing or into the   would make   execute the   command  . The following symbolic character names are recognized:   and  . In addition to command names,   allows keys to be bound to a string that is inserted when the key is pressed (a  ). The syntax for controlling key bindings in the   file is simple. All that is required is the name of the command or the text of a macro and a key sequence to which it should be bound. The name may be specified in one of two ways: as a symbolic key name, possibly with   or   prefixes, or as a key sequence. When using the form   or macro,   is the name of a key spelled out in English. For example: In the above example,   is bound to the function universal-argument,   is bound to the function  , and   is bound to run the macro expressed on the right hand side (that is, to insert the text " " into the line). In the second form,  ,   differs from   above in that strings denoting an entire key sequence may be specified by placing the sequence within double quotes. Some   Emacs style key escapes can be used, as in the following example, but the symbolic character names are not recognized. In this example,   is again bound to the function universal-argument.   is bound to the function  , and   is bound to insert the text " ". The full set of GNU Emacs style escape sequences is control prefix meta prefix an escape character backslash literal  literal  In addition to the GNU Emacs style escape sequences, a second set of backslash escapes is available: alert (bell) backspace delete form feed newline carriage return horizontal tab vertical tab the eight-bit character whose value is the octal value   (one to three digits) the eight-bit character whose value is the hexadecimal value   (one or two hex digits) When entering the text of a  , single or double quotes must be used to indicate a macro definition. Unquoted text is assumed to be a function name. In the macro body, the backslash escapes described above are expanded. Backslash will quote any other character in the macro text, including   and  . Bash allows the current   key bindings to be displayed or modified with the   builtin command. The editing mode may be switched during interactive use by using the   option to the   builtin command (see the section " " below).  has variables that can be used to further customize its behavior. A variable may be set in the   file with a statement of the form. Except where noted,   variables can take the values   or   (without regard to case). Unrecognized variable names are ignored. When a variable value is read, empty or null values, " " (case-insensitive), and " " are equivalent to  . All other values are equivalent to  . The variables and their default values are: audible Controls what happens when readline wants to ring the terminal bell. If set to  , readline never rings the bell. If set to  , readline uses a visible bell if one is available. If set to  , readline attempts to ring the terminal's bell. On If set to  , readline attempts to bind the control characters treated specially by the kernel's terminal driver to their readline equivalents. "#" The string that is inserted when the readline insert-comment command is executed. This command is bound to   in emacs mode and to   in vi command mode. Off If set to  , readline performs filename matching and completion in a case-insensitive fashion. 0 The length in characters of the common prefix of a list of possible completions that is displayed without modification. When set to a value greater than zero, common prefixes longer than this value are replaced with an ellipsis when displaying possible completions. 100 This determines when the user is queried about viewing the number of possible completions generated by the possible-completions command. It may be set to any integer value greater than or equal to zero. If the number of possible completions is greater than or equal to the value of this variable, the user is asked whether or not he wishes to view them; otherwise they are listed on the terminal. On If set to  , readline will convert characters with the eighth bit set to an   key sequence by stripping the eighth bit and prefixing an escape character (in effect, using escape as the meta prefix). Off If set to  , readline will inhibit word completion. Completion characters will be inserted into the line as if they had been mapped to self-insert. emacs Controls whether readline begins with a set of key bindings similar to Emacs or vi.   can be set to either   or  . On When set to  , on operating systems that indicate they support it, readline echoes a character corresponding to a signal generated from the keyboard. Off When set to  , readline will try to enable the application keypad when it is called. Some systems need this to enable the arrow keys. On When set to  , readline will try to enable any meta modifier key the terminal claims to support when it is called. On many terminals, the meta key is used to send eight-bit characters. Off If set to  , tilde expansion is performed when readline attempts word completion. Off If set to  , the history code attempts to place point at the same location on each history line retrieved with   or  . 0 Set the maximum number of history entries saved in the history list. If set to zero, the number of entries in the history list is not limited. Off When set to  , makes readline use a single line for display, scrolling the input horizontally on a single screen line when it becomes longer than the screen width rather than wrapping to a new line. Off If set to  , readline will enable eight-bit input (that is, it will not strip the high bit from the characters it reads), regardless of what the terminal claims it can support. The name meta-flag is a synonym for this variable. "C-[C-J" The string of characters that should terminate an incremental search without subsequently executing the character as a command. If this variable has not been given a value, the characters   and   will terminate an incremental search. emacs Set the current readline keymap. The set of valid keymap names is  ,  ,  ,  ,  ,  , and  .   is equivalent to  ;   is equivalent to  . The default value is  ; the value of   also affects the default keymap. On If set to  , completed directory names have a slash appended. Off If set to  , history lines that have been modified are displayed with a preceding asterisk ( ). Off If set to  , completed names that are symbolic links to directories have a slash appended (subject to the value of mark-directories). On This variable, when set to  , causes readline to match files whose names begin with a ' ' (hidden files) when performing filename completion. If set to  , the leading ' ' must be supplied by the user in the filename to be completed. Off If set to  , menu completion displays the common prefix of the list of possible completions (which may be empty) before cycling through the list. Off If set to  , readline displays characters with the eighth bit set directly rather than as a meta-prefixed escape sequence. On If set to  , readline uses an internal more-like pager to display a screenful of possible completions at a time. Off If set to  , readline displays completions with matches sorted horizontally in alphabetical order, rather than down the screen. Off If set to  , readline will undo all changes to history lines before returning when accept-line is executed. By default, history lines may be modified and retain individual undo lists across calls to readline. Off This alters the default behavior of the completion functions. If set to  , words which have more than one possible completion cause the matches to be listed immediately instead of ringing the bell. Off This alters the default behavior of the completion functions in a fashion similar to  . If set to  , words which have more than one possible completion without any possible partial completion (the possible completions don't share a common prefix) cause the matches to be listed immediately instead of ringing the bell. Off If set to  , this alters the default completion behavior when inserting a single match into the line. It's only active when performing completion in the middle of a word. If enabled, readline does not insert characters from the completion that match characters after point in the word being completed, so portions of the word following the cursor are not duplicated. Off If set to  , a character denoting a file's type as reported by   is appended to the filename when listing possible completions. Readline implements a facility similar in spirit to the conditional compilation features of the C preprocessor that allows key bindings and variable settings to be performed as the result of tests. There are four parser directives used. The   construct allows bindings to be made based on the editing mode, the terminal being used, or the application using readline. The text of the test extends to the end of the line; no characters are required to isolate it. The   form of the   directive is used to test whether readline is in   or   mode. This may be used in conjunction with the set keymap command, for instance, to set bindings in the   and   keymaps only if readline is starting out in emacs mode. The   form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal's function keys. The word on the right side of the   is tested against the both full name of the terminal and the portion of the terminal name before the first  . This allows   to match both   and  , for instance. The   construct is used to include application-specific settings. Each program using the readline library sets the application name, and an initialization file can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance, the following command adds a key sequence that quotes the current or previous word in bash: This command, as seen in the previous example, terminates an   command. Commands in this branch of the   directive are executed if the test fails. This directive takes a single filename as an argument and reads commands and bindings from that file. For example, the following directive would read   provides commands for searching through the command history (see section " " below) for lines containing a specified string. There are two search modes:   and   begin before the user has finished typing the search string. As each character of the search string is typed,   displays the next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history entry. The characters present in the value of the isearch-terminators variable are used to terminate an incremental search. If that variable has not been assigned a value the   and   characters will terminate an incremental search.   will abort an incremental search and restore the original line. When the search is terminated, the history entry containing the search string becomes the current line. To find other matching entries in the history list, type   or   as appropriate. This will search backward or forward in the history for the next entry matching the search string typed so far. Any other key sequence bound to a   command will terminate the search and execute that command. For instance, a   will terminate the search and accept the line, thereby executing the command from the history list.  remembers the last incremental search string. If two  s are typed without any intervening characters defining a new search string, any remembered search string is used. Non-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or be part of the contents of the current line. The following is a list of the names of the commands and the default key sequences to which they are bound. Command names without an accompanying key sequence are unbound by default. In the following descriptions,   refers to the current cursor position, and   refers to a cursor position saved by the   command. The text between the   and   is referred to as the  . beginning-of-line C-a Move to the start of the current line. end-of-line C-e Move to the end of the line. forward-char C-f Move forward a character. backward-char C-b Move back a character. forward-word M-f Move forward to the end of the next word. Words are composed of alphanumeric characters (letters and digits). backward-word M-b Move back to the start of the current or previous word. Words are composed of alphanumeric characters (letters and digits). shell-forward-word Move forward to the end of the next word. Words are delimited by non-quoted shell metacharacters. shell-backward-word Move back to the start of the current or previous word. Words are delimited by non-quoted shell metacharacters. clear-screen C-l Clear the screen leaving the current line at the top of the screen. With an argument, refresh the current line without clearing the screen. redraw-current-line Refresh the current line. accept-line Newline, Return Accept the line regardless of where the cursor is. If this line is non-empty, add it to the history list according to the state of the   variable. If the line is a modified history line, then restore the history line to its original state. previous-history C-p Fetch the previous command from the history list, moving back in the list. next-history C-n Fetch the next command from the history list, moving forward in the list. beginning-of-history M-< Move to the first line in the history. end-of-history M-> Move to the end of the input history, i.e., the line currently being entered. reverse-search-history C-r Search backward starting at the current line and moving 'up' through the history as necessary. This is an incremental search. forward-search-history C-s Search forward starting at the current line and moving 'down' through the history as necessary. This is an incremental search. non-incremental-reverse-search-history M-p Search backward through the history starting at the current line using a non- incremental search for a string supplied by the user. non-incremental-forward-search-history M-n Search forward through the history using a non-incremental search for a string supplied by the user. history-search-forward Search forward through the history for the string of characters between the start of the current line and the point. This is a non-incremental search. history-search-backward Search backward through the history for the string of characters between the start of the current line and the point. This is a non-incremental search. yank-nth-arg M-C-y Insert the first argument to the previous command (usually the second word on the previous line) at point. With an argument  , insert the  th word from the previous command (the words in the previous command begin with word 0). A negative argument inserts the nth word from the end of the previous command. Once the argument   is computed, the argument is extracted as if the " " history expansion had been specified. yank-last-arg M-., M-_ Insert the last argument to the previous command (the last word of the previous history entry). With a numeric argument, behave exactly like  . Successive calls to   move back through the history list, inserting the last word (or the word specified by the argument to the first call) of each line in turn. Any numeric argument supplied to these successive calls determines the direction to move through the history. A negative argument switches the direction through the history (back or forward). The history expansion facilities are used to extract the last argument, as if the " " history expansion had been specified. shell-expand-line M-C-e Expand the line as the shell does. This performs alias and history expansion as well as all of the shell word expansions. See the section " " below for a description of history expansion. history-expand-line M-^ Perform history expansion on the current line. See the section " " below for a description of history expansion. magic-space Perform history expansion on the current line and insert a space. See the section " " below for a description of history expansion. alias-expand-line Perform alias expansion on the current line. See the section " " above for a description of alias expansion. history-and-alias-expand-line Perform history and alias expansion on the current line. insert-last-argument M-., M-_ A synonym for  . operate-and-get-next C-o Accept the current line for execution and fetch the next line relative to the current line from the history for editing. Any argument is ignored. edit-and-execute-command C-xC-e Invoke an editor on the current command line, and execute the result as shell commands. Bash attempts to invoke  ,  , and   as the editor, in that order. delete-char C-d Delete the character at  . If   is at the beginning of the line, there are no characters in the line, and the last character typed was not bound to  , then return EOF. backward-delete-char Rubout Delete the character behind the cursor. When given a numeric argument, save the deleted text on the kill ring. forward-backward-delete-char Delete the character under the cursor, unless the cursor is at the end of the line, in which case the character behind the cursor is deleted. quoted-insert C-q, C-v Add the next character typed to the line verbatim. This is how to insert characters like C-q, for example. tab-insert C-v TAB Insert a tab character. self-insert a, b, A, 1, !, ... Insert the character typed. transpose-chars C-t Drag the character before   forward over the character at  , moving   forward as well. If   is at the end of the line, then this transposes the two characters before  . Negative arguments have no effect. transpose-words M-t Drag the word before   past the word after  , moving   over that word as well. If   is at the end of the line, this transposes the last two words on the line. upcase-word M-u Uppercase the current (or following) word. With a negative argument, uppercase the previous word, but do not move  . downcase-word M-l Lowercase the current (or following) word. With a negative argument, lowercase the previous word, but do not move  . capitalize-word M-c Capitalize the current (or following) word. With a negative argument, capitalize the previous word, but do not move  . overwrite-mode Toggle overwrite mode. With an explicit positive numeric argument, switches to overwrite mode. With an explicit non-positive numeric argument, switches to insert mode. This command affects only emacs mode; vi mode does overwrite differently. Each call to readline() starts in insert mode. In overwrite mode, characters bound to self-insert replace the text at point rather than pushing the text to the right. Characters bound to   replace the character before   with a space. By default, this command is unbound. kill-line C-k Kill the text from   to the end of the line. backward-kill-line C-x Rubout Kill backward to the beginning of the line. unix-line-discard C-u Kill backward from   to the beginning of the line. The killed text is saved on the kill-ring. kill-whole-line Kill all characters on the current line, no matter where point is. kill-word M-d Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by forward-word. backward-kill-word M-Rubout Kill the word behind  . Word boundaries are the same as those used by backward-word. shell-kill-word M-d Kill from   to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by  . shell-backward-kill-word M-Rubout Kill the word behind  . Word boundaries are the same as those used by  . unix-word-rubout C-w Kill the word behind  , using white space as a word boundary. The killed text is saved on the kill-ring. unix-filename-rubout Kill the word behind  , using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring. delete-horizontal-space M-\ Delete all spaces and tabs around  . kill-region Kill the text in the current region. copy-region-as-kill Copy the text in the region to the kill buffer. copy-backward-word Copy the word before   to the kill buffer. The word boundaries are the same as  . copy-forward-word Copy the word following   to the kill buffer. The word boundaries are the same as  . yank C-y Yank the top of the kill ring into the buffer at  . yank-pop M-y Rotate the kill ring, and yank the new top. Only works following   or  . digit-argument M-0, M-1, ..., M-- Add this digit to the argument already accumulating, or start a new argument. M-- starts a negative argument. universal-argument This is another way to specify an argument. If this command is followed by one or more digits, optionally with a leading minus sign, those digits define the argument. If the command is followed by digits, executing   again ends the numeric argument, but is otherwise ignored. As a special case, if this command is immediately followed by a character that is neither a digit or minus sign, the argument count for the next command is multiplied by four. The argument count is initially one, so executing this function the first time makes the argument count four, a second time makes the argument count sixteen, and so on. complete TAB Attempt to perform completion on the text before  . Bash attempts completion treating the text as a variable (if the text begins with  ), username (if the text begins with  ), hostname (if the text begins with  ), or command (including aliases and functions) in turn. If none of these produces a match, filename completion is attempted. possible-completions M-? List the possible completions of the text before point. insert-completions M-* Insert all completions of the text before   that would have been generated by possible-completions. menu-complete Similar to  , but replaces the word to be completed with a single match from the list of possible completions. Repeated execution of   steps through the list of possible completions, inserting each match in turn. At the end of the list of completions, the bell is rung (subject to the setting of bell-style) and the original text is restored. An argument of   moves   positions forward in the list of matches; a negative argument may be used to move backward through the list. This command is intended to be bound to  , but is unbound by default. menu-complete-backward Identical to  , but moves backward through the list of possible completions, as if   had been given a negative argument. This command is unbound by default. delete-char-or-list Deletes the character under the cursor if not at the beginning or end of the line (like  ). If at the end of the line, behaves identically to  . This command is unbound by default. complete-filename M-/ Attempt filename completion on the text before point. possible-filename-completions C-x / List the possible completions of the text before  , treating it as a filename. complete-username M-~ Attempt completion on the text before  , treating it as a username. possible-username-completions C-x ~ List the possible completions of the text before  , treating it as a username. complete-variable M-$ Attempt completion on the text before  , treating it as a shell variable. possible-variable-completions C-x $ List the possible completions of the text before point, treating it as a shell variable. complete-hostname Attempt completion on the text before  , treating it as a hostname. possible-hostname-completions C-x @ List the possible completions of the text before  , treating it as a hostname. complete-command M-! Attempt completion on the text before  , treating it as a command name. Command completion attempts to match the text against aliases, reserved words, shell functions, shell builtins, and finally executable filenames, in that order. possible-command-completions C-x ! List the possible completions of the text before  , treating it as a command name. dynamic-complete-history M-TAB Attempt completion on the text before  , comparing the text against lines from the history list for possible completion matches. dabbrev-expand Attempt menu completion on the text before point, comparing the text against lines from the history list for possible completion matches. complete-into-braces M-{ Perform filename completion and insert the list of possible completions enclosed within braces so the list is available to the shell (see the section " " above). start-kbd-macro C-x ( Begin saving the characters typed into the current keyboard macro. end-kbd-macro C-x ) Stop saving the characters typed into the current keyboard macro and store the definition. call-last-kbd-macro C-x e Re-execute the last keyboard macro defined, by making the characters in the macro appear as if typed at the keyboard. re-read-init-file C-x C-r Read in the contents of the   file, and incorporate any bindings or variable assignments found there. abort C-g Abort the current editing command and ring the terminal's bell (subject to the setting of bell-style). do-uppercase-version M-a, M-b, M-x, ... If the metafied character   is lowercase, run the command that is bound to the corresponding uppercase character. prefix-meta ESC Metafy the next character typed.   is equivalent to  . undo C-_, C-x C-u Incremental undo, separately remembered for each line. revert-line M-r Undo all changes made to this line. This is like executing the   command enough times to return the line to its initial state. tilde-expand M-& Perform tilde expansion on the current word. set-mark , M-<space> Set the mark to the point. If a numeric argument is supplied, the mark is set to that position. exchange-point-and-mark C-x C-x Swap the point with the mark. The current cursor position is set to the saved position, and the old cursor position is saved as the mark. character-search (C-] A character is read and   is moved to the next occurrence of that character. A negative count searches for previous occurrences. character-search-backward M-C-] A character is read and   is moved to the previous occurrence of that character. A negative count searches for subsequent occurrences. skip-csi-sequence Read enough characters to consume a multi-key sequence such as those defined for keys like   and  . Such sequences begin with a Control Sequence Indicator (CSI), usually  . If this sequence is bound to " ", keys producing such sequences will have no effect unless explicitly bound to a readline command, instead of inserting stray characters into the editing buffer. This is unbound by default, but usually bound to  . insert-comment M-# Without a numeric argument, the value of the readline comment-begin variable is inserted at the beginning of the current line. If a numeric argument is supplied, this command acts as a toggle: if the characters at the beginning of the line do not match the value of  , the value is inserted, otherwise the characters in   are deleted from the beginning of the line. In either case, the line is accepted as if a newline had been typed. The default value of   causes this command to make the current line a shell comment. If a numeric argument causes the comment character to be removed, the line will be executed by the shell. glob-complete-word M-g The word before   is treated as a pattern for pathname expansion, with an asterisk implicitly appended. This pattern is used to generate a list of matching file names for possible completions. glob-expand-word C-x * The word before   is treated as a pattern for pathname expansion, and the list of matching file names is inserted, replacing the word. If a numeric argument is supplied, an asterisk is appended before pathname expansion. glob-list-expansions C-x g The list of expansions that would have been generated by   is displayed, and the line is redrawn. If a numeric argument is supplied, an asterisk is appended before pathname expansion. dump-functions Print all of the functions and their key bindings to the readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an   file. dump-variables Print all of the  -able readline variables and their values to the readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an   file. dump-macros Print all of the readline key sequences bound to macros and the strings they output. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an   file. display-shell-version C-x C-v Display version information about the current instance of bash. When word completion is attempted for an argument to a command for which a completion specification (a  ) has been defined using the   builtin (see the section " " below), the programmable completion facilities are invoked. First, the command name is identified. If the command word is the empty string (completion attempted at the beginning of an empty line), any   defined with the   option to complete is used. If a   has been defined for that command, the   is used to generate the list of possible completions for the word. If the command word is a full pathname, a   for the full pathname is searched for first. If no   is found for the full pathname, an attempt is made to find a   for the portion following the final slash. If those searches do not result in a  , any   defined with the   option to complete is used as the default. Once a   has been found, it is used to generate the list of matching words. If a   is not found, the default bash completion as described above under Completing is performed. First, the actions specified by the   are used. Only matches which are prefixed by the word being completed are returned. When the   or   option is used for filename or directory name completion, the shell variable   is used to filter the matches. Any completions specified by a pathname expansion pattern to the   option are generated next. The words generated by the pattern need not match the word being completed. The   shell variable is not used to filter the matches, but the   variable is used. Next, the string specified as the argument to the   option is considered. The string is first split using the characters in the   special variable as delimiters. Shell quoting is honored. Each word is then expanded using brace expansion, tilde expansion, parameter and variable expansion, command substitution, and arithmetic expansion, as described above under the section " ." The results are split using the rules described above under the section " ." The results of the expansion are prefix-matched against the word being completed, and the matching words become the possible completions. After these matches have been generated, any shell function or command specified with the   and   options is invoked. When the command or function is invoked, the  ,  ,  , and   variables are assigned values as described above under the section " ." If a shell function is being invoked, the   and   variables are also set. When the function or command is invoked, the first argument is the name of the command whose arguments are being completed, the second argument is the word being completed, and the third argument is the word preceding the word being completed on the current command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in generating the matches. Any function specified with   is invoked first. The function may use any of the shell facilities, including the   builtin described below, to generate the matches. It must put the possible completions in the   array variable. Next, any command specified with the   option is invoked in an environment equivalent to command substitution. It should print a list of completions, one per line, to the standard output. Backslash may be used to escape a newline, if necessary. After all of the possible completions are generated, any filter specified with the   option is applied to the list. The filter is a pattern as used for pathname expansion; a & in the pattern is replaced with the text of the word being completed. A literal   may be escaped with a backslash; the backslash is removed before attempting a match. Any completion that matches the pattern will be removed from the list. A leading   negates the pattern; in this case any completion not matching the pattern will be removed. Finally, any prefix and suffix specified with the   and   options are added to each member of the completion list, and the result is returned to the readline completion code as the list of possible completions. If the previously-applied actions do not generate any matches, and the   option was supplied to complete when the   was defined, directory name completion is attempted. If the   option was supplied to complete when the   was defined, directory name completion is attempted and any matches are added to the results of the other actions. By default, if a   is found, whatever it generates is returned to the completion code as the full set of possible completions. The default bash completions are not attempted, and the readline default of filename completion is disabled. If the     option was supplied to complete when the   was defined, the bash default completions are attempted if the   generates no matches. If the   default option was supplied to complete when the   was defined, readline's default completion will be performed if the   (and, if attempted, the default bash completions) generate no matches. When a   indicates that directory name completion is desired, the programmable completion functions force readline to append a slash to completed names which are symbolic links to directories, subject to the value of the mark-directories readline variable, regardless of the setting of the   readline variable. There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with  . It's possible for shell functions executed as completion handlers to indicate that completion should be retried by returning an exit status of 124. If a shell function returns 124, and changes the   associated with the command on which completion is being attempted (supplied as the first argument when the function is executed), programmable completion restarts from the beginning, with an attempt to find a new   for that command. This allows a set of completions to be built dynamically as completion is attempted, rather than being loaded all at once. For instance, assuming that there is a library of  , each kept in a file corresponding to the name of the command, the following default completion function would load completions dynamically: When the   history option to the   builtin is enabled, the shell provides access to the command history, the list of commands previously typed. The value of the   variable is used as the number of commands to save in a history list. The text of the last   commands (default 500) is saved. The shell stores each command in the history list prior to parameter and variable expansion (see the section " " above) but after history expansion is performed, subject to the values of the shell variables   and  . On startup, the history is initialized from the file named by the variable   (default  ). The file named by the value of   is truncated, if necessary, to contain no more than the number of lines specified by the value of  . When the history file is read, lines beginning with the history comment character followed immediately by a digit are interpreted as timestamps for the preceding history line. These timestamps are optionally displayed depending on the value of the   variable. When an interactive shell exits, the last   lines are copied from the history list to  . If the   shell option is enabled (see the description of   under the section " " below), the lines are appended to the history file, otherwise the history file is overwritten. If   is unset, or if the history file is unwritable, the history is not saved. If the   variable is set, time stamps are written to the history file, marked with the history comment character, so they may be preserved across shell sessions. This uses the history comment character to distinguish timestamps from other history lines. After saving the history, the history file is truncated to contain no more than   lines. If   is not set, no truncation is performed. The builtin command   (see the " " section below) may be used to list or edit and re-execute a portion of the history list. The   builtin may be used to display or modify the history list and manipulate the history file. When using command-line editing, search commands are available in each editing mode that provide access to the history list. The shell allows control over which commands are saved on the history list. The   and   variables may be set to cause the shell to save only a subset of the commands entered. The   shell option, if enabled, causes the shell to attempt to save each line of a multi-line command in the same history entry, adding semicolons where necessary to preserve syntactic correctness. The   shell option causes the shell to save the command with embedded newlines instead of semicolons. See the description of the   builtin below under the section " " for information on  ting and  ting shell options. The shell supports a history expansion feature that is similar to the history expansion in  . This section describes what syntax features are available. This feature is enabled by default for interactive shells, and can be disabled using the   option to the   builtin command (see the section " " below). Non-interactive shells do not perform history expansion by default. History expansions introduce words from the history list into the input stream, making it easy to repeat commands, insert the arguments to a previous command into the current input line, or fix errors in previous commands quickly. History expansion is performed immediately after a complete line is read, before the shell breaks it into words. It takes place in two parts. The first is to determine which line from the history list to use during substitution. The second is to select portions of that line for inclusion into the current one. The line selected from the history is the event, and the portions of that line that are acted upon are words. Various modifiers are available to manipulate the selected words. The line is broken into words in the same fashion as when reading input, so that several metacharacter-separated words surrounded by quotes are considered one word. History expansions are introduced by the appearance of the history expansion character, which is   by default. Only backslash ( ) and single quotes can quote the history expansion character. Several characters inhibit history expansion if found immediately following the history expansion character, even if it is unquoted:  ,  ,  ,  , and  . If the   shell option is enabled,   will also inhibit expansion. Several shell options settable with the   builtin may be used to tailor the behavior of history expansion. If the   shell option is enabled (see the description of the   builtin below), and readline is being used, history substitutions are not immediately passed to the shell parser. Instead, the expanded line is reloaded into the readline editing buffer for further modification. If readline is being used, and the   shell option is enabled, a failed history substitution will be reloaded into the readline editing buffer for correction. The   option to the history builtin command may be used to see what a history expansion will do before using it. The   option to the history builtin may be used to add commands to the end of the history list without actually executing them, so that they are available for subsequent recall. The shell allows control of the various characters used by the history expansion mechanism (see the description of   above under the section " "). The shell uses the history comment character to mark history timestamps when writing the history file. An event designator is a reference to a command line entry in the history list. Unless the reference is absolute, events are relative to the current position in the history list. Start a history substitution, except when followed by a  ,  ,  ,   or   (when the   shell option is enabled using the   builtin). Refer to command line  . Refer to the current command minus  . Refer to the previous command. This is a synonym for ' '. Refer to the most recent command preceding the current position in the history list starting with string. Refer to the most recent command preceding the current position in the history list containing string. The trailing   may be omitted if string is followed immediately by a newline. Quick substitution. Repeat the previous command, replacing   with  . Equivalent to " " (see Modifiers below). The entire command line typed so far.  are used to select desired words from the event. A   separates the event specification from the word designator. It may be omitted if the word designator begins with a  ,  ,  ,  , or  . Words are numbered from the beginning of the line, with the first word being denoted by 0 (zero). Words are inserted into the current line separated by single spaces. The zeroth word. For the shell, this is the command word. The  th word. The first argument. That is, word  . The last argument. The word matched by the most recent ' ' search. A range of words; ' ' abbreviates ' '. All of the words but the zeroth. This is a synonym for ' '. It is not an error to use   if there is just one word in the event; the empty string is returned in that case. Abbreviates  . Abbreviates   like  , but omits the last word. If a word designator is supplied without an event specification, the previous command is used as the event. After the optional word designator, there may appear a sequence of one or more of the following  , each preceded by a ' '. Remove a trailing file name component, leaving only the head. Remove all leading file name components, leaving the tail. Remove a trailing suffix of the form  , leaving the basename. Remove all but the trailing suffix. Print the new command but do not execute it. Quote the substituted words, escaping further substitutions. Quote the substituted words as with  , but break into words at blanks and newlines. Substitute   for the first occurrence of   in the event line. Any delimiter can be used in place of  . The final delimiter is optional if it is the last character of the event line. The delimiter may be quoted in   and   with a single backslash. If   appears in  , it is replaced by  . A single backslash will quote the  . If   is null, it is set to the last   substituted, or, if no previous history substitutions took place, the last string in a   search. Repeat the previous substitution. Cause changes to be applied over the entire event line. This is used in conjunction with ' ' (e.g., ' ') or ' '. If used with ' ', any delimiter can be used in place of  , and the final delimiter is optional if it is the last character of the event line. An   may be used as a synonym for  . Apply the following ' ' modifier once to each word in the event line. Unless otherwise noted, each builtin command documented in this section as accepting options preceded by   accepts   to signify the end of the options. The  ,  ,  , and   builtins do not accept options and do not treat   specially. The  ,  ,  ,  ,  , and   builtins accept and process arguments beginning with   without requiring  . Other builtins that accept arguments but are not specified as accepting options interpret arguments beginning with   as invalid options and require   to prevent this interpretation.  [ ] No effect; the command does nothing beyond expanding arguments and performing any specified redirections. A zero exit code is returned.    [ ]    [ ] Read and execute commands from   in the current shell environment and return the exit status of the last command executed from  . If   does not contain a slash, file names in   are used to find the directory containing  . The file searched for in   need not be executable. When bash is not in posix mode, the current directory is searched if no file is found in  . If the   option to the   builtin command is turned off, the   is not searched. If any arguments are supplied, they become the positional parameters when filename is executed. Otherwise the positional parameters are unchanged. The return status is the status of the last command exited within the script (0 if no commands are executed), and   if   is not found or cannot be read.  [-p] [ [= ] ...]  with no arguments or with the   option prints the list of aliases in the form alias   on standard output. When arguments are supplied, an alias is defined for each name whose value is given. A trailing space in value causes the next word to be checked for alias substitution when the alias is expanded. For each name in the argument list for which no value is supplied, the name and value of the alias is printed. Alias returns   unless a name is given for which no alias has been defined.  [  ...] Resume each suspended job   in the background, as if it had been started with  . If   is not present, the shell's notion of the current job is used.   returns 0 unless run when job control is disabled or, when run with job control enabled, any specified   was not found or was started without job control.  [   ] [ ]  [   ] [   ] [   ] [   ]  [   ]     [   ]     [   ]    Display current readline key and function bindings, bind a key sequence to a readline function or macro, or set a readline variable. Each non-option argument is a command as it would appear in  , but each binding or command must be passed as a separate argument; e.g., ' '. Options, if supplied, have the following meanings:   Use   as the keymap to be affected by the subsequent bindings. Acceptable   names are  ,  ,  ,  ,  ,  ,  , and  .   is equivalent to  ;   is equivalent to  . List the names of all readline functions. Display readline function names and bindings in such a way that they can be re-read. List current readline function names and bindings. Display readline key sequences bound to macros and the strings they output in such a way that they can be re-read. Display readline key sequences bound to macros and the strings they output. Display readline variable names and values in such a way that they can be re-read. List current readline variable names and values.   Read key bindings from  .   Query about which keys invoke the named function.   Unbind all keys bound to the named function.   Remove any current binding for  .   Cause shell-command to be executed whenever   is entered. When   is executed, the shell sets the   variable to the contents of the readline line buffer and the   variable to the current location of the insertion point. If the executed command changes the value of   or  , those new values will be reflected in the editing state. The return value is 0 unless an unrecognized option is given or an error occurred.  [ ] Exit from within a  ,  ,  , or   loop. If   is specified, break   levels.   must be ≥ 1. If   is greater than the number of enclosing loops, all enclosing loops are exited. The return value is 0 unless   is not greater than or equal to 1.    [ ] Execute the specified shell builtin, passing it arguments, and return its exit status. This is useful when defining a function whose name is the same as a shell builtin, retaining the functionality of the builtin within the function. The   builtin is commonly redefined this way. The return status is   if shell-builtin is not a shell builtin command.  [ ] Returns the context of any active subroutine call (a shell function or a script executed with the   or   builtins). Without  , caller displays the line number and source filename of the current subroutine call. If a non-negative integer is supplied as  ,   displays the line number, subroutine name, and source file corresponding to that position in the current execution call stack. This extra information may be used, for example, to print a stack trace. The current frame is frame 0. The return value is 0 unless the shell is not executing a subroutine call or   does not correspond to a valid position in the call stack.  [ |[  [ ]]] [ ] Change the current directory to  . The variable   is the default dir. The variable   defines the search path for the directory containing  . Alternative directory names in   are separated by a colon ( ). A null directory name in   is the same as the current directory, i.e., " ". If   begins with a slash ( ), then   is not used. The   option says to use the physical directory structure instead of following symbolic links (see also the   option to the   builtin command); the   option forces symbolic links to be followed. If the   option is supplied with  , and the current working directory cannot be successfully determined after a successful directory change,   will return an unsuccessful status. An argument of   is equivalent to  . If a non-empty directory name from   is used, or if   is the first argument, and the directory change is successful, the absolute pathname of the new working directory is written to the standard output. The return value is true if the directory was successfully changed; false otherwise.  [ ]  [  ...] Run   with   suppressing the normal shell function lookup. Only builtin commands or commands found in the   are executed. If the   option is given, the search for command is performed using a default value for   that is guaranteed to find all of the standard utilities. If either the   or   option is supplied, a description of command is printed. The   option causes a single word indicating the command or file name used to invoke command to be displayed; the   option produces a more verbose description. If the   or   option is supplied, the exit status is 0 if command was found, and 1 if not. If neither option is supplied and an error occurred or command cannot be found, the exit status is 127. Otherwise, the exit status of the command builtin is the exit status of command.  [ ] [ ] Generate possible completion matches for   according to the options, which may be any option accepted by the   builtin with the exception of   and  , and write the matches to the standard output. When using the   or   options, the various shell variables set by the programmable completion facilities, while available, will not have useful values. The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the same flags. If word is specified, only those completions matching word will be displayed. The return value is true unless an invalid option is supplied, or no matches were generated.  [ ] [   ] [ ] [   ] [   ] [   ] [   ] [   ] [   ] [   ] [   ]   [  ...]    [ ] [  ...] Specify how arguments to each   should be completed. If the   option is supplied, or if no options are supplied, existing completion specifications are printed in a way that allows them to be reused as input. The   option removes a completion specification for each  , or, if no  s are supplied, all completion specifications. The   option indicates that the remaining options and actions should apply to the "default" command completion; that is, completion attempted on a command for which no completion has previously been defined. The   option indicates that the remaining options and actions should apply to "empty" command completion; that is, completion attempted on a blank line. The process of applying these completion specifications when word completion is attempted is described above under the section " ." Other options, if specified, have the following meanings. The arguments to the  ,  , and   options (and, if necessary, the   and   options) should be quoted to protect them from expansion before the   builtin is invoked.   The   controls several aspects of the compspec's behavior beyond the simple generation of completions. The   may be one of: : Perform the rest of the default bash completions if the compspec generates no matches. : Use readline's default filename completion if the compspec generates no matches. : Perform directory name completion if the compspec generates no matches. : Tell readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting special characters, or suppressing trailing spaces). Intended to be used with shell functions. : Tell readline not to append a space (the default) to words completed at the end of the line. : After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other actions.   The   may be one of the following to generate a list of possible completions: : Alias names. May also be specified as  . : Array variable names. : Readline key binding names. : Names of shell builtin commands. May also be specified as  . : Command names. May also be specified as  . : Directory names. May also be specified as  . : Names of disabled shell builtins. : Names of enabled shell builtins. : Names of exported shell variables. May also be specified as  . : File names. May also be specified as  . : Names of shell functions. : Group names. May also be specified as  . : Help topics as accepted by the help builtin. : Hostnames, as taken from the file specified by the HOSTFILE shell variable. : Job names, if job control is active. May also be specified as  . : Shell reserved words. May also be specified as  . : Names of running jobs, if job control is active. : Service names. May also be specified as  . : Valid arguments for the   option to the set builtin. : Shell option names as accepted by the   builtin. : Signal names. : Names of stopped jobs, if job control is active. : User names. May also be specified as  . : Names of all shell variables. May also be specified as  .    is executed in a subshell environment, and its output is used as the possible completions.   The shell function   is executed in the current shell environment. When it finishes, the possible completions are retrieved from the value of the   array variable.   The pathname expansion pattern   is expanded to generate the possible completions.    is added at the beginning of each possible completion after all other options have been applied.    is appended to each possible completion after all other options have been applied.   The   is split using the characters in the IFS special variable as delimiters, and each resultant word is expanded. The possible completions are the members of the resultant list which match the word being completed.    is a pattern as used for pathname expansion. It is applied to the list of possible completions generated by the preceding options and arguments, and each completion matching   is removed from the list. A leading   in   negates the pattern; in this case, any completion not matching   is removed. The return value is true unless an invalid option is supplied, an option other than   or   is supplied without a   argument, an attempt is made to remove a completion specification for a   for which no specification exists, or an error occurs adding a completion specification.  [   ] [ ] [   ] [ ] Modify completion options for each name according to the  , or for the currently-executing completion if no   are supplied. If no   are given, display the completion options for each name or the current completion. The possible values of   are those valid for the   builtin described above. The   option indicates that the remaining options should apply to the "default" command completion; that is, completion attempted on a command for which no completion has previously been defined. The   option indicates that the remaining options should apply to "empty" command completion; that is, completion attempted on a blank line. The return value is true unless an invalid option is supplied, an attempt is made to modify the options for a name for which no completion specification exists, or an output error occurs.  [ ] Resume the next iteration of the enclosing  ,  ,  , or   loop. If   is specified, resume at the  th enclosing loop.   must be ≥ 1. If   is greater than the number of enclosing loops, the last enclosing loop (the "top-level" loop) is resumed. The return value is 0 unless   is not greater than or equal to 1.  [ ] [ ] [ [= ] ...]  [ ] [ ] [ [= ] ...] Declare variables and/or give them attributes. If no   are given then display the values of variables. The   option displays the attributes and values of each  . When   is used with   arguments, additional options are ignored. When   is supplied without   arguments, it displays the attributes and values of all variables having the attributes specified by the additional options. If no other options are supplied with  ,   displays the attributes and values of all shell variables. The   option will restrict the display to shell functions. The   option inhibits the display of function definitions; only the function name and attributes are printed. If the extdebug shell option is enabled using shopt, the source file name and line number where the function is defined are displayed as well. The   option implies  . The   option forces variables to be created or modified at the global scope, even when   is executed in a shell function. It is ignored in all other cases. The following options can be used to restrict output to variables with the specified attribute or to give variables attributes: Each name is an indexed array variable (see the section " " above). Each name is an associative array variable (see the section " " above). Use function names only. The variable is treated as an integer; arithmetic evaluation (see the section " " above) is performed when the variable is assigned a value. When the variable is assigned a value, all uppercase characters are converted to lowercase. The uppercase attribute is disabled. Make names readonly. These names cannot then be assigned values by subsequent assignment statements or unset. Give each name the trace attribute. Traced functions inherit the DEBUG and RETURN traps from the calling shell. The trace attribute has no special meaning for variables. When the variable is assigned a value, all lowercase characters are converted to uppercase. The lowercase attribute is disabled. Mark names for export to subsequent commands via the environment. Using '+' instead of '-' turns off the attribute instead, with the exceptions that   may not be used to destroy an array variable and   will not remove the readonly attribute. When used in a function, makes each name local, as with the local command, unless the   option is supplied, If a variable name is followed by  , the value of the variable is set to  . The return value is 0 unless an invalid option is encountered, an attempt is made to define a function using " ", an attempt is made to assign a value to a readonly variable, an attempt is made to assign a value to an array variable without using the compound assignment syntax (see the section " " above), one of the names is not a valid shell variable name, an attempt is made to turn off readonly status for a readonly variable, an attempt is made to turn off array status for an array variable, or an attempt is made to display a non-existent function with  .  [ ] [ ] [ ] Without options, displays the list of currently remembered directories. The default display is on a single line with directory names separated by spaces. Directories are added to the list with the   command; the   command removes entries from the list. Displays the nth entry counting from the left of the list shown by   when invoked without options, starting with zero. Displays the nth entry counting from the right of the list shown by   when invoked without options, starting with zero. Clears the directory stack by deleting all of the entries. Produces a longer listing; the default listing format uses a tilde to denote the home directory. Print the directory stack with one entry per line. Print the directory stack with one entry per line, prefixing each entry with its index in the stack. The return value is 0 unless an invalid option is supplied or   indexes beyond the end of the directory stack.  [ ] [ ] [  ...] Without options, each   is removed from the table of active jobs. If   is not present, and neither   nor   is supplied, the shell's notion of the current job is used. If the   option is given, each   is not removed from the table, but is marked so that   is not sent to the job if the shell receives a  . If no   is present, and neither the   nor the   option is supplied, the current job is used. If no   is supplied, the   option means to remove or mark all jobs; the   option without a   argument restricts operation to running jobs. The return value is 0 unless a   does not specify a valid job.  [ ] [  ...] Output the  , separated by spaces, followed by a newline. The return status is always 0. If   is specified, the trailing newline is suppressed. If the   option is given, interpretation of the following backslash-escaped characters is enabled. The   option disables the interpretation of these escape characters, even on systems where they are interpreted by default. The   shell option may be used to dynamically determine whether or not   expands these escape characters by default.   does not interpret   to mean the end of options.   interprets the following escape sequences: : alert (bell) : backspace : suppress further output ,  : an escape character : form feed : new line : carriage return : horizontal tab : vertical tab : backslash : the eight-bit character whose value is the octal value nnn (zero to three octal digits) : the eight-bit character whose value is the hexadecimal value HH (one or two hex digits) : the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits) : the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)  [ ] [ ] [   ] [  ...] Enable and disable builtin shell commands. Disabling a builtin allows a disk command which has the same name as a shell builtin to be executed without specifying a full pathname, even though the shell normally searches for builtins before disk commands. If   is used, each name is disabled; otherwise, names are enabled. For example, to use the test binary found via the PATH instead of the shell builtin version, run "enable   test". The   option means to load the new builtin command name from shared object filename, on systems that support dynamic loading. The   option will delete a builtin previously loaded with  . If no name arguments are given, or if the   option is supplied, a list of shell builtins is printed. With no other option arguments, the list consists of all enabled shell builtins. If   is supplied, only disabled builtins are printed. If   is supplied, the list printed includes all builtins, with an indication of whether or not each is enabled. If   is supplied, the output is restricted to the POSIX special builtins. The return value is 0 unless a name is not a shell builtin or there is an error loading a new builtin from a shared object.  [  ...] The  s are read and concatenated together into a single command. This command is then read and executed by the shell, and its exit status is returned as the value of  . If there are no  s, or only null arguments,   returns 0.  [ ] [   ] [  [ ]] If   is specified, it replaces the shell. No new process is created. The arguments become the arguments to  . If the   option is supplied, the shell places a dash at the beginning of the zeroth argument passed to command. This is what   does. The   option causes command to be executed with an empty environment. If   is supplied, the shell passes   as the zeroth argument to the executed command. If   cannot be executed for some reason, a non-interactive shell exits, unless the shell option   is enabled, in which case it returns failure. An interactive shell returns failure if the file cannot be executed. If   is not specified, any redirections take effect in the current shell, and the return status is 0. If there is a redirection error, the return status is 1.  [ ] Cause the shell to exit with a status of n. If n is omitted, the exit status is that of the last command executed. A trap on EXIT is executed before the shell terminates.  [ ] [ [= ]] ...   The supplied  s are marked for automatic export to the environment of subsequently executed commands. If the   option is given, the names refer to functions. If no  s are given, or if the   option is supplied, a list of all names that are exported in this shell is printed. The   option causes the export property to be removed from each name. If a variable name is followed by  , the value of the variable is set to  .   returns an exit status of 0 unless an invalid option is encountered, one of the  s is not a valid shell variable name, or   is supplied with a   that is not a function.  [   ] [ ] [ ] [ ]    [ = ] [ ] Fix Command. In the first form, a range of commands from   to   is selected from the history list. The   and   may be specified as a string (to locate the last command beginning with that string) or as a number (an index into the history list, where a negative number is used as an offset from the current command number). If   is not specified it is set to the current command for listing (so that " " prints the last 10 commands) and to   otherwise. If   is not specified it is set to the previous command for editing and -16 for listing. The   option suppresses the command numbers when listing. The   option reverses the order of the commands. If the   option is given, the commands are listed on standard output. Otherwise, the editor given by   is invoked on a file containing those commands. If   is not given, the value of the   variable is used, and the value of   if   is not set. If neither variable is set,   is used. When editing is complete, the edited commands are echoed and executed. In the second form, command is re-executed after each instance of   is replaced by  . A useful alias to use with this is " ", so that typing " " runs the last command beginning with " " and typing " " re-executes the last command. If the first form is used, the return value is 0 unless an invalid option is encountered or first or last specify history lines out of range. If the   option is supplied, the return value is the value of the last command executed or failure if an error occurs with the temporary file of commands. If the second form is used, the return status is that of the command re-executed, unless   does not specify a valid history line, in which case   returns failure.  [ ] Resume   in the foreground, and make it the current job. If   is not present, the shell's notion of the current job is used. The return value is that of the command placed into the foreground, or failure if run when job control is disabled or, when run with job control enabled, if   does not specify a valid job or   specifies a job that was started without job control.      [ ]  is used by shell procedures to parse positional parameters. The   contains the option characters to be recognized; if a character is followed by a colon, the option is expected to have an argument, which should be separated from it by white space. The colon and question mark characters may not be used as option characters. Each time it is invoked,   places the next option in the shell variable name, initializing name if it does not exist, and the index of the next argument to be processed into the variable  .   is initialized to 1 each time the shell or a shell script is invoked. When an option requires an argument,   places that argument into the variable  . The shell does not reset   automatically; it must be manually reset between multiple calls to   within the same shell invocation if a new set of parameters is to be used. When the end of options is encountered,   exits with a return value greater than zero.   is set to the index of the first non-option argument, and name is set to  .  normally parses the positional parameters, but if more arguments are given in  ,   parses those instead.  can report errors in two ways. If the first character of   is a colon, silent error reporting is used. In normal operation diagnostic messages are printed when invalid options or missing option arguments are encountered. If the variable   is set to 0, no error messages will be displayed, even if the first character of   is not a colon. If an invalid option is seen,   places   into   and, if not silent, prints an error message and unsets  . If   is silent, the option character found is placed in   and no diagnostic message is printed. If a required argument is not found, and   is not silent, a question mark ( ) is placed in  ,   is unset, and a diagnostic message is printed. If   is silent, then a colon ( ) is placed in name and   is set to the option character found.  returns true if an option, specified or unspecified, is found. It returns false if the end of options is encountered or an error occurs.  [ ] [   ] [ ] [ ] Each time   is invoked, the full pathname of the command name is determined by searching the directories in   and remembered. Any previously-remembered pathname is discarded. If the   option is supplied, no path search is performed, and filename is used as the full file name of the command. The   option causes the shell to forget all remembered locations. The   option causes the shell to forget the remembered location of each name. If the   option is supplied, the full pathname to which each name corresponds is printed. If multiple name arguments are supplied with  , the name is printed before the hashed full pathname. The   option causes output to be displayed in a format that may be reused as input. If no arguments are given, or if only   is supplied, information about remembered commands is printed. The return status is true unless a name is not found or an invalid option is supplied.  [ ] [ ] Display helpful information about builtin commands. If   is specified, help gives detailed help on all commands matching  ; otherwise help for all the builtins and shell control structures is printed.   Display a short description of each pattern   Display the description of each pattern in a  -like format   Display only a short usage synopsis for each pattern The return status is 0 unless no command matches  .  [ ]          [ ]      [  ...]      [  ...] With no options, display the command history list with line numbers. Lines listed with a   have been modified. An argument of   lists only the last   lines. If the shell variable   is set and not null, it is used as a format string for   to display the time stamp associated with each displayed history entry. No intervening blank is printed between the formatted time stamp and the history line. If filename is supplied, it is used as the name of the history file; if not, the value of   is used. Options, if supplied, have the following meanings: : Clear the history list by deleting all the entries.   : Delete the history entry at position  . : Append the "new" history lines (history lines entered since the beginning of the current bash session) to the history file. : Read the history lines not already read from the history file into the current history list. These are lines appended to the history file since the beginning of the current bash session. : Read the contents of the history file and use them as the current history. : Write the current history to the history file, overwriting the history file's contents. : Perform history substitution on the following  s and display the result on the standard output. Does not store the results in the history list. Each arg must be quoted to disable normal history expansion. : Store the  s in the history list as a single entry. The last command in the history list is removed before the  s are added. If the   variable is set, the time stamp information associated with each history entry is written to the history file, marked with the history comment character. When the history file is read, lines beginning with the history comment character followed immediately by a digit are interpreted as timestamps for the previous history line. The return value is 0 unless an invalid option is encountered, an error occurs while reading or writing the history file, an invalid offset is supplied as an argument to  , or the history expansion supplied as an argument to   fails.  [ ] [   ... ]      [   ... ] The first form lists the active jobs. The options have the following meanings: : List process IDs in addition to the normal information. : Display information only about jobs that have changed status since the user was last notified of their status. : List only the process ID of the job's process group leader. : Restrict output to running jobs. : Restrict output to stopped jobs. If   is given, output is restricted to information about that job. The return status is 0 unless an invalid option is encountered or an invalid   is supplied. If the   option is supplied, jobs replaces any   found in command or  s with the corresponding process group ID, and executes command passing it  s, returning its exit status.  [    |     | - ] [  |  ] ...    [  |  ] Send the signal named by   or   to the processes named by pid or jobspec. The   is either a case-insensitive signal name such as   (with or without the SIG prefix) or a signal number;   is a signal number. If   is not present, then   is assumed. An argument of   lists the signal names. If any arguments are supplied when   is given, the names of the signals corresponding to the arguments are listed, and the return status is 0. The   argument to   is a number specifying either a signal number or the exit status of a process terminated by a signal. The kill returns true if at least one signal was successfully sent, or false if an error occurs or an invalid option is encountered.    [  ...] Each   is an arithmetic expression to be evaluated (see the section " " above). If the last   evaluates to  , let returns  ;   is returned otherwise.  [ ] [ [= ] ...] For each argument, a local variable named   is created, and assigned value. The   can be any of the options accepted by  . When   is used within a function, it causes the variable   to have a visible scope restricted to that function and its children. With no operands,   writes a list of local variables to the standard output. It is an error to use   when not within a function. The return status is   unless   is used outside a function, an invalid   is supplied, or   is a readonly variable. Exit a login shell.  [   ] [   ] [   ] [ ] [   ] [   ] [   ] [ ]  [   ] [   ] [   ] [ ] [   ] [   ] [   ] [ ] Read lines from the standard input into the indexed array variable  , or from file descriptor fd if the   option is supplied. The variable   is the default  . Options, if supplied, have the following meanings: : Copy at most   lines. If   is 0, all lines are copied. : Begin assigning to   at index  . The default index is 0. : Discard the first   lines read. : Remove a trailing newline from each line read. : Read lines from file descriptor fd instead of the standard input. : Evaluate   each time   lines are read. The   option specifies  . : Specify the number of lines read between each call to  . If   is specified without  , the default   is 5000. When   is evaluated, it is supplied the index of the next   element to be assigned and the line to be assigned to that element as additional arguments. The   is evaluated after the line is read but before the   element is assigned. If not supplied with an explicit  ,   will clear   before assigning to it.  returns successfully unless an invalid option or option argument is supplied,   is invalid or unassignable, or if   is not an indexed array.  [ ] [ ] [ ] Removes entries from the directory stack. With no arguments, removes the top directory from the stack, and performs a   to the new top directory. Arguments, if supplied, have the following meanings: : Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.  Removes the  th entry counting from the left of the list shown by  , starting with zero. For example: " " removes the first directory, " " the second.  Removes the  th entry counting from the right of the list shown by  , starting with zero. For example: " " removes the last directory, " " the next to last. If the   command is successful, a   is performed as well, and the return status is 0.   returns false if an invalid option is encountered, the directory stack is empty, a non-existent directory stack entry is specified, or the directory change fails.  [   ]   [ ] Write the formatted   to the standard output under the control of the  . The   option causes the output to be assigned to the variable var rather than being printed to the standard output. The format is a character string which contains three types of objects: plain characters, which are copied to standard output, character escape sequences, which are converted and copied to the standard output, and format specifications, each of which causes printing of the next successive argument. In addition to the   format specifications,   interprets the following extensions:  causes   to expand backslash escape sequences in the corresponding argument (except that   terminates output, backslashes in  ,  , and   are not removed, and   escapes beginning with   may contain up to four digits).  causes   to output the corresponding argument in a format that can be reused as shell input.  causes   to output the date-time string resulting from using   as a format string for  . The corresponding argument is an integer representing the number of seconds since the  . Two special argument values may be used:   represents the current time, and   represents the time the shell was invoked. Arguments to non-string format specifiers are treated as C constants, except that a leading plus or minus sign is allowed, and if the leading character is a single or double quote, the value is the ASCII value of the following character. The format is reused as necessary to consume all of the arguments. If the format requires more arguments than are supplied, the extra format specifications behave as if a zero value or null string, as appropriate, had been supplied. The return value is zero on success, non-zero on failure.  [ ] [ ] [ ]  [ ] [ ] Adds a directory to the top of the directory stack, or rotates the stack, making the new top of the stack the current working directory. With no arguments, exchanges the top two directories and returns 0, unless the directory stack is empty. Arguments, if supplied, have the following meanings: : Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated. : Rotates the stack so that the nth directory (counting from the left of the list shown by  , starting with zero) is at the top. : Rotates the stack so that the nth directory (counting from the right of the list shown by  , starting with zero) is at the top. : Adds   to the directory stack at the top, making it the new current working directory. If the   command is successful, a   is performed as well. If the first form is used,   returns 0 unless the   to   fails. With the second form,   returns 0 unless the directory stack is empty, a non-existent directory stack element is specified, or the directory change to the specified new current directory fails.  [ ] Print the   of the  . The pathname printed contains no   if the   option is supplied or the   physical option to the   builtin command is enabled. If the   option is used, the pathname printed may contain symbolic links. The return status is 0 unless an error occurs while reading the name of the current directory or an invalid option is supplied.  [ ] [   ] [   ] [   ] [   ] [   ] [   ] [   ] [   ] [  ...] One line is read from the standard input, or from the file descriptor   supplied as an argument to the   option, and the first word is assigned to the first name, the second word to the second name, and so on, with leftover words and their intervening separators assigned to the last name. If there are fewer words read from the input stream than names, the remaining names are assigned empty values. The characters in IFS are used to split the line into words. The backslash character ( ) may be used to remove any special meaning for the next character read and for line continuation. Options, if supplied, have the following meanings:   : The words are assigned to sequential indices of the array variable  , starting at 0. The   is unset before any new values are assigned. Other name arguments are ignored.   : The first character of   is used to terminate the input line, rather than newline. : If the standard input is coming from a terminal, readline (see "  above) is used to obtain the line. Readline uses the current (or default, if line editing was not previously active) editing settings.   : If readline is being used to read the line, text is placed into the editing buffer before editing begins.   : read returns after reading   characters rather than waiting for a complete line of input, but honor a delimiter if fewer than   characters are read before the delimiter.   : read returns after reading exactly   characters rather than waiting for a complete line of input, unless EOF is encountered or read times out. Delimiter characters encountered in the input are not treated specially and do not cause read to return until   characters are read.   : Display prompt on standard error, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming from a terminal. : Backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation. : Silent mode. If input is coming from a terminal, characters are not echoed.    Cause read to time out and return failure if a complete line of input is not read within timeout seconds. The timeout may be a decimal number with a fractional portion following the decimal point. This option is only effective if read is reading input from a terminal, pipe, or other special file; it has no effect when reading from regular files. If timeout is 0, read returns success if input is available on the specified file descriptor, failure otherwise. The exit status is greater than 128 if the timeout is exceeded.   : Read input from file descriptor  . If no names are supplied, the line read is assigned to the variable REPLY. The return code is zero, unless end-of-file is encountered, read times out (in which case the return code is greater than 128), or an invalid file descriptor is supplied as the argument to  .  [ ] [ ] [ [= ] ...] The given  s are marked readonly; the values of these names may not be changed by subsequent assignment. If the   option is supplied, the functions corresponding to the names are so marked. The   option restricts the variables to indexed arrays; the   option restricts the variables to associative arrays. If both options are supplied,   takes precedence. If no   arguments are given, or if the   option is supplied, a list of all readonly names is printed. The other options may be used to restrict the output to a subset of the set of readonly names. The   option causes output to be displayed in a format that may be reused as input. If a variable   is followed by = , the value of the variable is set to  . The return status is 0 unless an invalid option is encountered, one of the  s is not a valid shell variable name, or   is supplied with a   that is not a function.  [ ] Causes a function to exit with the return value specified by  . If   is omitted, the return status is that of the last command executed in the function body. If used outside a function, but during execution of a script by the   ( ) command, it causes the shell to stop executing that script and return either   or the exit status of the last command executed within the script as the exit status of the script. If used outside a function and not during execution of a script by  , the return status is false. Any command associated with the RETURN trap is executed before execution resumes after the function or script.  [ ] [   ] [  ...]  [ ] [   ] [  ...] Without options, the name and value of each shell variable are displayed in a format that can be reused as input for setting or resetting the currently-set variables. Read-only variables cannot be reset. In posix mode, only shell variables are listed. The output is sorted according to the current locale. When options are specified, they set or unset shell attributes. Any arguments remaining after option processing are treated as values for the positional parameters and are assigned, in order, to  . Options, if specified, have the following meanings: : Automatically mark variables and functions that are modified or created for export to the environment of subsequent commands. : Report the status of terminated background jobs immediately, rather than before the next primary prompt. This is effective only when job control is enabled.  Exit immediately if a pipeline (which may consist of a single simple command), a subshell command enclosed in parentheses, or one of the commands executed as part of a command list enclosed by braces (see " " above) exits with a non-zero status. The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the   or   reserved words, part of any command executed in a   or   list except the command following the final   or  , any command in a pipeline but the last, or if the command's return value is being inverted with  . A trap on ERR, if set, is executed before the shell exits. This option applies to the shell environment and each subshell environment separately (see the section " " above), and may cause subshells to exit before executing all the commands in the subshell. : Disable pathname expansion. : Remember the location of commands as they are looked up for execution. This is enabled by default. : All arguments in the form of assignment statements are placed in the environment for a command, not just those that precede the command name. : Monitor mode. Job control is enabled. This option is on by default for interactive shells on systems that support it (see " ," above). Background processes run in a separate process group and a line containing their exit status is printed upon their completion. : Read commands but do not execute them. This may be used to check a shell script for syntax errors. This is ignored by interactive shells.   : The   can be one of the following: : Same as  . : Same as  . : Use an emacs-style command line editing interface. This is enabled by default when the shell is interactive, unless the shell is started with the   option. This also affects the editing interface used for read  . : Same as  . : Same as  . : Same as  . : Same as  . : Same as  . : Enable command history, as described above under HISTORY. This option is on by default in interactive shells. : The effect is as if the shell command " " had been executed (see " ," above). : Same as  . : Same as  . : Same as  . : Same as  . : Same as  . : Currently ignored. : Same as  . : Same as  . : Same as  . : Same as  . : If set, the return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands in the pipeline exit successfully. This option is disabled by default. posix Change the behavior of bash where the default operation differs from the POSIX standard to match the standard (posix mode). : Same as  . : Same as  . : Use a vi-style command line editing interface. This also affects the editing interface used for read  . : Same as  . If   is supplied with no  , the values of the current options are printed. If   is supplied with no  , a series of   commands to recreate the current option settings is displayed on the standard output. : Turn on privileged mode. In this mode, the   and   files are not processed, shell functions are not inherited from the environment, and the  ,  ,  , and   variables, if they appear in the environment, are ignored. If the shell is started with the effective user (group) id not equal to the real user (group) id, and the   option is not supplied, these actions are taken and the effective user id is set to the real user id. If the   option is supplied at startup, the effective user id is not reset. Turning this option off causes the effective user and group ids to be set to the real user and group ids. : Exit after reading and executing one command. : Treat unset variables and parameters other than the special parameters " " and " " as an error when performing parameter expansion. If expansion is attempted on an unset variable or parameter, the shell prints an error message, and, if not interactive, exits with a non-zero status. : Print shell input lines as they are read. : After expanding each  ,   command,   command,   command, or arithmetic   command, display the expanded value of  , followed by the command and its expanded arguments or associated word list. : The shell performs brace expansion (see   above). This is on by default. : If set, bash does not overwrite an existing file with the  ,  , and   redirection operators. This may be overridden when creating output files by using the redirection operator   instead of  . : If set, any trap on ERR is inherited by shell functions, command substitutions, and commands executed in a subshell environment. The ERR trap is normally not inherited in such cases. : Enable   style history substitution. This option is on by default when the shell is interactive. : If set, the shell does not follow symbolic links when executing commands such as   that change the current working directory. It uses the physical directory structure instead. By default, bash follows the logical chain of directories when performing commands which change the current directory.  If set, any traps on DEBUG and RETURN are inherited by shell functions, command substitutions, and commands executed in a subshell environment. The DEBUG and RETURN traps are normally not inherited in such cases.  If no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters are set to the  , even if some of them begin with a  .  Signal the end of options, cause all remaining   to be assigned to the positional parameters. The   and   options are turned off. If there are no  , the positional parameters remain unchanged. The options are off by default unless otherwise noted. Using   rather than   causes these options to be turned off. The options can also be specified as arguments to an invocation of the shell. The current set of options may be found in  . The return status is always true unless an invalid option is encountered.  [ ] The positional parameters from  +1 ... are renamed to   .... Parameters represented by the numbers   down to  - +1 are unset. The   must be a non-negative number less than or equal to  . If   is 0, no parameters are changed. If   is not given, it is assumed to be 1. If   is greater than  , the positional parameters are not changed. The return status is greater than zero if   is greater than   or less than zero; otherwise 0.  [ ] [ ] [  ...] Toggle the values of variables controlling optional shell behavior. With no options, or with the   option, a list of all settable options is displayed, with an indication of whether or not each is set. The   option causes output to be displayed in a form that may be reused as input. Other options have the following meanings: : Enable (set) each  . : Disable (unset) each  . : Suppresses normal output (quiet mode); the return status indicates whether the   is set or unset. If multiple   arguments are given with  , the return status is zero if all  s are enabled; non-zero otherwise. : Restricts the values of   to be those defined for the   option to the set builtin. If either   or   is used with no   arguments, the display is limited to those options that are set or unset, respectively. Unless otherwise noted, the shopt options are disabled (unset) by default. The return status when listing options is zero if all  s are enabled, non-zero otherwise. When setting or unsetting options, the return status is zero unless an   is not a valid shell option. The list of   options is: : If set, a command name that is the name of a directory is executed as if it were the argument to the   command. This option is only used by interactive shells. : If set, an argument to the   builtin command that is not a directory is assumed to be the name of a variable whose value is the directory to change to. : If set, minor errors in the spelling of a directory component in a   command will be corrected. The errors checked for are transposed characters, a missing character, and one character too many. If a correction is found, the corrected file name is printed, and the command proceeds. This option is only used by interactive shells. : If set, bash checks that a command found in the hash table exists before trying to execute it. If a hashed command no longer exists, a normal path search is performed. : If set, bash lists the status of any stopped and running jobs before exiting an interactive shell. If any jobs are running, this causes the exit to be deferred until a second exit is attempted without an intervening command (see the section " "). The shell always postpones exiting if any jobs are stopped. : If set, bash checks the window size after each command and, if necessary, updates the values of LINES and COLUMNS. : If set, bash attempts to save all lines of a multiple-line command in the same history entry. This allows easy re-editing of multi-line commands. : If set, bash changes its behavior to that of version 3.1 with respect to quoted arguments to the   conditional command's   operator. : If set, bash changes its behavior to that of version 3.2 with respect to locale-specific string comparison when using the   conditional command's   and   operators. Bash versions before bash-4.1 use ASCII collation and  ; bash-4.1 and later use the current locale's collation sequence and  . : If set, bash changes its behavior to that of version 4.0 with respect to locale-specific string comparison when using the   conditional command's   and   operators (see previous item) and the effect of interrupting a command list. : If set, bash, when in posix mode, treats a single quote in a double-quoted parameter expansion as a special character. The single quotes must match (an even number) and the characters between the single quotes are considered quoted. This is the behavior of posix mode through version 4.1. The default bash behavior remains as in previous versions. : If set, bash replaces directory names with the results of word expansion when performing filename completion. This changes the contents of the readline editing buffer. If not set, bash attempts to preserve what the user typed. : If set, bash attempts spelling correction on directory names during word completion if the directory name initially supplied does not exist. : If set, bash includes filenames beginning with a ' ' in the results of pathname expansion. : If set, a non-interactive shell will not exit if it cannot execute the file specified as an argument to the   builtin command. An interactive shell does not exit if   fails. : If set, aliases are expanded as described above under ALIASES. This option is enabled by default for interactive shells. : If set, behavior intended for use by   is enabled: : If set, the extended pattern matching features described above under   are enabled. : If set,   and   quoting is performed within   expansions enclosed in double quotes. This option is enabled by default. : If set, patterns which fail to match filenames during pathname expansion result in an expansion error. : If set, the suffixes specified by the FIGNORE shell variable cause words to be ignored when performing word completion even if the ignored words are the only possible completions. See " " above for a description of  . This option is enabled by default. : If set, the pattern   used in a pathname expansion context will match all files and zero or more directories and subdirectories. If the pattern is followed by a  , only directories and subdirectories match. : If set, shell error messages are written in the standard GNU error message format. : If set, the history list is appended to the file named by the value of the   variable when the shell exits, rather than overwriting the file. : If set, and readline is being used, a user is given the opportunity to re-edit a failed history substitution. : If set, and readline is being used, the results of history substitution are not immediately passed to the shell parser. Instead, the resulting line is loaded into the readline editing buffer, allowing further modification. : If set, and readline is being used, bash will attempt to perform hostname completion when a word containing a   is being completed (see " " under " ," above). This is enabled by default. : If set, bash will send   to all jobs when an interactive login shell exits. : If set, allow a word beginning with   to cause that word and all remaining characters on that line to be ignored in an interactive shell (see " " above). This option is enabled by default. : If set, and job control is not active, the shell runs the last command of a pipeline not executed in the background in the current shell environment. : If set, and the   option is enabled, multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible. : The shell sets this option if it is started as a login shell (see " " above). The value may not be changed. : If set, and a file that bash is checking for mail has been accessed since the last time it was checked, the message "The mail in mailfile has been read" is displayed. : If set, and readline is being used, bash will not attempt to search the   for possible completions when completion is attempted on an empty line. : If set, bash matches filenames in a case-insensitive fashion when performing pathname expansion (see " " above). : If set, bash matches patterns in a case-insensitive fashion when performing matching while executing   or   conditional commands. : If set, bash allows patterns which match no files (see " " above) to expand to a null string, rather than themselves. : If set, the programmable completion facilities (see " " above) are enabled. This option is enabled by default. : If set, prompt strings undergo parameter expansion, command substitution, arithmetic expansion, and quote removal after being expanded as described in " " above. This option is enabled by default. : The shell sets this option if it is started in restricted mode (see " " below). The value may not be changed. This is not reset when the startup files are executed, allowing the startup files to discover whether or not a shell is restricted. : If set, the   builtin prints an error message when the shift count exceeds the number of positional parameters. : If set, the   ( ) builtin uses the value of PATH to find the directory containing the file supplied as an argument. This option is enabled by default. If set, the   builtin expands backslash-escape sequences by default.  [ ] Suspend the execution of this shell until it receives a   signal. A login shell cannot be suspended; the   option can be used to override this and force the suspension. The return status is 0 unless the shell is a login shell and   is not supplied, or if job control is not enabled.       Return a status of 0 or 1 depending on the evaluation of the conditional expression  . Each operator and operand must be a separate argument. Expressions are composed of the primaries described above under " ."   does not accept any options, nor does it accept and ignore an argument of   as signifying the end of options. Expressions may be combined using the following operators, listed in decreasing order of precedence. The evaluation depends on the number of arguments; see below. Operator precedence is used when there are five or more arguments.   : True if   is false.     : Returns the value of  . This may be used to override the normal precedence of operators.     : True if both   and   are true.     : True if either   or   is true.  and   evaluate conditional expressions using a set of rules based on the number of arguments. : The expression is false. : The expression is true if and only if the argument is not null. : If the first argument is  , the expression is true if and only if the second argument is null. If the first argument is one of the unary conditional operators listed above under  , the expression is true if the unary test is true. If the first argument is not a valid unary conditional operator, the expression is false. : The following conditions are applied in the order listed. If the second argument is one of the binary conditional operators listed above under  , the result of the expression is the result of the binary test using the first and third arguments as operands. The   and   operators are considered binary operators when there are three arguments. If the first argument is  , the value is the negation of the two-argument test using the second and third arguments. If the first argument is exactly ( and the third argument is exactly ), the result is the one-argument test of the second argument. Otherwise, the expression is false. : If the first argument is  , the result is the negation of the three-argument expression composed of the remaining arguments. Otherwise, the expression is parsed and evaluated according to precedence using the rules listed above. : The expression is parsed and evaluated according to precedence using the rules listed above. When used with   or  , the   and   operators sort lexicographically using ASCII ordering. Print the accumulated user and system times for the shell and for processes run from the shell. The return status is 0.  [ ] [[ ]   ...] The command   is to be read and executed when the shell receives signal(s)  . If   is absent (and there is a single  ) or  , each specified signal is reset to its original disposition (the value it had upon entrance to the shell). If   is the null string the signal specified by each   is ignored by the shell and by the commands it invokes. If   is not present and   has been supplied, then the trap commands associated with each   are displayed. If no arguments are supplied or if only   is given, trap prints the list of commands associated with each signal. The   option causes the shell to print a list of signal names and their corresponding numbers. Each   is either a signal name defined in  , or a signal number. Signal names are case insensitive and the   prefix is optional. If a   is EXIT (0) the command   is executed on exit from the shell. If a   is DEBUG, the command   is executed before every simple command, for command, case command, select command, every arithmetic for command, and before the first command executes in a shell function (see " ," above). Refer to the description of the   option to the   builtin for details of its effect on the DEBUG trap. If a   is RETURN, the command   is executed each time a shell function or a script executed with the . or source builtins finishes executing. If a   is ERR, the command   is executed whenever a simple command has a non-zero exit status, subject to the following conditions. The ERR trap is not executed if the failed command is part of the command list immediately following a while or until keyword, part of the test in an if statement, part of a command executed in a   or   list, or if the command's return value is being inverted via  . These are the same conditions obeyed by the errexit option. Signals ignored upon entry to the shell cannot be trapped or reset. Trapped signals that are not being ignored are reset to their original values in a subshell or subshell environment when one is created. The return status is false if any   is invalid; otherwise trap returns true.  [ ]   [  ...] With no options, indicate how each   would be interpreted if used as a command name. If the   option is used, type prints a string that is one of alias, keyword, function, builtin, or file if   is an alias, shell reserved word, function, builtin, or disk file, respectively. If the   is not found, then nothing is printed, and an exit status of false is returned. If the   option is used, type either returns the name of the disk file that would be executed if   were specified as a command name, or nothing if " " would not return file. The   option forces a   search for each  , even if " " would not return file. If a command is hashed,   and   print the hashed value, not necessarily the file that appears first in  . If the   option is used, type prints all of the places that contain an executable named  . This includes aliases and functions, if and only if the   option is not also used. The table of hashed commands is not consulted when using  . The   option suppresses shell function lookup, as with the command builtin.   returns true if all of the arguments are found, false if any are not found.  [  [ ]] Provides control over the resources available to the shell and to processes started by it, on systems that allow such control. The   and   options specify that the hard or soft   is set for the given resource. A hard   cannot be increased by a non-root user once it is set; a soft   may be increased up to the value of the hard  . If neither   nor   is specified, both the soft and hard  s are set. The value of   can be a number in the unit specified for the resource or one of the special values hard, soft, or unlimited, which stand for the current hard  , the current soft  , and no limit, respectively. If   is omitted, the current value of the soft   of the resource is printed, unless the   option is given. When more than one resource is specified, the   name and unit are printed before the value. Other options are interpreted as follows: : All current  s are reported. : The maximum socket buffer size. : The maximum size of core files created. : The maximum size of a process's data segment. : The maximum scheduling priority (" "). : The maximum size of files written by the shell and its children. : The maximum number of pending signals. : The maximum size that may be locked into memory. : The maximum resident set size (many systems do not honor this  ). : The maximum number of open file descriptors (most systems do not allow this value to be set). : The pipe size in 512-byte blocks (this may not be set). : The maximum number of bytes in POSIX message queues. : The maximum real-time scheduling priority. : The maximum stack size. : The maximum amount of cpu time in seconds. : The maximum number of processes available to a single user. : The maximum amount of virtual memory available to the shell and, on some systems, to its children. : The maximum number of file locks. : The maximum number of threads. If   is given, it is the new value of the specified resource (the   option is display only). If no option is given, then   is assumed. Values are in 1024-byte increments, except for  , which is in seconds,  , which is in units of 512-byte blocks, and  ,  ,  , and  , which are unscaled values. The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new  .  [ ] [ ] [ ] The   is set to  . If mode begins with a digit, it is interpreted as an octal number; otherwise it is interpreted as a symbolic mode mask similar to that accepted by  . If mode is omitted, the current value of the mask is printed. The   option causes the mask to be printed in symbolic form; the default output is an octal number. If the   option is supplied, and mode is omitted, the output is in a form that may be reused as input. The return status is 0 if the mode was successfully changed or if no mode argument was supplied, and false otherwise.  [ ] [  ...] Remove each   from the list of defined aliases. If   is supplied, all alias definitions are removed. The return value is true unless a supplied   is not a defined alias.  [ ] [  ...] For each  , remove the corresponding variable or function. If no options are supplied, or the   option is given, each   refers to a shell variable. Readonly variables may not be unset. If   is specified, each   refers to a shell function, and the function definition is removed. Each unset variable or function is removed from the environment passed to subsequent commands. If any of  ,  ,  ,  ,  ,  ,  , or   are unset, they lose their special properties, even if they are subsequently reset. The exit status is true unless a   is readonly.  [  ...] Wait for each specified process and return its termination status. Each   may be a process ID or a job specification; if a job spec is given, all processes in that job's pipeline are waited for. If   is not given, all currently active child processes are waited for, and the return status is zero. If   specifies a non-existent process or job, the return status is 127. Otherwise, the return status is the exit status of the last process or job waited for. If bash is started with the name  , or the   option is supplied at invocation, the shell becomes  . A   is used to set up an environment more controlled than the standard shell. It behaves identically to bash with the exception that the following are disallowed or not performed: These restrictions are enforced after any startup files are read. When a command that is found to be a shell script is executed (see the section " " above), rbash turns off any restrictions in the shell spawned to execute the script. The bash executable. The systemwide initialization file, executed for login shells. The systemwide per-interactive-shell startup file. The systemwide login shell cleanup file, executed when a login shell exits. The personal initialization file, executed for login shells. The individual per-interactive-shell startup file. The individual login shell cleanup file, executed when a login shell exits. Individual readline initialization file. Launches the bash command interpreter. The remainder of the examples will assume that you are at a bash prompt. Sets the value of variable   to "This is the value of my variable." Prints the value of  . Prints " " Prints " ". environment variable   to " " Prints the value of the environment variable  . This one-line command prints " ". This command does a few things: Prints " ". Prints the following:  — The C shell command interpreter.  — The Korn shell command interpreter.  — The Bourne shell command interpreter. Black Lives Matter. |  Learn the basics of the world's fastest growing and most popular programming language used by software engineers, analysts, data scientists, and machine learning engineers alike. Python is a general-purpose, versatile and popular programming language. It’s great as a first language because it is concise and easy to read, and it is also a good language to have in any programmer’s stack as it can be used for everything from web development to software development and scientific applications. This course is a great introduction to both fundamental programming concepts and the Python programming language. By the end, you’ll be comfortable programming in Python and taking your skills off the Codecademy platform and onto your own computer. Join people who have taken this course Portfolio projects that showcase your new skills It's time to build fluency in Python fundamentals. In this next Pro Project, we're going to practice syntax in Python so you can hone your skills and feel confident taking them to the real world.
Why? You've done a great job so far on your quest to learn Python. Let's build something to solidify your newfound knowledge.
What's next? Calculator, tipping, more Python. You got this!  It's time to build fluency in Python fundamentals. In this next Pro Project, we're going to practice inputs and print in Python so you can hone your skills and feel confident taking them to the real world.
Why? Being able to take inputs and print results is a key part of programming.
What's next? Mad Libs, user inputs, more Python. You got this!  It's time to build fluency in Python fundamentals. In this next Pro Project, we're going to practice functions and conditionals in Python so you can hone your skills and feel confident taking them to the real world.
Why? Ever wanted to automate your math homework? Time to build something in Python that does just that.
What's next? Shapes, math, more Python. You got this! Stress-test your knowledge with quizzes that help commit syntax to memory Get started learning Python with   free  . Learn Data Science by completing interactive coding challenges and watching videos by expert instructors.  ! This site is generously supported by  . DataCamp offers online interactive   for Data Science. Join   other learners and get started learning Python for data science today! Welcome to the LearnPython.org interactive Python tutorial. Whether you are an experienced programmer or not, this website is intended for everyone who wishes to learn the Python programming language. You are welcome to join our group on   for questions, discussions and updates. Just click on the chapter you wish to begin from, and follow the instructions. Good luck! Read more here:  This site is generously supported by  . DataCamp offers online interactive   for Data Science. Join   other learners and get started learning Python for data science today! Offered By This course aims to teach everyone the basics of programming computers using Python. We cover the basics of how one constructs a program from a series of simple instructions in Python.  The course has no pre-requisites and avoids all but the simplest mathematics. Anyone with moderate computer experience should be able to master the materials in this course. This course will cover Chapters 1-5 of the textbook “Python for Everybody”.  Once a student completes this course, they will be ready to take more advanced programming courses. This course covers Python 3. Install Python and write your first program Describe the basics of the Python programming language Use variables to store, retrieve and calculate information Utilize core programming tools such as functions and loops The mission of the University of Michigan is to serve the people of Michigan and the world through preeminence in creating, communicating, preserving and applying knowledge, art, and academic values, and in developing leaders and citizens who will challenge the present and enrich the future. These are the course-wide materials as well as the first part of Chapter One where we explore what it means to write programs.  We finish Chapter One and have the quiz and first assignment in the third week of the class. Throughout the course you may want to come back and look at these materials.  This section should not take you an entire week.  In this module you will set things up so you can write Python programs.  Not all activities in this module are required for this class so please read the "Using Python in this Class" material for details. In the first chapter we try to cover the "big picture" of programming so you get a "table of contents" of the rest of the book.   Don't worry if not everything makes perfect sense the first time you hear it.   This chapter is quite broad and you would benefit from reading the chapter in the book in addition to watching the lectures to help it all sink in.  You might want to come back and re-watch these lectures after you have funished a few more chapters. In this chapter we cover how a program uses the computer's memory to store, retrieve and calculate information. In this section we move from sequential code that simply runs one line of code after another to conditional code where some steps are skipped.  It is a very simple concept - but it is how computer software makes "choices". This is a relatively short chapter.   We will learn about what functions are and how we can use them.   The programs in the first chapters of the book are not large enough to require us to develop functions, but as the book moves into more and more complex programs, functions will be an essential way for us to make sense of our code. Loops and iteration complete our four basic programming patterns.  Loops are the way we tell Python to do something over and over.   Loops are the way we build programs that stay with a problem until the problem is solved. Dr. Chuck has a special ability to teach programming to people who doesn't necessarily have programming background. This is rare among programming teachers, and shows that he is an excellent educator. Thank you. It was a worthwhile course. Entertaining as well. I just wish that there were more sample homework before the exercises so students could see how the lessons are applied to actual problems. Great introduction to Python and programming as a whole. Everything is broken down making it easy to understand. Had zero programming experience before and this class made it easy and fun to get into. Extremely basic but Dr. Chuck is so interesting that you never get bored. You can pass the course in a few days with minimum or even no programming knowledge. It's a good starting point for beginners. When will I have access to the lectures and assignments? Access to lectures and assignments depends on your type of enrollment. If you take a course in audit mode, you will be able to see most course materials for free. To access graded assignments and to earn a Certificate, you will need to purchase the Certificate experience, during or after your audit. If you don't see the audit option:  What will I get if I subscribe to this Specialization? When you enroll in the course, you get access to all of the courses in the Specialization, and you earn a certificate when you complete the work. Your electronic Certificate will be added to your Accomplishments page - from there, you can print your Certificate or add it to your LinkedIn profile.  If you only want to read and view the course content, you can audit the course for free. What is the refund policy? If you subscribed, you get a 7-day free trial during which you can cancel at no penalty. After that, we don’t give refunds, but you can cancel your subscription at any time.  . Is financial aid available? Yes, Coursera provides financial aid to learners who cannot afford the fee. Apply for it by clicking on the Financial Aid link beneath the "Enroll" button on the left. You'll be prompted to complete an application and will be notified if you are approved. You'll need to complete this step for each course in the Specialization, including the Capstone Project.  . Will I earn university credit for completing the Course? This Course doesn't carry university credit, but some universities may choose to accept Course Certificates for credit. Check with your institution to learn more.   and   on Coursera provide the opportunity to earn university credit. 
        The Python programming language
       GitHub is home to over 50 million developers working together to host and review code, manage projects, and build software together. 
                  Use Git or checkout with SVN using the web URL.
                 If nothing happens,   and try again. If nothing happens,   and try again. If nothing happens,   and try again. If nothing happens,   and try again. Copyright (c) 2001-2020 Python Software Foundation.  All rights reserved. See the end of this file for further copyright and license information. Contents For more complete instructions on contributing to CPython development,
see the  . Installable Python kits, and information about using Python, are available at
 . On Unix, Linux, BSD, macOS, and Cygwin: This will install Python as  . You can pass many options to the configure script; run  
to find out more.  On macOS case-insensitive file systems and on Cygwin,
the executable is called  ; elsewhere it's just  . Building a complete Python installation requires the use of various
additional third-party libraries, depending on your build platform and
configure options.  Not all standard library modules are buildable or
useable on all platforms.  Refer to the
 
section of the   for current detailed information on
dependencies for various Linux distributions and macOS. On macOS, there are additional configure and build options related
to macOS framework and universal builds.  Refer to  . On Windows, see  . If you wish, you can create a subdirectory and invoke configure from there.
For example: (This will fail if you   built at the top-level directory.  You should do
a   at the top-level first.) To get an optimized build of Python,  
before you run  .  This sets the default make targets up to enable
Profile Guided Optimization (PGO) and may be used to auto-enable Link Time
Optimization (LTO) on some platforms.  For more details, see the sections
below. PGO takes advantage of recent versions of the GCC or Clang compilers.  If used,
either via   or by manually running
  regardless of configure flags, the optimized build
process will perform the following steps: The entire Python directory is cleaned of temporary files that may have
resulted from a previous compilation. An instrumented version of the interpreter is built, using suitable compiler
flags for each flavour. Note that this is just an intermediary step.  The
binary resulting from this step is not good for real life workloads as it has
profiling instructions embedded inside. After the instrumented interpreter is built, the Makefile will run a training
workload.  This is necessary in order to profile the interpreter execution.
Note also that any output, both stdout and stderr, that may appear at this step
is suppressed. The final step is to build the actual interpreter, using the information
collected from the instrumented one.  The end result will be a Python binary
that is optimized; suitable for distribution or production installation. Enabled via configure's   flag.  LTO takes advantage of the
ability of recent compiler toolchains to optimize across the otherwise
arbitrary   file boundary when building final executables or shared
libraries for additional performance gains. We have a comprehensive overview of the changes in the   document.  For a more
detailed change log, read  , but a full
accounting of changes can only be gleaned from the  . If you want to install multiple versions of Python, see the section below
entitled "Installing multiple versions".  is online,
updated daily. It can also be downloaded in many formats for faster access.  The documentation
is downloadable in HTML, PDF, and reStructuredText formats; the latter version
is primarily for documentation authors, translators, and people with special
formatting requirements. For information about building Python's documentation, refer to  . Significant backward incompatible changes were made for the release of Python
3.0, which may cause programs written for Python 2 to fail when run with Python
3.  For more information about porting your code from Python 2 to Python 3, see
the  . To test the interpreter, type   in the top-level directory.  The
test set produces some output.  You can generally ignore the messages about
skipped tests due to optional features which can't be imported.  If a message
is printed about a failed test or a traceback or core dump is produced,
something is wrong. By default, tests are prevented from overusing resources like disk space and
memory.  To enable these tests, run  . If any tests fail, you can re-run the failing test(s) in verbose mode.  For
example, if   and   failed, you can run: If the failure persists and appears to be a problem with Python rather than
your environment, you can   and
include relevant output from that command to show the issue. See  
for more on running tests. On Unix and Mac systems if you intend to install multiple versions of Python
using the same installation prefix (  argument to the configure
script) you must take care that your primary python executable is not
overwritten by the installation of a different version.  All files and
directories installed using   contain the major and minor
version and can thus live side-by-side.    also creates
  which refers to  .  If you
intend to install multiple versions using the same prefix you must decide which
version (if any) is your "primary" version.  Install that version using  .  Install all other versions using  . For example, if you want to install Python 2.7, 3.6, and 3.10 with 3.10 being the
primary version, you would execute   in your 3.10 build directory
and   in the others. Bug reports are welcome!  You can use the   to report bugs, and/or submit pull requests  . You can also follow development discussion on the  . If you have a proposal to change Python, you may want to send an email to the
comp.lang.python or   mailing lists for initial feedback.  A
Python Enhancement Proposal (PEP) may be submitted if your idea gains ground.
All current PEPs, as well as guidelines for submitting a new PEP, are listed at
 . See   for Python 3.9 release details. Copyright (c) 2001-2020 Python Software Foundation.  All rights reserved. Copyright (c) 2000 BeOpen.com.  All rights reserved. Copyright (c) 1995-2001 Corporation for National Research Initiatives.  All
rights reserved. Copyright (c) 1991-1995 Stichting Mathematisch Centrum.  All rights reserved. See the file "LICENSE" for information on the history of this software, terms &
conditions for usage, and a DISCLAIMER OF ALL WARRANTIES. This Python distribution contains   GNU General Public License (GPL) code,
so it may be used in proprietary projects.  There are interfaces to some GNU
code but these are entirely optional. All trademarks referenced herein are property of their respective holders. 
      The Python programming language
     Authors:
 ,
 ,
 ,
 ,
 ,
 ,
 ,
 
 Python is an interpreted object-oriented programming language. It is open source, so the interpreter and source are freely available and distributable in binary form. Python has 
 
 
 
 
 
 
 
 
 Basic familiarity with the fundamental concepts of programming HTML Are you a programming beginner? Maybe you've just started, or maybe you've taken a couple of entry-level programming classes and want to learn more. The beginner courses here will show you the basics of object-oriented programming (OOP) while teaching you the simple and functional Python programming language. When you've completed this section, you'll be ready to move on to improving your code quality. by Jason Olson Jan 26, 2018 / 1h 5m 1h 5m At the heart of creating software is being able to use the right tool for the right job. In this course, Python: The Big Picture, you'll learn about the Python programming language. First, you'll learn what Python is, what makes it different, and why you should care. Next, you'll explore the different ways Python is being used to develop different types of applications today. Finally, you'll discover how to get started working with Python code and what next steps you can take in your Python journey. When you're finished with this course, you'll have a foundational knowledge of Python that will help you as you move forward to recognizing when Python is the right tool for any future jobs you are faced with as a software developer. 
 by Austin Bingham Dec 12, 2019 / 4h 5m 4h 5m Python is a big language, and it's important to have a thorough grounding in its key concepts in order to be productive and create high-quality Python programs. In our experience, starting off in the right direction and avoiding early misconceptions is crucial to success with Python, and that's the kind of start we aim to provide. In this course, Core Python: Getting Started, we are going to introduce you to the essentials of the Python language as well as important parts of the Python standard library. Some of the major topics that we will cover include: Python's fundamental data types, using functions and modules to organize your code, Python's underlying object model, defining your own types using classes, and working with iteration and iterable objects. By the end this course, you'll have the skills and knowledge to work on almost any Python project, and you'll be in a great position to continue learning more advanced aspects of the language. 
 by Sarah Holderness Jun 1, 2018 / 1h 29s 1h 29s Explore the basics of Python and learn what it means to store and manipulate numbers and words as well as make decisions with your program.
This interactive course was formerly known as Try Python on Code School. 
 by Sarah Holderness Oct 1, 2018 / 2h 18m 2h 18m Explore more Python basics and use them to help manage our circus and its Spam Van food truck.
This interactive course was formerly known as Flying Through Python on Code School. 
 The intermediate courses you see here will teach you to improve your code. You'll dive deeper into unit testing and debugging, as well as learn some of the more advanced features of the Python language. by Robert Smallshire Jul 18, 2014 / 7h 21m 7h 21m Python – Beyond the Basics builds directly on the foundations laid in our introductory Python course, Python Fundamentals. Python is a great dynamic language for web development, big data, science, and scripting. In this course we add breadth and depth to your Python skills, exploring the topics you'll need to create robust and readable applications of any size. On completing this course, you'll be familiar with the majority of Python techniques and constructs used in Python programs. Crucially, we'll also advise you on when – and when not – to use the different tools available in Python to best effect, to maximize the quality of your code, your productivity, and the joy inherent in coding in Python. 
 by Reindert-Jan Ekker May 17, 2019 / 1h 10m 1h 10m In need of core skills for any level python development? In this course, Python Best Practices for Code Quality, you will learn a number of best practices that will help you improve the quality of your Python code. First, you will discover the guidelines for formatting code called Pep8. Next, you will create beautiful and publishable documentation with Python docstrings and a tool called Sphinx. Finally. you will explore how to improve maintainability and prevent errors by adding type hints to your code. By the end of this course, you will be able to write clearer, more readable and more maintainable code with better documentation. 
 by Reindert-Jan Ekker Feb 2, 2019 / 1h 23m 1h 23m Most real-world Python projects make use of code written by others, and usually this code is included by installing Python packages. In this course, Managing Python Packages and Virtual Environments, you will learn everything you need to install and manage the packages your project requires using pip, the Python package installer. When you start working on more than a single project, you will find that there's a need to install packages for one project separately from another project. You will come to understand that there's a tool for this situation as well: virtualenv, and no professional Python developer can go without it. First, you will explore everything you need to know in order to use virtual environments on a daily basis. After covering these two core tools, you will then discover other tools that you should at least be aware of such as virtualenvwrapper, which makes managing virtual environments a lot less painful. Finally, you will discover two newer tools: pipenv and poetry, and the direction the Python community is headed. By the end of this course, you will learn how to manage the requirements of your Python projects using virtual environments and pip, 
 by Emily Bache Jun 28, 2019 / 2h 49m 2h 49m Once you’ve learned the basics of the Python language and started building programs, you will soon realize a need for some automated tests to make sure everything you’ve built keeps on working as you (and other developers) extend and improve it. In this course, Unit Testing with Python, you will learn foundational knowledge in unit testing. First, you will discover how to write and run tests using the ‘unittest’ framework, and some theory about how to design good test cases. Next, you will explore other popular testing frameworks in Python - pytest and doctest. Finally, you will examine how to use test doubles effectively, and techniques for parameterized testing and measuring test coverage. When you’re finished with this course, you will have the skills and knowledge of writing unit tests needed to be confident adding tests for the code you write, and sharing those tests with other developers. 
 by Tom Bell Sep 27, 2018 / 2h 35m 2h 35m Python & Flask are great for building a simple website. In this project, you'll use them to build a simple job board. The main page of the site will show all jobs and each job and employer will have dedicated pages. Users will also be able to review each employer. 
 Our advanced Python track will show you how you can apply your newfound skill. You'll learn full-stack web development, as well as some techniques that will help you implement advanced frameworks. by Terry Toy Aug 21, 2015 / 3h 2m 3h 2m Learn full stack web development using Python and WEB2PY. WEB2PY is an easy to learn, integrate framework that includes a web server, admin, bootstap, and sqlite database. One simple download has everything you need to build robust, data driven web applications. This project-based course is for beginners new to web development or those who want to quickly learn a Python web framework. 
 by Robert Smallshire Jun 24, 2017 / 3h 52m 3h 52m Over time, Python has exploded in popularity, from being an obscure scripting language to becoming one of the most popular, and widely used languages in the world.  
In this  , you'll learn advanced topics, a knowledge of which will set you apart from the greater number of Python developers. 
 
By the end of this advanced Python tutorial, you'll know enough Python to understand the advanced techniques used to implement sophisticated frameworks and much more.
 Be sure to only enter offer codes separated by line breaks and does not include commas. There is/are   offer code(s) loaded. * Required field Opt in for the latest promotions and events. You may unsubscribe at any time.  By providing my phone number to Pluralsight and toggling this feature on, I agree and acknowledge that Pluralsight may use that number to contact me for marketing purposes, including using autodialed or pre-recorded calls and text messages. I understand that consent is not required as a condition of purchase from Pluralsight. By activating this benefit, you agree to abide by Pluralsight's   and  . We use cookies to make interactions with our websites and services easy and meaningful. For more information about the cookies we use or to find out how you can disable cookies,  . You have disabled non-critical cookies and are browsing in private mode. For the best possible experience on our website, please accept cookies. For additional details please read our  . Welcome to Google's Python Class -- this is a free class for people with a little bit of programming experience who want to learn Python. The class includes written materials, lecture videos, and lots of code exercises to practice Python coding. These materials are used within Google to introduce Python to people who have just a little programming experience. The first exercises work on basic Python concepts like strings and lists, building up to the later exercises which are full programs dealing with text files, processes, and http connections. The class is geared for people who have a little bit of programming experience in some language, enough to know what a "variable" or "if statement" is. Beyond that, you do not need to be an expert programmer to use this material. To get started, the Python sections are linked at the left --   to get Python installed on your machine,   for an introduction to the language, and then   starts the coding material, leading to the first exercise. The end of each written section includes a link to the code exercise for that section's material. The lecture videos parallel the written materials, introducing Python, then strings, then first exercises, and so on. At Google, all this material makes up an intensive 2-day class, so the videos are organized as the day-1 and day-2 sections.

 This material was created by   working in the engEDU group at Google. Special thanks for the help from my Google colleagues  John Cox, Steve Glassman, Piotr Kaminksi, and Antoine Picard. And finally thanks to Google and my director Maggie Johnson for the enlightened generosity to put these materials out on the internet for free under the   license -- share and enjoy! 
 
  Check out the   to ask and answer questions.
 
 Except as otherwise noted, the content of this page is licensed under the  , and code samples are licensed under the  . For details, see the  . Java is a registered trademark of Oracle and/or its affiliates. Last updated 2015-07-25 UTC.  While Javascript is not essential for this website, your interaction with the content will be limited. Please turn Javascript on for the full experience.  The core of extensible programming is defining functions. Python allows mandatory and optional arguments, keyword arguments, and even arbitrary argument lists.  Lists (known as arrays in other languages) are one of the compound data types that Python understands. Lists can be indexed, sliced and manipulated with other built-in functions.  Calculations are simple with Python, and expression syntax is straightforward: the operators  ,  ,   and   work as expected; parentheses   can be used for grouping.  . Experienced programmers in any other language can pick up Python very quickly, and beginners find the clean syntax and indentation structure easy to learn.   with our Python 3 overview. Python knows the usual control flow statements that other languages speak —  ,  ,   and   — with some of its own twists, of course.  Python is a programming language that lets you work quickly  and integrate systems more effectively.  Whether you're new to programming or an experienced developer, it's easy to learn and use Python. Python source code and installers are available for download for all versions! Latest:  Documentation for Python's standard library, along with tutorials and guides, are available online. Looking for work or have a Python related position that you're trying to hire for? Our   is the place to go.   The mission of the Python Software Foundation is to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers.    
 
 
 Python is a popular programming language. It was created by Guido van Rossum, 
and released in 1991. It is used for: 
 
 
 
 
 
 
 
 
 If you want to report an error, or if you want to make a suggestion, do not hesitate to send us an e-mail: help@w3schools.com Your message has been sent to W3Schools. We   how wealthy countries (those defined as   by the World Bank) tend to visit a different set of technologies than the rest of the world. Among the largest differences we saw was in the programming language Python. When we focus on high-income countries, the growth of Python is even larger than it might appear from tools like  , or in other rankings that consider global software development. In this post, we’ll explore the extraordinary growth of the Python programming language in the last five years, as seen by Stack Overflow traffic within high-income countries. The term “fastest-growing” can be  , but we make the case that  All the numbers discussed in this post are for  ; they’re generally representative of trends in the United States, United Kingdom, Germany, Canada, and other such countries, which in combination make up about 64% of Stack Overflow’s traffic. Many other countries such as India, Brazil, Russia, and China also make enormous contributions to the global software development ecosystem, and this post is less descriptive of those economies, though we’ll see that Python has shown growth there as well. It’s worth emphasizing up front that the number of users of a language isn’t a measure of the language’s quality: we’re   the languages developers use, but not prescribing anything. (Full disclosure: I   primarily in Python, though I have since switched entirely to R). You can see on   that Python has been growing rapidly in the last few years. But for this post we’ll focus on high-income countries, and consider visits to questions rather than questions asked (this tends to give similar results, but has less month-by-month noise, especially for smaller tags). We have data on Stack Overflow question views going back to late 2011, and in this time period we can consider the growth of Python relative to five other major programming languages. (Note that this is therefore a shorter time scale than the Trends tool, which goes back to 2008). These are currently six of the ten most-visited Stack Overflow tags in high-income countries; the four we didn’t include are CSS, HTML, Android, and JQuery. June 2017 was the first month that  . This included being the most visited tag within the US and the UK, and in the top 2 in almost all other high income nations (next to either Java or JavaScript). This is especially impressive because in 2012, it was less visited than any of the other 5 languages, and has grown by 2.5-fold in that time. Part of this is because of the seasonal nature of traffic to Java. Since it’s  , Java traffic tends to rise during the fall and spring and drop during the summer. Will it catch up with Python again by the end of the year? We can try forecasting the next two years of growth with a  , which combines growth with seasonal trends to make a prediction about future values. According to this model, Python could either stay in the lead or be overtaken by Java in the fall (it’s roughly within the variation of the model’s predictions), but it’s clearly on track to become the most visited tag in 2018. STL also suggests that JavaScript and Java will remain at similar levels of traffic among high income countries, just as they have for the last two years. The above was looking only at the six most-visited programming languages. Among other notable technologies, which are currently growing the fastest in high-income countries? We defined the growth rate in terms of the ratio between 2017 and 2016 share of traffic. We decided to consider only programming languages (like Java and Python) and platforms (such as iOS, Android, Windows and Linux) in this analysis, as opposed to frameworks like   or libraries like   (although many of those showed notable growth that may be examined in a future post). Because of the challenges in defining “fastest-growing” described in  , we compare the growth to the overall average in a  . With a 27% year-over year-growth rate, Python stands alone as a tag that is  ; the next-largest tag that shows similar growth is R. We see that traffic to most other large tags has stayed pretty steady within high-income countries, with visits to Android, iOS, and PHP decreasing slightly. We previously examined some of the shrinking tags like Objective-C, Perl and Ruby in our  ). We can also notice that among functional programming languages, Scala is the largest and growing, while F# and Clojure are smaller and shrinking, with Haskell in between and remaining steady. There’s an important omission from the above chart: traffic to TypeScript questions grew by an impressive 142% in the last year, enough that we left it off to avoid overwhelming the rest of the scale. You can also see that some other smaller languages are growing similarly or faster than Python (like R, Go and Rust), and there are a number of tags like Swift and Scala that are also showing impressive growth. How does their traffic over time compare to Python’s? The growth of languages like R and Swift is indeed impressive, and TypeScript has shown especially rapid expansion in an even shorter time. Many of these smaller languages grew from getting almost no question traffic to become notable presences in the software ecosystem. But as this graph shows, it’s easier to show rapid growth when a tag started relatively small. Note that we’re not saying these languages are in any way “competing” with Python. Rather, we’re explaining why we’d treat their growth in a separate category; these were lower-traffic tags to start with. Python is an unusual case for being  . (Incidentally, it is also accelerating! Its year-over-year growth has become faster each year since 2013). So far in this post we’ve been analyzing the trends in high-income countries. Does Python show a similar growth in the rest of the world, in countries like India, Brazil, Russia and China? Indeed it does. Outside of high-income countries Python is   the fastest growing major programming language; it simply started at a lower level and the growth began two years later (in 2014 rather than 2012). In fact, the year-over-year growth rate of Python in non-high-income countries is slightly   than it is in high-income countries. We don’t examine it here, but R, the  , is growing in these countries as well. Many of the conclusions in this post about the growth and decline of tags (as opposed to the absolute rankings) in high-income countries hold true for the rest of the world; there’s a 0.979 Spearman correlation between the growth rates in the two segments. In some cases, you can see a “lagging” phenomenon similar to what happened with Python, where a technology was widely adopted within high-income countries a year or two before it expanded in the rest of the world. (This is an interesting phenomenon and may be the subject of a future blog post!) We’re not looking to contribute to any “language war.” The number of users of a language doesn’t imply anything about its quality, and certainly can’t tell you which language is  . With that perspective in mind, however, we believe it’s worth understanding what languages make up the developer ecosystem, and how that ecosystem might be changing. This post demonstrated that Python has shown a surprising growth in the last five years, especially within high-income countries. In our next post, we’ll start to explore the  . We’ll segment the growth by country and by industry, and examine what other technologies tend to be used alongside Python (to estimate, for example, how much of the growth has been due to increased usage of Python for web development versus for data science). In the meantime, if you work in Python and are looking to take the next step in your career, here are  .   The “why” for Python (and to a large extent R) is fairly obvious: The rise of Data Science/ML/Deep Learning. Deep Learning frameworks available with Python APIs, in addition to Spark for “Big Data”, combined with the ease of picking up Python and a couple decades worth of scientific packages coming from academia and industry have made Python an incredibly productive and versatile Swiss Army Knife. Swiss Army Knife for individual science and research projects. I really would like to knowfor what kind of projects theses programming languages are used. I simply cannot imagine python beeing used for a regular industrial software project. The first version of Google was written in Python. Very true. Best advice I got early in career listening to a Google Engineer was to in fact learn new languages as they come out. not just ones employers looking for at the moment. It is indeed used for regular software projects: From Lucasfilm to Paypal (where it’s used in over 50 projects)…. …to Netflix: It is indeed used, I guess this is used mostly by start ups to implement an idea; and then it grows and grows; and is handed over to commercial programmers who have to deal with the nightmare of maintenance and hard refactoring. I am not sure you could call Google, Facebook and Youtube “startups” And large opensource projects with thousands of developers don’t seem to have a problem maintaining python. (openstack, ansible) I think the issue is probably with the culture or practices at the places you have worked more than any language they chose to use. Here is a good example of a project that refactored java to python to simplify dependencies and coding. Tensorflow and pytorch have lots of traction in the Machine Learning world too.  ML/DL/etc… have added to the popularity too. But to be brutally honest, most ugly python programs are only ugly because the developers didn’t take the time to learn the idiomatic, and pythonic way of using the language.  But once again that is not the languages fault, that is the fault of developers who cargo culted bad practices from other languages. My first experience with Python was trying to make sense of Anaconda (the red hat distro packaging software) in 2002.  Horrible, uncommented spaghetti!  Space delimited crap! Unreadable, not enough white space (see space delimited), zero meaningful comments, few comments at all.  Utter garbage. I’m still shocked that it ran. Agree, I have used Python in one project and though I love the simplicity in prototyping with it, the dynamic typing part makes it extremely hard to maintain especially as more and more teams work on it, and when the project is 2 , 3 years old. Yeah I would also like to know what are the strengths of this language over languages such as C#, JS, or Java. Stack Overflow traffic within high-income countries. The term “fastest-growing” can be hard to define precisely, but we make the case that Python has a solid claim to being the fastest-growing major programming language. I’d really like to see that case made (using much better statistics than “questions asked on overflow”).  One alternative measure is the Tiobe Index.  You may not agree with the way it measures a language’s popularity but has been a reasonably consistent measure taken for the last 15 years.  It doesn’t contain any hint that “Python has a solid claim to being the fastest-growing major programming language”. Apr 2019	Apr 2018	Change	Programming Language	Ratings	Change 
1	1		Java	15.035%	-0.74% 
2	2		C	14.076%	+0.49% 
3	3		C++	8.838%	+1.62% 
4	4		Python	8.166%	+2.36% As far as industry goes, Ignition is Python (not CPython but Jython) so you get a lot of controls engineers using Python. You also get a lot of data scientists using it. When I worked for a logistics company, the stack was .Net, but all our data scientists used Python for predictive analytics, geographic measurements and processing data feeds. While a lot of small businesses use WordPress, you see some small and medium going the Python route via Django. Fascinating. I’ve always been interested in the rise and fall in popularity of programming languages. Where is Julia? 🙂 What about Elixir 😀 @David Robinson I would also echo that question: “What about Elixir?” Elixir would have looked very similar to Rust- you’re probably right that it could have been included! (May even have the chance to edit this graph to add it). At that size there’s a question of where to draw the line (I didn’t bother including, say, Fortran) but admittedly it’s a bit unfair to mention Rust but not Elixir. Thanks very much for the update. I’d say elixir is on a trajectory that’s more similar to Go, just not as far along in the the cycle. GIven that it’s later release that Rust/Go, it’ll be interested to see these numbers over the next year or two — particularly on the year over year plot chart. Thanks very much for your work on the post and all the replies. Yiiiikes.. it’s still… not even… Where is Elixir? 🙂 It’s there, but the x-axis overlapped it perfectly so you cannot see it. nice Do you suppose that this correlates with the sales of the Raspberry Pi? I didn’t know a thing about Python until I started programming my first RPi. Now it’s my go-to language at pi-plates.com. The first release of Raspberry PI (Feb 2012) correlates perfectly with when the growth began in the wider graph  See also Hacker News discussion:  Newbies to programming may be more likely to search for or ask more questions than experienced programmers. Could this perhaps indicate that people new to programming often learn Python as a first language, and thus ask more questions about it?  That is, could it be that Python’s apparent popularity is magnified because its users are more likely to ask questions than other languages’ users? There is also frameworks to consider. For example, a user of Java EE is clearly using Java, but will not necessarily include the `java` tag in their question. I would assume the same is true of other languages, particularly Javascript. You can say the same about python, too. A quick check shows me 74,000+ questions tagged with django but not with python. That number is a whole lot bigger than I expected it to be. That’s a good point. But I think it might also have something to do with a ton of things that you can do with Python. From building web apps, mobile apps to networking apps and now data-based applications/prototypes. It might just be that Python makes it easier for people to switch roles and try new things. It may also be that Python Code is very difficult to maintain (my experience) That’s because space delimited languages discourage commenting. For anyone wondering, yes there are many types of statistical bias and not taking these into account can lead you to bad conclusions. If previously there were just a few newbies asking question and now there are more and more newbies asking questions, it means the language is growing. The point is that the number of questions asked is increasing. So either the existing Python users are asking more and more questions as they gain experience, or new Python users are showing up. Can we use an STL model on percentages like that? I’m thinking no. The timeseries are correlated – for example, the author explains that java is heavily taught in undergraduate courses, causing peaks in its share of views during the fall and spring college semesters. If you look at javascript, it dips when java rises and rises when java dips. Is that because all the college students read up on javascript during their breaks? more likely, the absolute page views of javascript are less correlated to undergraduate schedules, but its relative rank increases as the page views of java decline. I’d also like to see how Ruby does vs Python and others in Japan. And Vue.js vs React and Angular in China. That would be interesting data to show IMO. I don’t think we can get information about China users, they must pass the great fire wall : ) i don’t know the “language war”. what is the “language war”? like Nsync vs. backstreet years ago Yo the java pattern is sooo funny. Slumps during summer and Christmas. These people are not real programmers, schools and white collar 😛 It is also interesting that the JS chart has its peaks when Java has its lows. So those students start to go wild with JS during their break times? Is the code for this analysis available? i thought it is not actually growth , maybe it caused python’s documentation poor less than java Great survey. It would be nice to see a survey like this for databases. At least in my daily business I see a switch of the focus. Clear and simple data structures are the base for clear and simple (Python) code. I’m a J2EE developer by trade, a python developer on the side — 
read: right tool for the right job. Maybe due to industry trends? Python seems to attract more academics — mathematicians, data scientists, physicists, etc. It’s more approachable. Recent trends in AI and data science might suggest the libraries supporting these hot topics developed by such people make it more approachable by practitioners or experimenters. Who knows? Good read. Time to reopen my Python books and start to play with it! Start with the latest version. Important new goings-on. I learnt C++ and Python and wanted to take both of them at proficient level but I was confused for which one should i pick first. Finally I chose python. It may grow as much as it wants, I don’t like Python that much. I get along, but I do not embrace it. That typescript projection is way off. See angular. There is no projection for TypeScript. Does JavaScript include other frameworks like NodeJs or AngularJs? Same for Java, does it include Android? And PHP? I hope there would be some overlap, even though it is marginal. Thoughts? My guess is that it’s specifically the language tags. So [Android] [Java] would count for both (but android is not a language per say, so it’s not listed here). For javascript, 
 [node.js][javascript] would be included but [node.js] only would not. Looking forward the next post! AI and ML are coming bro! too many languages and too many frameworks ………… this sounds as negative more to me than a positive Very interesting graphs. For myself, the most interesting details are the yearly changes and emerging patterns especially for java, javascript and c++. My interpretation, java and c++ are the main languages when it comes to employes with daily 9 to 5 job, they decrease for the typical vacations around summer and new year. In contrast to this javascript seems to be the side-project/personal-use language, it rises when developers go on vacation. 🙂 And php seems to be a christmas language maybe all the good old shopping sites need an update just before the big sales. So conclusion for me atleast, your best bet for a steady job with good work life balance are still java and c++. I think students taking programming courses in Java and C/++ (still the most common intro to programming languages) might explain that even more directly. Interesting to note the very regular periodicity of Java and C++ in the first graph. Does this indicate their maturity as languages and in their use? 
As well languages well established with a history of reliability and so on they are likely used as the main ‘workhorse’ languages of larger established, companies with western operations (say, Siemens for e.g.). This might correlate to the periodic pattern where work in such companies generally tends to slow somewhat over the Christmas and summer break periods. With the acuteness of  Python’s trend though it’s hard to tell if the same trend is appearing there yet. Java is also an extremely typical language for college intro to programming classes. So stack overflow likely is flooded with Java question visits at the beginning of each semester and fewer in the summer I’d guess it has more to do with those being commonly taught languages in schools.  The drops seem to coincide with summer/spring/winter/fall vacations. “we’re describing the languages developers use ”  Is it not rather the languages for which people ask themselves many questions and on which they seek an answer on SO? As a general language widely used by beginners, sometimes in areas far away from computer science, it seems normal that Python attracts a lot of attention. I would be interested to know which libraries of Python are concerned. The hype around data science and machine learning has undoubtedly increased the number of questions related to modules such as Pandas, TensorFlow or Scikitlearn. You have a great point. SO wrote “developers” while in reality they are considering programmers. A lot of Python programmers are not even developers or computer scientists (but this is also true for R and several great languages commonly used for data science, statistics, biology and a lot of other purposes). R is bad. Please switch to Python. So bad nobody in company pushes me to Python so I stay in R with comfortably. This is my 20th year anniversary of taking up Python! Hail Guido. 
R growth is interesting – as this is free replacement for S+. Learned this back in 1990’s as S. 
I dumped S+ & could not stand Java or C++ 20 years ago. 
I still love it but beginning to learning Scala nowadays. It won’t replace Python anytime soon but a nice complement Python for speed & multi threading issues. Scala is great, but not quite as fun or easy as Python. 
Hopefully, Scala won’t take 20 yrs for me to monetize (does not seem like it either). Guido is a BeauDiFuL man. Not abusing his authority as benevolent dictator either unlike some. Beautiful mind. He is taking up issues with autistic children. He deserves to be supported. > Python for speed & multi threading issues. 
Yet most Python implementations don’t support multithreading. Right, that’s why s/he is using scala for that. Could it be that folks flock to StackOverflow because they can’t figure it out on their own and it’s not well documented? That would only explain the steady increase if you assume the Python documentation gets worse and worse each month. I agree that the documentation is not Python’s forte, but have you ever contributed to improving it? Could. But specially not likely within Python. It have a community and design focus towards good documentation. Official documentation is good but often lacks practical examples on how to make that thing dance. Also, I plead guilty that when using a module I never used before, I often wonder how to it in a pythonic way. StackOverflow answers that neatly. If it were another language, I would care less (and good luck to the future maintainer). That might explain why Java jobs pay more on average, according to some sources. Hahahahaha. No. The docs I’ve read are sub-par, and poorly indexed.  I see better from third parties. Yeah. Sure. Sphinx usually indexes it badly. Lets get the flames started :/ I doubt this is a primary factor, but could definitely be a cause for some of the growth. Python is a good language for beginners. Beginning programmers often have trouble with documentation, and, in my experience, Python’s documentation is not particularly friendly. With more and more people learning to program, there are more beginner programmers than ever right now. You are correct. I am still learning and I check the documentation often when I want to use something new. The documentation helps me to understand how it works “more or less” but without a practical example I cannot make it work, most of the times. Stackoverflow has so many examples that a quick search fits my needs. Interesting, I would have expected go to be taking some chunks from python (we’ll have to watch it over the next few years), but maybe Python is hitting the famous “critical mass.”  And good on ’em it’s a nice language, and much less painful than some others… Suggest me some good sources to learn python. 😛 
Thanks. Checkout this:  Very original link. But a solid choice 😀 A lesson the Django devs instilled in me. ‘RTFM’ I was told. How about learning by doing & have fun while you do: codecombat.com  (in addition to going through docs, though) SoloLearn – if you already know how to program. They give you a nice run-through of the major features. Why on earth is java (alone) experiencing a mid summer drop? Is there something with java that just makes it unbearable in the summer heat? School is out, no homework to be done 🙂 Hah… good point. Java is pretty much unbearable in any temperature.  It’s unfortunate that it’s taught so widely – it was the de-facto go-to language when the current crop of instructors were learning programming, and so that’s why it’s being taught now.  Pretty much any modern language would be better. JAVA is horrific. That’s who. The number of StackOverflow questions on Python seems likely to have to do with the quality of Python documentation, which ranges from sketchy to poor. StackOverflow is where a search winds up when answers can’t be found elsewhere. Python’s documentation is no worst than javascript or php. Anyway who reads the docs when you have stackoverflow. How would that explain the steady increase of Python questions? Do you read the documentation when you want to solve a programming challenge? Most developers go to stackoverflow to solve their issue quickly and continue working. I think this is more a cultural thing more than the quality of the documentation. As I see, nowadays the developers prefers fastest answers than exhausting search. I am a quant not a programmer. So, I asked most dumbest Q in the planet on earliest threads. It’s a great community of experts & just attempted to be helpful. Either way, I found it much better than any other. Good lang structure really helps as the basis. Python is for the solvers not the the elite few like others. I hate to say it but that last sentence is about the dumbest comment on Python in the planet. I don’t mind saying it. That comment tells you how little u know about quant analysts and your troubled up bringing. Don’t get personal & insulting, unless personally provoked. I think another factor is countries like Australia started to teach their university fundamental programming courses in Python. But I feel like Python is currently in a middle ground between being Node.js and Golang. …What does that even mean?  One of those is a technology, the other is a language targeting the complete opposite dev-space as Python “Python is currently in a middle ground between being Node.js and Golang.”? And what is that supposed to mean? I also would like to see trends in terms of Python 2 versus 3, I feel the latter is finally picking up. More people are learning to hack.. noice. Nope, it’s all percentage, so in fact no-one more could be learning to hack today than last year, it might be that less people are asking visiting questions about C#.  Who knows, because the author graphed percentages against percentages within a closed system! Where is the Kotlin? it must have experienced an incredible growth this year! I was thinking this as well. Even though it isn’t a big tag, its growth was quite high:  Traffic to Stackoverflow means persons who want answers to questions about Python.  Python is a simple development language but still raises lots of syntax questions. I learned R prior to the year 2000 and came across Python through a friend in 2002. Today their eco systems are completely different, no one says that R is like S anymore, persons formerly known as SPSS professionals became R experts, and Python now means mostly web app development, Django/Flask etc. Syntax and features changed over the years but what remains is that Python is simple but also quite unintuitive. It makes you raise lots of questions. That could be a super-mario style gamification of learning programming in Python but it is also a result of insufficient official documentation and Python’s common oddities. I agree one can have doubts on over-interpreting this result. Eg. Would the curves have similar shape and proportion if we would look at question creations instead of views? Python is just about as intuitive as you’d get with a programming language as a beginner. I really disagree with you there. I think the influx of traffic can be explained because python is so intuitive, ie; beginners can pick up python and formulate intermediate questions quickly with python – thus explaining the need of stackoverflow. I tend to agree with the “simple but unintuitive” statement, although I’m looking from a non-beginner perspective here. For example, using “len(s)” (and not the object attribute/method) to find out the length of a string/list is quite unintuitive because I expect Python to be all-object-oriented; another thing is the need to put the module name in front of a function name (for example, string.split). Why seems so hard for some people not using brackets to delimit scopes? This clickbait article sucked. I expected it to go into detail about the business drivers of why organizations might be adopting Python over other languages. Instead it just graphed the number of tech support questions, suggesting a correlation to the language’s popularity. As André Rebentisch suggests in the comment below, it could just mean that Python is harder to learn due to inadequate documentation. This.  In spite of several books, the language is nearly gibberish. The type nomenclature sucks, stray whitespace will cause a syntax error (this discourages readability and comments, IMO), and you have to load libraries just to do anything. While this is fine for C (where you have to drag in libraries to write “Hello World”), it is outrageous for a non-compiled scripting language like Python. Hence, StackOverflow gets more questions as more companies and tools require using it. Wow.  You’ve obviously never used Python professionally (or even amateur-ally!).  It is one of the easiest languages to use, your “stray whitespace” comment is a complete non-issue for anyone that’s used it on any bigger program than “Hello World”, and it’s motto of “batteries included” means that it has a lot more built in functionality than most languages. If it wasn’t gibberish, I would use it.   I had to use it on an AWS project, and the script I had to expand and maintain was unreadable, uncommented, and was broken every time I tried to comment it and spread it out so it was readable by something other than a 20 year old with no life.   Plus, have you tried to read anaconda? That was my first exposure, and it gave me bad Tcl flashbacks.  Both instances were at paid professional jobs, one in 2002, one in 2014.  Your argument is invalid, because what you state as “obvious” is not true. Really nice work guys. We covered this on the Python Bytes podcast this week:  What’s the excitement?! Nothing new! All of the you mentioned has already been done in R when I was back in grad school I wonder how much of this growth comes from Python 2 vs Python 3 This article is incorrectly and sensationally titled: it’s not worthy of an “official” SO article.  It should make abundantly plain that it is about the popularity of tags on SO, not something doing in-depth research into which languages are being used. 
This tag trend could indicate many, many things, particularly given the spectrum of experience of SO users. It could indicate so many things that any article wishing to talk about it needs first to consider in some depth what can possibly and realistically be achieved by looking at tag popularity. Down. Vote. (!) Quite interesting job, but is there any correlation to percentage of post that do not include language name? For example I see plenty of times posts about php symfony, doctrine and so on without the “php” tag. Please stop mapping percentages against percentages, as they have little relation to actual growth, being out of 100 as they are. All the percentages are out of the same exact denominator, which is the number of visits per month to Stack Overflow. This has been slowly but steadily decreasing over time, with notable drops in each December (associated with the holidays in many Western countries) and to a lesser extent the summer. Would it really make for a more informative or descriptive plot if each were curve were slating more upwards, with associated seasonal drops? It wouldn’t change the relationship between any pair of lines. This graph also makes it clearer which tags are seasonally associated with the school year (Java, C++) which are negatively associated with it (Javascript), and whose traffic is nearly independent of it (Python). The only thing StackOverflow question counts indicate directly is that Python is the fastest growing cause of programmers’ headaches, which is entirely expected of this monstrosity. You misunderstood the plots. The “monstrosities” (aka PHP and C++) have a lower question count. Why not correlate this data with your Jobs/Careers section?  Where is there growth in those countries in job postings?   There are 1449 jobs on your jobs site. JavaScript brings up 596. Java search brings up 557. Python 428.  C# 208.  Almost all the jobs on there are in the “Rich Countries” (North America, Europe) and very few are not. It would be interesting to get some data from your Careers site on the last few years and how many jobs were posted per year for each of these very popular technologies. I will never understand why people choose python over ruby The increasing interest in data science and the available packages that allow the creation of statistical learning models has a lot to do with the growth of both python and r. Combine that with the straightforward syntax of python and you got yourself a winner. I don’t know about others, but personally I’d steer away from Ruby because of its package management systems (RubyGems and Bundler), which are difficult to understand and use properly, and don’t play well with distributions’ package managers. Bundler is very easy to use. It was the inspiration for the others. Now Npm, Yarn, even PHP use similar solutions. Unlike pypi? Well, I only used pypi it like one or two times, and I don’t remember having problems with it. At least, with pypi, you don’t deal with Gemfiles and some weird installation magic to get the application working, you just install the packages that you want and go on. That is literally the exact same thing you do with requirements.txt and pypi. Not quite. Maybe I was just lucky, but I didn’t encountered requirements.txt before. With Ruby, dealing with Gemfiles and Bundler seems unavoidable. And the problem is that Bundler tries to do much more than just installing packages. It manages its own local configuration, mixes application-level configuration with dependency configuration, employs a concept of “groups” to vary installed packages depending on different use cases. Now, there is also “rake” that also has to do with application installation and maintenance. All of this constitutes a complex, very non-trivial ecosystem with varying types of configuration files and whatnot. It may be great and convenient to use if you are a Ruby expert, but if you are just a sysadmin who wants to figure out why Redmine suddenly breaks after Gentoo updates some ruby packages… Well, good luck with that. Disagree with you here. Ruby’s package management solution is one of its best features, and (just IMO) superior to Python’s. Generally, of course, which language you prefer is mostly a preference, and they’re both great languages. Ruby and Python are not at the same level. Maybe Ruby over php. Python is dominant in science and big data, also older, so more established. Python also has a superior syntax and data model. Ruby is great, but Python is better. Python is much less expressive language than Ruby. Python’s syntax is also uglier. But… Python has several very good libs like SciPy and is much simpler language to start with. The `end` keyword. Well there is a major bias in this paper, where the writer makes the assumption that the number of questions reflects the growth of usage. 
While there is certainly some correlation, it may very well be that growth of questions relates to many other factors: 
 – growth of problems. It is easy to imagine that if you don’t have problems, you won’t ask questions. It may be that with Python apps gradually growing in size and scope, more problems appear than with other languages 
 – questions already answered. You can find answers to many questions in say Java, hence new users won’t ask new questions 
I am not expressing an opinion on Python here, simply an opinion on the paper. Growth of questions does not translate to growth of usage (unless proven otherwise) It’s question views, not questions asked. Existing questions thus count as well as new ones. I will make FORTRAN pop again Sure, but please at least spell it “Fortran” as it has been spelled for over a quarter century. 😉 It would be interesting to collect data to see how many continued using python from prototype to production. Python would definetly help to build MVP, when in production where actual concurrency matters; very few like Instagram have built robust python based architectures. 
Btw, achieving decent concurrency in python is quite straightforward. Understanding of Greenlets, Gevent, uvloop Cython etc. could prevent headache in future. Seems the researcher need to understand how Stack Overflow is used before making such a misleading statement.  A higher score on Stack Overflow Trends would indicate the inadequacies of the language.  More visits indicate a level of frustration, a lack of documentation, and not the languages popularity. Traffic from high-income countries (US/UK) is also misleading, without understanding the root cause.  Python started out as an ASCII only language, making it useless in non-ASCII environments.  In lower-income (non-English speaking) countries, they do not choose Python because many outputs default to the ASCII character set. Using Python takes a constant effort to use a character set that’s not ASCII.  Keeping the desired character set is a constant fight, one I have personally faced time and time again.  Adding a lot of 
extra code that is not necessary in other programming languages. python3 is better with unicode default Sorry no, this is wrong on all accounts. Even ancient Python supported unicode out of the box. Python 3, which is 11 years old, uses utf-8 source encoding and unicode strings by default. Maybe it’s not the number of Python users that increased, but the confusion? then Java is the most confusing language of all times. But… this is a quite true :v Yes, probably. Actually I believe is just people trying learn how to use third-libraries of WebScrapping and Machine Learning works (pandas, sklearn, tensorflow, theano and etc), which in essence are complex things and not exactly because of Python, but their itself embedded technologies. It’s probably a combination of both. The recent machine learning / deep learning hype has brought into existence many new ML Python libraries that need to be learned by users, even if they were Python users before, so it increases the number of questions they ask. Additionally, the fact that most popular machine learning libraries are written in Python may also cause more people to use Python. Nitpick: Fold growth represents doubling. 2.5-fold is roughly 5.6 times as much as the original value. Python is seeing about 2.5 times as much traffic, not 2.5-fold as much traffic. I don’t think that’s right. I just checked in a dictionary and “Twofold” means doubling and “threefold” means tripling. I’m pretty sure 2.5-fold wouldn’t mean 5.6 times much. That dictionary may also tell you that the meaning of “literally” is “not literally.” They reflect common use, which in some cases includes common inaccurate word use. That’s a usage that I haven’t seen even in technical stats literature – seems pretty esoteric. But either way by that definition 2.5-fold is exactly 3.5 times as much as the original value (it’s just the difference between new and old in terms of the old). I’m not sure where you got 5.6 times, maybe you interpreted it as being something exponential? I started My PhD a year and half ago. Programming was something new to me. In the department I am in most postdoc use python. I started learning it. Believe me. this language is amazing. An interesting analysis, but one problem with statistical analysis is assigning a causation to a correlation. So, the correlation is one of number of views. The causation assumption is because of the number of users. However, there are other potential causation theories, such as lack of documentation, inexperience of users/viewers, source of viewership (e.g. students versus professionals), etc. I always find it disturbing when people jump to causation theories based on a set of statistics when the full set of statistics are not identified (and often not even available). This can lead to some erroneous conclusion that people then base actions on incorrectly. One of my favorite examples is car insurance in the USA. In the ’80s, red-colored cars were in more accidents than any other color car. The conclusion reported in the US news media was that a red-colored car was more dangerous than other color. Legislation was proposed to raise the insurance costs of those who owned red cars (luckily, this did not go through).  What question was not addressed by the statistics? How many red cars were out there. It turned out that there were way more red cars than any other color. When you adjusted for number of cars, it actually turned out that the red cars were in fewer accidents per car than any other color. So, instead of being the most dangerous, they were the safest (at least when counting number of accidents, there were no statistics on fatalities per color that I could find).  Pushing correlation as causation is a favorite past time of statisticians and those that report statistics. I suggest that while reviewing the numbers is very interesting, take the causation statements with a grain of salt. The red cars point is just terrible use of statistics, its not related to the correlation as causation problem. Paul, you are correct that the red car was a terrible use of statistics. However, the problem is the same. Someone sees a correlation in the statistical set they are reviewing and assign a causation (implied or stated) to that correlation. In this case the correlation was number of question views over time and the assumed causation is a significant increase in python programmers and language use. For example, the numbers don’t state “unique user views”. Anyway, I do like Stack Overflow’s statistics, I just don’t base my career decisions on just that data set. “Conclusion: do questions really represent the health of a technology?”   It would be interesting to collect data to see how many continued using python from prototype to production. Python would definetly help to build MVP, when in production where actual concurrency matters; very few like Instagram have built robust python based architectures. Btw, achieving decent concurrency in python is quite straightforward. Understanding of Greenlets, Gevent, uvloop Cython etc. could prevent headache in future. With the raise of machine learning, AI, data science.. it’s no surprise to me. There was none Python programmer in my company before except for me. Now for our new R&D, BI, the main/only language we are using is Python. If developer time is more valuable than compute costs, than it’s about the effort to code the solution – and for ML, Python appears to be the preferred choice. I’d love to see what sort of tags within Python are seeing the most visits/growth. I’m betting that there’s a lot of pandas and other scientific Python driving these visits. most probably sklearn,pandas and matpotlib ruby is better I think this methodology works when comparing a single language’s growth, but not when comparing languages with each other.  For example when I use C#, probably 80% of my questions are answered by intellisense.  To the extent that I’ve used Python, it has typically been inside a Jupyter notebook, where you have to look up everything little thing. I use C# 40 hours a week at my day job, and Python for a data science class (~10 hrs week).  I can safely say I visit StackOverflow a lot more often with Python questions. You should use PyCharm if you prefer the C# experience. It’s like Visual Studio + Resharper only better. Nice! Just started on Julia. Wow! this is an excellent language. I now it know it better after a week than Scala after months of investment. If anything can dethrone R, Python, Scala, Matlab, etc.., then Julia may be able to. Took the nearly best features. I do miss the obj orientation, but really great. This is coming from 2 decades on Python by a member from “Liar’s Poker” quant. no doubt Julia has pros, but Pascal-like syntax killed my interest in this language… Why do you think there is such a strong seasonality for some of the languages like java, javascript, and c++ in the high-income countries? Ofcourse, wealthy countries are moving towards much of the Artificial Intelligence and Congnitive Software. And Python has been a choice for most of the developers in these streams. I started My PhD a year and half ago. Programming was something new to me. In the department I am in most postdoc use python. I started learning it. Believe me. this language is amazing. It would be interesting to collect data to see how many continued using python from prototype to production. Python would definetly help to build MVP, when in production where actual concurrency matters; very few like Instagram have built robust python based architectures. What’s up friends, its fantastic article on the topic of cultureand completely defined, keep it up all the time. Very good article. I’m facing some of these issues as well.. In lower-income (non-English speaking) countries, they do not choose Python because many outputs default to the ASCII character set. I need to explore Python books and start working on it! It’d be interesting to collect information to find out how many ongoing with python from prototype to manufacturing. Python would definitely help build MVP, when in creation in which real concurrency things; quite few like Instagram have constructed solid python established architectures. In lower-income (non-English speaking) countries, they do not choose Python because many outputs default to the ASCII character set. Hassan In lower-income (non-English speaking) countries, they do not choose Python because many outputs default to the ASCII character set. Agree Python is fastest-growing programming language In last few weeks, I was reading about Python history and got shocked to know that big companies like Netflix, IBM and Dropbox uses Python. The best all-round language we have? Probably. Now, personally, I prefer C# to Java as a language, I also prefer WPF to Java’s UI toolkits (although JavaFX is very good indeed). However, C#/WPF only runs on Windows, so what if I want to run on something else? Cross platform options are maybe… C++/QT, C#/Toolkit of your choice, or maybe stuff like TCL/TK. Or maybe you could do a UI in SDL and have it run on just about anything. You could do a HTML/CSS UI too, you could get that running on most things. For server stuff, you’ve got a lot more options as you don’t need to worry about UI toolkits, but even then, what cross platform languages are there, which are genuinely better than Java? I’m struggling to come up with on, C of course is The Greatest Language Ever Created By Man, but it’s not great at everything, if I was writing a corporate system accessing databases, working with XML, REST services, SSL, give me Java any day. Java is not a perfect system, but it is very good indeed, as said elsewhere in this question, yes it can go crazy with academic stuff, and be needlessly verbose. However, if not Java, what? Python, Ruby, PHP etc. all have their place, but as an all-round language, Java really is just head and shoulders over all of them. Is the any thing which can be done using python But can not using  c++ !!! Yeah, its best..Along with that, it’s not that hard to understand the language. In the last few weeks, I was reading about Python history and got shocked to know that big companies like Netflix, IBM, and Dropbox uses Python. 
Great post! Python would definetly help to build MVP, when in production where actual concurrency matters  Required fields are marked              
 
 This site uses Akismet to reduce spam.  . © 2020 All Rights Reserved. 
        Proudly powered by  
            We've verified that the organization   controls the domain:
           GitHub is home to over 50 million developers working together. Join them to grow your own development teams, manage permissions, and collaborate on projects. 
        The Python programming language
       
 
 
 
 
        Optional static typing for Python 3 and 2 (PEP 484)
       
 
 
 
 
        Source code for python.org
       
 
 
 
 
        Python Enhancement Proposals
       
 
 
 
 
        Collection of library stubs for Python, with static types
       
 
 
 
 
        The Python developer's guide
       
 
 
 
 
            The Python programming language
 
            Spanish translation of the Python documentation.
 
            zh_CN translation of the Python documentation
 
            Optional static typing for Python 3 and 2 (PEP 484)
 
            Brazilian Portuguese translation of the Python Documentation
 
            Collection of library stubs for Python, with static types
 
            Python Enhancement Proposals
 
            The Python developer's guide
 
            Contributor License Agreement assistant (CLA assistant)
 
            A bot to help identify missing information for CPython pull requests
 
            `blurb add` over the internet
 
            Korean translation of the Python documentation
 
            Configuration for Python planets (e.g.  )
 
            Source code for python.org
 
            CLA enforcement bot for Python organization projects
 
  - A bot for backporting and merging CPython pull requests
 
            Work related to PEP 484: typing.py (released via PyPI) and issue tracker
 
            Sphinx theme for Python documentation
 
            Source for packages that the cpython build process depends on
 
            Python Performance Benchmark Suite
 
            French translation of the Python documentation.
 
            Modified fork of CPython's ast module that parses `# type:` comments
 
            scripts for building documentation on docs.python.org
 
            PSF infrastructure configuration
 
            Communications from the Steering Council
 
            Configuration for buildbot.python.org
 
            Binaries that the cpython build process depends on
 
            Terjemahan Bahasa Indonesia untuk Dokumentasi Python
 Or  
    250,378 projects
     
    1,981,033 releases
     
    3,087,363 files
     
    441,622 users
     The Python Package Index (PyPI) is a repository of software for the Python programming language. 
        PyPI helps you find and install software developed and shared by the Python community.
         .
       
        Package authors use PyPI to distribute their software.
         .
       Trending projects as downloaded by the community Cython implementation of ksuid Library for interacting with fortnite services Pure-python XMPP library for asyncio Asynchronous console and interfaces for asyncio Pure-python, protocol agnostic SASL library for asyncio Hot off the press: the newest project releases A library for the Pixiv API. my saas in django Python Hacking Library By Nasir Ali A package for MLS-Models This is my personal toolkit. Status:  
 
          Developed and maintained by the Python community, for the Python community.
           
 
 © 2020  
 
 Supported by Python is a programming language. Python can be used on a server to create web applications. With our "Try it Yourself" editor, you can edit Python code and view the result. In our File Handling section you will learn how to open, read, write, and 
delete files. In our database section you will learn how to access and work with MySQL and MongoDB databases: Insert the missing part of the code below to output "Hello World". Learn by examples! This tutorial supplements all explanations with clarifying examples. Learn by taking a quiz! This quiz will give you a signal of how much you know, or do not know, about Python. You will also find complete function and method references: Download Python from the official Python web site:
   The perfect solution for professionals who need to balance work, family, and career building. More than 25 000 certificates already issued! The   documents your knowledge of HTML. The   documents your knowledge of advanced CSS. The   documents your knowledge of JavaScript and HTML DOM. The   documents your knowledge of Python. The   documents your knowledge of jQuery. The   documents your knowledge of SQL. The   documents your knowledge of PHP and MySQL. The   documents your knowledge of XML, XML DOM and XSLT. The   documents your knowledge of the Bootstrap framework. 
 
 
 
 
 
 
 
 
 If you want to report an error, or if you want to make a suggestion, do not hesitate to send us an e-mail: help@w3schools.com Your message has been sent to W3Schools. Black Lives Matter. |  Python is a general-purpose, versatile, and powerful programming language. It’s a great first language because it’s concise and easy to read. Whatever you want to do, Python can do it. From web development to machine learning to data science, Python is the language for you. Why we love it: Great first language Large programming community  Excellent online documentation Endless libraries and packages World-wide popularity Powerful and flexible Loading 
  is an  ,  ,    . Created by   and first released in 1991, Python's design philosophy emphasizes   with its notable use of  . Its   and   approach aim to help   write clear, logical code for small and large-scale projects. 
 Python is   and  . It supports multiple  , including   (particularly,  ),  , and  . Python is often described as a "batteries included" language due to its comprehensive  . 
 Python was conceived in the late 1980s as a successor to the  . Python 2.0, released in 2000, introduced features like   and a garbage collection system with  .
 Python 3.0, released in 2008, was a major revision of the language that is not completely  , and much Python 2 code does not run unmodified on Python 3.
 The Python 2 language was officially discontinued in 2020 (first planned for 2015), and "Python 2.7.18 is the last Python 2.7 release and therefore the last Python 2 release."  No more security patches or other improvements will be released for it.  With Python 2's  , only  Python 3.5.x  and later are supported.
 Python   are available for many  . A global community of programmers develops and maintains  , a    . A non-profit organization, the  , manages and directs resources for Python and CPython development.
 Python was conceived in the late 1980s  by   at   (CWI) in the   as a successor to the   (itself inspired by  ),  capable of   and interfacing with the   operating system.  Its implementation began in December 1989.  Van Rossum shouldered sole responsibility for the project, as the lead developer, until 12 July 2018, when he announced his "permanent vacation" from his responsibilities as Python's  , a title the Python community bestowed upon him to reflect his long-term commitment as the project's chief decision-maker.  He now shares his leadership as a member of a five-person steering council.  In January 2019, active Python core developers elected Brett Cannon, Nick Coghlan, Barry Warsaw, Carol Willing and Van Rossum to a five-member "Steering Council" to lead the project. 
 Python 2.0 was released on 16 October 2000 with many major new features, including a     and support for  . 
 Python 3.0 was released on 3 December 2008. It was a major revision of the language that is not completely  .  Many of its major features were   to Python 2.6.x  and 2.7.x version series.  Releases of Python 3 include the   utility, which automates (at least partially) the translation of Python 2 code to Python 3. 
 Python 2.7's   date was initially set at 2015 then postponed to 2020 out of concern that a large body of existing code could not easily be forward-ported to Python 3. 
 Python is a  .   and   are fully supported, and many of its features support   and   (including by   and   (magic methods)).  Many other paradigms are supported via extensions, including   and  . 
 Python uses   and a combination of   and a cycle-detecting garbage collector for  .  It also features dynamic   ( ), which binds method and variable names during program execution.
 Python's design offers some support for   in the   tradition. It has  ,  , and   functions;  ,  , sets, and   expressions.  The standard library has two modules (itertools and functools) that implement functional tools borrowed from   and  . 
 The language's core philosophy is summarized in the document   ( ), which includes   such as: 
 Rather than having all of its functionality built into its core, Python was designed to be highly  . This compact modularity has made it particularly popular as a means of adding programmable interfaces to existing applications. Van Rossum's vision of a small core language with a large standard library and easily extensible interpreter stemmed from his frustrations with  , which espoused the opposite approach. 
 Python strives for a simpler, less-cluttered syntax and grammar while giving developers a choice in their coding methodology. In contrast to  's " " motto, Python embraces a "there should be one—and preferably only one—obvious way to do it" design philosophy.   , a Fellow at the Python Software Foundation and Python book author, writes that "To describe something as 'clever' is   considered a compliment in the Python culture." 
 Python's developers strive to avoid  , and reject patches to non-critical parts of the   reference implementation that would offer marginal increases in speed at the cost of clarity.  When speed is important, a Python programmer can move time-critical functions to extension modules written in languages such as C, or use  , a  .   is also available, which translates a Python script into C and makes direct C-level API calls into the Python interpreter.
 An important goal of Python's developers is keeping it fun to use. This is reflected in the language's name—a tribute to the British comedy group  —and in occasionally playful approaches to tutorials and reference materials, such as examples that refer to spam and eggs (from a  ) instead of the standard  . 
 A common   in the Python community is  , which can have a wide range of meanings related to program style. To say that code is pythonic is to say that it uses Python idioms well, that it is natural or shows fluency in the language, that it conforms with Python's minimalist philosophy and emphasis on readability. In contrast, code that is difficult to understand or reads like a rough transcription from another programming language is called  .
 Users and admirers of Python, especially those considered knowledgeable or experienced, are often referred to as  . 
 Python is meant to be an easily readable language. Its formatting is visually uncluttered, and it often uses English keywords where other languages use punctuation. Unlike many other languages, it does not use   to delimit blocks, and semicolons after statements are optional. It has fewer syntactic exceptions and special cases than   or  . 
 Python uses   indentation, rather than   or keywords, to delimit  . An increase in indentation comes after certain statements; a decrease in indentation signifies the end of the current block.  Thus, the program's visual structure accurately represents the program's semantic structure.  This feature is sometimes termed the  , which some other languages share, but in most languages indentation doesn't have any semantic meaning.
 Python's   include (among others):
 Python does not support   optimization or  , and, according to Guido van Rossum, it never will.  However, better support for  -like functionality is provided in 2.5, by extending Python's  .  Before 2.5, generators were    ; information was passed unidirectionally out of the generator. From Python 2.5, it is possible to pass information back into a generator function, and from Python 3.3, the information can be passed through multiple stack levels. 
 Some Python   are similar to languages such as   and  , while some are not:
 In Python, a distinction between expressions and statements is rigidly enforced, in contrast to languages such as  ,  , or  . This leads to duplicating some functionality. For example:
 Statements cannot be a part of an expression, so list and other comprehensions or  , all being expressions, cannot contain statements. A particular case of this is that an assignment statement such as   cannot form part of the conditional expression of a conditional statement. This has the advantage of avoiding a classic C error of mistaking an assignment operator   for an equality operator   in conditions:   is syntactically valid (but probably unintended) C code but   causes a syntax error in Python.
  on objects are   attached to the object's class; the syntax   is, for normal methods and functions,   for  . Python methods have an explicit   parameter to access  , in contrast to the implicit   (or  ) in some other object-oriented programming languages (e.g.,  ,  ,  , or  ). 
 Python uses   and has typed objects but untyped variable names. Type constraints are not checked at  ; rather, operations on an object may fail, signifying that the given object is not of a suitable type. Despite being  , Python is  , forbidding operations that are not well-defined (for example, adding a number to a string) rather than silently attempting to make sense of them.
 Python allows programmers to define their own types using  , which are most often used for  . New   of classes are constructed by calling the class (for example,   or  ), and the classes are instances of the     (itself an instance of itself), allowing   and  .
 Before version 3.0, Python had two kinds of classes:   and  .  The syntax of both styles is the same, the difference being whether the class   is inherited from, directly or indirectly (all new-style classes inherit from   and are instances of  ). In versions of Python 2 from Python 2.2 onwards, both kinds of classes can be used. Old-style classes were eliminated in Python 3.0.
 The long term plan is to support   and from Python 3.5, the syntax of the language allows specifying static types but they are not checked in the default implementation, CPython. An experimental optional static type checker named   supports compile-time type checking. 
 
 
 Python has the usual symbols for arithmetic operators ( ,  ,  ,  ), the floor division operator   and the     (where the remainder can be negative,  e.g.  ). It also has   for  , e.g.   and  , and a matrix multiply operator   .  These operators work like in traditional math; with the same  , the operators   (   and   can also be   to represent positive and negative numbers respectively).
 Division between integers produces floating point results. The behavior of division has changed significantly over time: 
 In Python terms,   is   (or simply  ), and   is     before version 3.0 is  . 
 Rounding towards negative infinity, though different from most languages, adds consistency. For instance, it means that the equation   is always true. It also means that the equation   is valid for both positive and negative values of  . However, maintaining the validity of this equation means that while the result of   is, as expected, in the   [0,  ), where   is a positive integer, it has to lie in the interval ( , 0] when   is negative. 
 Python provides a   function for   a float to the nearest integer. For  , Python 3 uses  :   and   both produce  .  Versions before 3 used  :   is  ,   is  . 
 Python allows boolean expressions with multiple equality relations in a manner that is consistent with general use in mathematics. For example, the expression   tests whether   is less than   and   is less than  .   C-derived languages interpret this expression differently: in C, the expression would first evaluate  , resulting in 0 or 1, and that result would then be compared with  . 
 Python uses   for all integer operations. The   type/class in the   module provides decimal floating point numbers to a pre-defined arbitrary precision and several rounding modes.  The   class in the   module provides arbitrary precision for  . 
 Due to Python's extensive mathematics library, and the third-party library   that further extends the native capabilities, it is frequently used as a scientific scripting language to aid in problems such as numerical data processing and manipulation. 
  program:
 Program to calculate the   of a positive integer:
 
 Python's large  , commonly cited as one of its greatest strengths,  provides tools suited to many tasks. For Internet-facing applications, many standard formats and protocols such as   and   are supported. It includes modules for creating  , connecting to  ,  , arithmetic with arbitrary-precision decimals,  manipulating  , and  .
 Some parts of the standard library are covered by specifications (for example, the   (WSGI) implementation   follows PEP 333 ), but most modules are not. They are specified by their code, internal documentation, and  . However, because most of the standard library is cross-platform Python code, only a few modules need altering or rewriting for variant implementations.
 As of November 2019,  the   (PyPI), the official repository for third-party Python software, contains over 200,000  packages with a wide range of functionality, including:
 Most Python implementations (including CPython) include a   (REPL), permitting them to function as a   for which the user enters statements sequentially and receives results immediately.
 Other shells, including   and  , add further abilities such as improved auto-completion, session state retention and  .
 As well as standard desktop  , there are  -based IDEs;   (intended for developing science and math-related Python programs);  , a browser-based IDE and hosting environment; and Canopy IDE, a commercial Python IDE emphasizing  . 
  is the   of Python. It is written in  , meeting the   standard with several select   features.  It compiles Python programs into an intermediate   which is then executed by its  .  CPython is distributed with a large standard library written in a mixture of C and native Python. It is available for many platforms, including   (Vista and later; supported   and older, with by now unsupported Python 2.7) and most modern   systems. Platform portability was one of its earliest priorities,  in Python 1 and 2 time-frame, even supporting   and  , while since support has been dropped for a lot of platforms.
  is a fast, compliant interpreter of Python 2.7 and 3.6.  Its   brings a significant speed improvement over CPython but several libraries written in C cannot be used with it. 
  is a significant fork of CPython that implements  ; it does not use the C memory stack, thus allowing massively concurrent programs. PyPy also has a stackless version. 
  and   are Python 3 variants optimized for  . This includes  . 
 Other just-in-time Python compilers have been developed, but are now unsupported:
 In 2005,   released a Python interpreter for the   mobile phones named  . It includes many of the modules from the CPython implementations and some additional modules to integrate with the   operating system. The project has been kept up-to-date to run on all variants of the S60 platform, and several third-party modules are available. The Nokia   also supports Python with   widget libraries, enabling programs to be written and run on the target device. 
 There are several compilers to high-level  , with either unrestricted Python, a restricted subset of Python, or a language similar to Python as the source language:
 A performance comparison of various Python implementations on a non-numerical (combinatorial) workload was presented at EuroSciPy '13.  Python's performance compared to other programming languages has also been benchmarked by  . 
 Python's development is conducted largely through the   (PEP) process, the primary mechanism for proposing major new features, collecting community input on issues and documenting Python design decisions.  Python coding style is covered in PEP 8.  Outstanding PEPs are reviewed and commented on by the Python community and the steering council. 
 Enhancement of the language corresponds with development of the CPython reference implementation. The mailing list python-dev is the primary forum for the language's development. Specific issues are discussed in the     hosted at  .  Development originally took place on a   source-code repository running  , until Python moved to   in January 2017. 
 CPython's public releases come in three types, distinguished by which part of the version number is incremented:
 Python 3.9 alpha1 was announced in November 2019  and with the adoption of a new yearly release cadence,  the first release of 3.9 is slated for November 2020. 
 Many   are also released as previews and for testing before final releases. Although there is a rough schedule for each release, they are often delayed if the code is not ready. Python's development team monitors the state of the code by running the large   suite during development, and using the     system. 
 The major   on Python is  . There are also special Python mentoring programmes, such as  .
 Python's name is derived from the British comedy group  , whom Python creator Guido van Rossum enjoyed while developing the language. Monty Python references appear frequently in Python code and culture;  for example, the   often used in Python literature are   instead of the traditional  .  The official Python documentation also contains various references to Monty Python routines. 
 The prefix   is used to show that something is related to Python. Examples of the use of this prefix in names of Python applications or libraries include  , a   of   to Python (commonly used to create games);   and  , which bind   and   to Python respectively; and  , a Python implementation originally written in Python.
 Python API documentation generators include:
 Since 2003, Python has consistently ranked in the top ten most popular programming languages in the   where, as of February 2020 , it is the third most popular language (behind  , and  ).  It was selected Programming Language of the Year in 2007, 2010, and 2018. 
 An empirical study found that scripting languages, such as Python, are more productive than conventional languages, such as C and Java, for programming problems involving string manipulation and search in a dictionary, and determined that memory consumption was often "better than Java and not much worse than C or C++". 
 Large organizations that use Python include  ,  ,   ,   ,   ,   ,   ,  ,    and some smaller entities like   and  .  The social news networking site   is written entirely in Python. 
 Python can serve as a   for  , e.g., via   for the  .  With  , a standard API has evolved to facilitate these applications.   like  ,  ,  ,  ,  ,  ,  ,   and   support developers in the design and maintenance of complex applications.   and   can be used to develop the client-side of Ajax-based applications.   can be used as   to a relational database.   is a framework to program communications between computers, and is used (for example) by  .
 Libraries such as  ,   and   allow the effective use of Python in  ,  with specialized libraries such as   and   providing domain-specific functionality.   is a   with a   programmable in Python: its library covers many aspects of  , including  ,  ,  ,  , and  . 
 Python has been successfully embedded in many software products as a scripting language, including in   software such as  , 3D parametric modeler like  , 3D animation packages such as  ,  ,  ,  ,  ,  ,  ,  ,  , the visual effects compositor  , 2D imaging programs like  ,   ,   and  ,  and   programs like   and  .   uses Python as a   to show complex structures such as C++ containers.   promotes Python as the best choice for writing scripts in  .  It has also been used in several video games,  and has been adopted as first of the three available   in  , the other two being   and  . 
 Python is commonly used in   projects and machine learning projects with the help of libraries like  ,  ,   and  .  As a scripting language with  , simple syntax and rich text processing tools, Python is often used for  . 
 Many operating systems include Python as a standard component. It ships with most  ,    (using Python 2.7),   (as a package),  ,   (as a package) and   and can be used from the command line (terminal). Many Linux distributions use installers written in Python:   uses the   installer, while   and   use the   installer.   uses Python in its  ,  .
 Python is used extensively in the   industry, including in exploit development. 
 Most of the   software for the   XO, now developed at  , is written in Python.  The     project has adopted Python as its main user-programming language.
  includes Python, and intends to replace Java with Python. Its Python Scripting Provider is a core feature  since Version 4.0 from 7 February 2013.
 Python's design and philosophy have influenced many other programming languages:
 Python's development practices have also been emulated by other languages. For example, the practice of requiring a document describing the rationale for, and issues surrounding, a change to the language (in Python, a PEP) is also used in  ,   ,  and Swift. 
 
 
        When old is gold, these are the best retro games that make us misty eyed.
     We’re living in a golden age of gaming, with an incredible range of interactive experiences to suit every taste. Even so, it’s hard not to occasionally pine for the simpler days of the arcade era, where the best retro games - those fantastic 8-bit and 16-bit titles - turned us into the healthy, sleep-shirking addicts we are today. Without further ado, here are the top 20 retro games that we still can’t get enough of. Where possible we've added links to let you play these old gems on modern hardware, like the   and Sony PS4.
 Upvote your favourite retro games and use the suggestion box at the bottom to add games you think deserve a place in this hall of fame.  Having pretty much invented the platform game, Nintendo reinvented it with the secret-packed Super Mario Bros. 3, then repeated it with Super Mario World. The two best side-scrollers of all time, it’s a heck of a job to separate them. The sprawling ambition of Super Mario Bros. 3 or the invention of Super Mario World? The Frog Suit or Yoshi? The Super Leaf or the Cape Feather? We’ve plumped for SMB3, but they’re so close to gaming perfection, there’s nothing in it
 If Super Metroid taught us to fear the unknown, Link’s epic quest made it exciting again. A top-down Hyrule rammed with secrets and surprises, it’s a delight to explore. Not least when you figure out how the light and dark worlds slot together. Unlike these days where you’re given a nudge if you stray too far, here you’re encouraged to get gloriously, hopelessly lost – and you’ll have a whale of a time doing so.
 It’s smoky arcades filled with old cabinets that have been left scarred from cigarette burns, and unused credits sliding down onto floors that are perpetually sticky with cheap, stale booze. It’s teaching friends how to do the perfect dragon punch motion. It’s beating that bigger kid by doing Blanka’s electric attack. It’s unlocking Akuma and then immediately losing half of your life bar within seconds. Turbo might be the definitive version of Street Fighter II, but whichever one you played, the memories will no doubt still vividly linger.
 It’s odd to think that a game centring on finding the best way to successfully arrange a group of coloured blocks should have been at its best when played on a machine that was incapable of displaying more than four shades of greenish-grey. But, regardless, the Game Boy version of Alexei Pajitnov’s opus was simply the perfect match between game and hardware.
 Sega’s spiny speed merchant proved himself a worthy rival to Nintendo’s Mario with his Mega Drive debut. Yet it was the spectacular loops, corkscrews and clever environmental tricks in the follow-up that proved his makers carried the same swagger. With co-op partner Tails in tow (whose real name, Miles Prower, is one of gaming’s best dreadful puns) this blistering adventure was one of the finest two-player games of the 16-bit era and still leaves many of the modern Sonic games for dust.
 While everyone has their favourite Mario Kart – from the four-player-thrills of Mario Kart 64 to the weaponised mayhem of Double Dash!! – few would deny the SNES game’s claim to top spot. It’s aged beautifully – and, unlike many of its successors, every victory is hard-earned. Gaming’s finest spin-off. A high-end car, a beautiful girl, blue skies and a long strip of road to the horizon. It’s not so much a race as a high-speed cruise, taking you on the ultimate US road trip.
 The game that launched the career of a certain plumber, Nintendo’s 1981 arcade hit was pivotal. Having failed to crack the US, president Hiroshi Yamauchi convinced young designer Shigeru Miyamoto to create a new game. Jumpman (renamed Mario, after the US arm’s landlord, for the game’s Stateside launch) and his simian nemesis gobbled enough quarters to keep Nintendo afloat and launch countless Kong spinoffs (pictured). The rest is history.
 Two players, two pads, too many fizzy drinks: the only way to play Sega’s bruising brawler was with a partner. It was a rival to Capcom’s Final Fight, but this game definitely had the edge, which was partly due to Yuzo Koshiro’s particularly memorable score. There aren’t many games to have ever captured the sense of bleak isolation as expertly as this SNES classic. As bounty hunter Samas Aran dropped into a desolate world, it’s an homage to Alien, evoking the same gnawing tension as Ridley Scott’s cinematic horror, while the brooding, synth-led soundtrack prompted further shivers.
 Gaming’s great gift is allowing us to indulge in the kind of behaviour society frowns upon. Doing your job well gets you the high score, but flinging papers all over the place and subverting suburbia is hella cathartic.
 Forget Gears Of War, Taito’s 1978 classic was the first cover shooter, as you attempt to fend off an extraterrestrial force. Your pulse would quicken along with the music as the aliens came closer, while blasting the flying saucer was as satisfying as a Call Of Duty headshot.
 A precursor to the modern first-person shooter, Duck Hunt didn’t allow you to blast zombies, mutants or even mutant zombies. But lowering the waterfowl population was just as satisfying. Perhaps it was the bundled NES Zapper – one of the finest lightguns we’ve wielded. Or maybe it was the chance to wipe the smirk off of that dog’s face. Ms. Pac-Man is the arcade original, but with more added in. It introduced new maps and was harder: and it made the yellow gobbler the most successful US-produced coin-op. This Atari masterpiece had four players crowd around a cabinet to finish its labyrinthine levels. This situated you perfectly for elbowing someone in the ribs if they ignored advice about shooting food. Atari’s take on table tennis brought the medium into the mainstream, but aside from its importance to the industry, it’s a great game in its own right. Two dials, two bats, one ball: it still works now.
 For a certain generation, football rivalry wasn’t just between Fifa and Pro Evo. It was the pace and banana shots of Kick Off versus the sharp passing game of Sensible Soccer. For our money, Sensi wins: it gave a glimpse at tiki-taka way before Barca made it fashionable.
 No retro list would be complete without a classic point-and-click adventure, and there’s none finer than Tim Schafer and Dave Grossman’s barmpot sci-fi. Tipping its cap to Fifties monster movies and Chuck Jones cartoons, its time-travel plotline affords you bizarre pleasures. Uproariously silly.
 If you think modern games are too easy, this Spectrum hit is the remedy. All 20 screens host a clutch of wild and unpredictable hazards. If it was released now, it would have an easy mode and a dubstep soundtrack; best stick with the original.
 Played at a faster pace than Donkey Kong, Chuckie Egg required pixel-perfect leaps. It was home grown, intense and satisfying.
 Emulator Online has all the retro games from Super Nintendo (SNES & NES), SEGA (Genesis & Mega Drive), Game Boy (GBA, GBC, GB), N64, Nintendo DS and Neo-Geo Games. Game Boy Advance games and all other games are in  ! Play all the Retro Games that you used to play back in the day, and with our recommendation engine you can find the perfect game for countless hours of fun. This includes classic hit titles like  ,  ,  ,  ,  .   |     |     |      |     |      |      |   © Copyright 2020 Emulator Online. All rights reserved. Artwork and games are copyright to their respective owners.  EmulatorOnline.com is NOT endorsed or sponsored by Nintendo  You can read how we use cookies in our  . Welcome to the official Retro Games Website JavaScript is required to view the Walmart Canada website.   Please   or  Cookies are small pieces of information stored securely on your computer. A browser capable of storing cookies is required to view the Walmart Canada website. We use cookies to save information like your language preference and the nearest Walmart store. Personal information like your shipping address is never saved in a cookie. Please   or  . You may also   without cookies. Les témoins sont de petits renseignements stockés de façon sécuritaire dans votre ordinateur. Un navigateur capable de stocker des témoins est requis pour consulter le site Web de Walmart Canada. Nous utilisons des témoins pour sauvegarder des renseignements, comme vos préférences en matière de langue et de magasin. Vos renseignements personnels, comme votre adresse d'expédition, ne sont jamais sauvegardés dans un témoin. Veuillez   ou  . Vous pouvez aussi   sans témoins. If you’re the kind of gamer who thinks the industry was at its best before motion-sensing controls and other bells and whistles, browse the retro games at Amazon.com to rediscover your favorite titles from a simpler time.  You’ll find a wide selection of retro games for legendary  . You can relive the golden age of the home arcade with classic titles for Atari, including Q*Bert, Pac-Man, Frogger, and more. Spurred on the by the popularity of early Atari systems, one of the most successful game consoles of all time was the original Nintendo Entertainment System, originally released in 1985. The cutting edge 8-bit graphics and sound wowed gamers, and titles like Super Mario Brothers, The Legend of Zelda, Castlevania and Final Fantasy are still producing sequels today. You can experience the roots of video game culture with retro games for these and other classic systems.  In the ‘90s, televisions got bigger, and gaming consoles got more powerful. Nintendo and Sega fought for the top spot with the Super Nintendo Entertainment System, and the Sega Genesis, respectively. You’ll find all the retro games for SNES and Genesis you loved back in the day in one convenient spot. From Golden Axe to Mega Man X, all your favorite 16-bit titles are available at the Amazon.com Retro games store.  Nintendo 64 and PlayStation ushered in a new era of gaming. Polygons replaced pixels, and 3D rendering entered into the gaming vocabulary. Retro gaming hits like Crash Bandicoot, Mario Kart 64, and 007: Goldeneye pushed the limits of technology, and created the most realistic virtual environments seen up to that point. We also have some retro games for systems that might not feel as old as they are, including PlayStation 2, Nintendo GameCube, and the original Xbox.  From the moment you get your sword in the Legend of Zelda, to doing a barrel roll in Star Fox 64, now you can relive classic scenes from all your favorite retro games.  There's a problem loading this menu right now. Play Retro Games is a collection of fan based games bringing you the best retro games available to play on your browser.  © Copyright 2018  . All Rights Reserved 
 Already have an account?  You must have javascript enabled in your browser settings in order to visit this site. New here?  
 
 2020 © RetroGames.cc    New here?  Arcade machines are a significant part of gaming history that interest in them remains high. This interest is mostly attributed to the experience and thrill of playing the classics in their intended form and setting. However, amid the pandemic more and more entertainment exists in the cloud, including virtual arcades and quarter arcades that bring coin-operated history home. The Nintendo Switch has become increasingly more difficult to get due to constraints in supply-chains and the economy. It does not help that demand for the portable console has also skyrocketed because people want to entertain themselves during the lockdown around the world. However, there are still retailers with stock for the cheaper Nintendo Switch Lite. The Mario Movie is scheduled to be in theatres by 2022. Nintendo president has said work on the movie is moving along at a reasonable pace and plans to be in theatres on time. The film is an attempt by Nintendo to offer a new form of entertainment with its characters. The Mario games are some of the most iconic in gaming history so Nintendo hopes it would have a similar effect in the movie industry. Under the hood, the Nintendo Switch console is essentially a gaming device made of smartphone components. The only difference between the Switch and a high-end smartphone are its slide on controllers and its association with a gaming giant. Switchroot is a group that got a build of Android running on Nintendo's console, which gives access to the Play Store and millions of apps. Tate Multimedia is developing Urban Trial Tricky which is an exclusive game for Nintendo's console in super-smooth 60fps. This new game brings familiar tricks and racing as the Urban Trial Freestyle game on the 3DS. The game is expected to be released this summer and is based in a cartoon themed city with three modes, multiple levels, and with optional modifications. Nintendo's console sales increase because of the hit title, Animal Crossing: New Horizons. The game is a life simulation which lets players escape to a deserted island and create their own world. Nintendo expects to sell around 20 million Switch consoles and 150 million Switch games this year. The large portion of these sales can be attributed to hit titles that appeal to a wide audience of gamers. Play emulator online within your browser. Start playing retro classic games you used to play and experience the nostalgia. All emulator games work in the highest quality available with the fastest speeds. Play emulator games on your PC, tablets, and mobile. PlayEmulator is a convenient way to play old games you used to own that got lost over time. Use the menu to browse games by emulator console or use the game tags for specific listings of games. , also known as   and  , is the playing or collecting of older  ,  , and/or   video games in contemporary times. Usually, retrogaming is based upon systems that are obsolete or discontinued. It is typically put into practice for the purpose of nostalgia, preservation or the need to achieve authenticity. 
 Retrogaming has three main activities; vintage retrogaming, retrogaming emulation, and ported retrogaming. Vintage retrogaming includes games that are played on the original hardware.   involves newer systems simulating old gaming systems, while ported retrogaming allows games to be played on modern hardware via   or compilations. Additionally, the term could apply to a newer game, but with features similar to those of older games, such as a "retro  " which features turn-based combat and an isometric camera perspective.
 Participants in the hobby are sometimes known as retrogamers in the United Kingdom, while the terms "classic gamers" or "old school gamers" are more prevalent in the United States. Similarly, the games are known as retrogames, classic games, or old school games. 
 Retrogaming has existed since the early years of the video game industry, but was popularized with the popularity of the Internet and emulation technology.  It is argued that the main reasons players are drawn to retrogames are nostalgia for different eras,  the idea that older games are more innovative and original,  and the simplicity of the games that requires less hours of gameplay.
 Retrogaming and   have been described as   activity and as aspects of the  . 
 The games and systems can be anything not in the current generation.  Retro games can include   as well as   for   platforms.   are also popular, and were frequently attributed to individual programmers. The distinction between what is considered retro and modern is heavily debated, but it usually coincides with either the shift from 2D to 3D games (making the fourth gen the last retro generation, and the fifth being the first modern),  the turn of the millennium and the increase in online gaming (making the fifth gen the last retro generation, and the sixth being the first modern), or the switch from RCA to HDMI cables for video and sound transfer (making the sixth gen the last retro generation, and the seventh being the first modern). Some games are played on the original hardware; others are played through  . Some retro games can still be played online using just the internet browser via DOS emulation.  In some cases, entirely new versions of the games are designed, or  . As well as playing games, a subculture of retrogaming has grown up around the  .
 Reasons that people use concerning playing video games on original hardware include:
 Without excessive modification, modern displays cannot present retro games properly, typically leading to distorted picture and sound quality. This is why many gamers resort to purchasing older   for the hobby. Other reasons may include that some games take advantage of the image stretching to create wider and more detailed displays, such as   or  .
 Prior to digital sound, older game systems would replicate different tones and notes based on a specific selection of chips. Newer displays may have trouble replicating these sounds exactly. 
 The ability to play certain games on their original hardware may vary depending on the console and the applicable region. Variations due to region are also known as  .
 In the wake of increasing nostalgia and the success of retro-compilations in the fifth, sixth, and seventh generations of consoles, retrogaming has become a   in modern games, as well. Modern retrogames impose limitations on color palette, resolution, and memory well below the actual limits of the hardware in order to mimic the look of older hardware. These may be based on a general concept of retro, as with  , or an attempt to imitate a specific piece of hardware, as with   and its   color palette.
 This concept, known as Deliberate Retro  and NosCon,  began to gain traction thanks in part to the independent gaming scene,  where the short development time was attractive and commercial viability was not a concern. Major publishers have embraced modern retrogaming with releases such as  , an attempt to mimic NES hardware;  , a compilation of new games on faux-NES hardware; and Sega's   remake, which uses emulated   hardware running on   to create a 16-bit reimagining of the 8-bit original.
 Vintage retrogaming involves players collecting the original hardware, cartridges, and discs the video games were originally released on.  The hardware collected includes arcade systems, old home consoles, and their cartridges and discs. Some of these collectables can be fairly expensive and hard to find, limiting the access to these old games.  The vast majority, however, sell for much less than their retail price. 
 The popularity of vintage retrogaming has led to the circulation of pirated copies of retro games, which are generally considered to lack the collector value of the original cartridges and discs. 
 Retrogaming emulation involves older gaming systems being emulated on new hardware. It bypasses the need to collect old consoles and original games. ROMs, read only memory files, are taken directly from the original cartridge or disc from third parties. They are then typically put online through file sharing sites and played via emulators on modern hardware.  They are also often sold as re-releases, typically in compilations containing multiple games running on emulation software.  Since emulation is a more accessible way to take part in retrogaming, it helped to popularize and expand on the hobby. 
 Ported retrogaming involves old games being played on new systems, just as emulation. It differs from emulation because the games are rewritten for the new system and don't use the original ROM files.  Ported games are available through official collections, console-based downloads, and  .  Ported retrogaming is comparatively rare, since emulation is a much easier and more accurate method of running retro games on modern hardware.
 Modern retrogaming may sometimes be more broadly applied to games that feature retro-style designs and reimaginings with more modern graphics. These enhanced   include  ,  ,  ,  . Some are based directly upon the enhanced emulation of original games, as with Nintendo's  .
 When remakes are created by an individual or a group of enthusiasts without commercial motivation, such games sometimes are also called  . These are often motivated by the phenomenon of  , which is the discontinuation of sales and support by the original producers. Examples of   remakes are  ,  , and  .
 The nostalgia-based revival of older game styles has also been accompanied by the development of the modern   of game music. Chiptunes are characterized by severe limitations of sound imposed by the author's self-restriction to using only the original sound chips from 8-bit or 16-bit games. These compositions are featured in many retro-style modern games and are popular in the  .
 
With the new possibility of the   in mid-2000 the commercial distribution of old classical game titles became feasible again as deployment and storage costs dropped significantly:  A digital distributor specialized in bringing old games out of abandonware is   (formerly called  ) who started 2008 to search for copyright holders of classic games to re-release them legally and  -free. 
 Notable online platforms for classic video game re-releases include Nintendo's   and Sony's  .
 Mobile application developers have been purchasing the rights and licensing to re-release vintage arcade games on iOS and Android operating systems. Some publishers are creating spinoffs to their classic games, keeping the core gameplay while adding new features, levels, and styles of play.
  have been released or licensed by companies such as  , Sega, and  . These systems include stand-alone game libraries and plug directly into the user's television. 
 The video game industry has an active audience, including the retrogaming sector. The retrogaming community has both online and physical spaces where retrogames are discussed, collected, and played. 
 There are several websites and online forums devoted to both retrogaming and video games in general. The content on these online platforms typically includes reviews of older games, interviews with developers, fan-made content, game walkthroughs, and message boards for discussions.  Many gameplay videos posted online feature attempts at breaking   or   records.
 The competitive   traces its legacy from old-school arcades.  Some   have continued to receive arcade releases after the end of the arcade era.   Face-to-face competition of   has been featured in the  . 
 There are several events that retrogamers can take part in. Exhibits typically include vendors, retrogames available to play, tournaments, costumes, and live music, such as the Vancouver Retro Gaming Expo, run by Phase 3 events. This event has been occurring annually since March 17, 2012. 
 Retrogaming is recognized by   worldwide.  For example, the   arcade museum of  ,   was founded in 2002  and the   was founded in 1997.  Some classical art museums bear a video gaming retrospective, as with 2012's   exhibition titled   or as part of the   "Applied Design" exhibition in 2013.  Starting in 2015,   adds games annually to the  . In 2016, the first museum dedicated solely to the history of the videogame industry, The  , was opened in Frisco, Texas.
 Though many   titles are available for free download on third-party websites, the duration of copyright on creative works in most countries is far longer than the era of home computing.
 Emulators are typically created by third parties, and the software they run is often taken directly from the original games and put online for free download.  While it is completely legal for anyone to create an emulator for any hardware, unauthorized distribution of the code for a retro game is an infringement of the game's copyright.  Some companies have made public statements regarding the issues, such as Nintendo, stating that "the introduction of emulators created to play illegally copied Nintendo software represents the greatest threat to date in the intellectual property rights of video game developers".  However, video game developers and publishers typically turn a blind eye to emulation.  One reason for this is that at any given time, most of the games illegally distributed for emulation are not presently being sold by the company which owns the game, and so the damages the company would collect in the event of a successful lawsuit would most likely be negligible. 
 Retro Gaming ON SALE Retro Game Consoles Retro Gaming Accessories Retro Games In recent years, playing classic blasts from the past—aka retro gaming—has seen a huge rise in popularity. There’s  good reason too! Kids who gamed in the 80s and 90s are now adults and going back to relive your favourite childhood games is nothing short of amazing!  Retro gaming is a great way for families to introduce their children to the classic games of yesteryear. There are so many retro games that are rich and full of history. There are thousands of retro games just waiting for you to rediscover or discover for the first time with your family.  There are many choices when it comes to  . Plug and play retro consoles allow you to connect the console to your TV and come pre-loaded with some of the systems most notable games. For example, the C64 mini console is a micro-sized version of the world’s best-selling home computer—the Commodore 64. The console comes with 20 games pre-load and with a firmware update from the manufacture you can load your own c64 games on to it. Another example is Sony’s PlayStation Classic. It comes loaded with 20 games. Just plug it in and hook it up to your TV’s HDMI port and you are ready for fun.  There are also retro consoles that let you play using legacy game cartridges. This is a fantastic way for retro game collectors to enjoy these classic games. For example, the Retro-Bit 3-in1 Home System allows you to play SNES, NES and Sega Genesis games all in one machine! It comes with two controllers but also has six controller ports so that you can plug in original or third-party controllers.  Wireless controllers weren’t always the norm in gaming. As such, many retro game consoles come with exact wired replica controllers. And, many times the controller cords are simply not long enough. Fortunately, there are many   available at Best Buy Canada you can get to complement your retro gaming experience.  Controller extension cables, to extra controllers, to travel cases, to wireless controllers, to video cables and even AC adaptors—we’ve got you covered.  Did you know that Best Buy Canada sells retro games? If you like to  , make sure to check out our retro games section. We’ve got games for the SNES, GameCube, Gameboy Color, Gameboy Advance, PlayStation, PlayStation 2, Xbox and Sega Dreamcast!  Stock is always changing so make sure to visit our retro games section on a frequent basis. You never know what you might find!    In recent years, playing classic blasts from the past—aka retro gaming—has seen a huge rise in popularity. There’s  good reason too! Kids who gamed in the 80s and 90s are now adults and going back to relive your favourite childhood games is nothing short of amazing!  Retro gaming is a great way for families to introduce their children to the classic games of yesteryear. There are so many retro games that are rich and full of history. There are thousands of retro games just waiting for you to rediscover or discover for the first time with your family.  There are many choices when it comes to  . Plug and play retro consoles allow you to connect the console to your TV and come pre-loaded with some of the systems most notable games. For example, the C64 mini console is a micro-sized version of the world’s best-selling home computer—the Commodore 64. The console comes with 20 games pre-load and with a firmware update from the manufacture you can load your own c64 games on to it. Another example is Sony’s PlayStation Classic. It comes loaded with 20 games. Just plug it in and hook it up to your TV’s HDMI port and you are ready for fun.  There are also retro consoles that let you play using legacy game cartridges. This is a fantastic way for retro game collectors to enjoy these classic games. For example, the Retro-Bit 3-in1 Home System allows you to play SNES, NES and Sega Genesis games all in one machine! It comes with two controllers but also has six controller ports so that you can plug in original or third-party controllers.  Wireless controllers weren’t always the norm in gaming. As such, many retro game consoles come with exact wired replica controllers. And, many times the controller cords are simply not long enough. Fortunately, there are many   available at Best Buy Canada you can get to complement your retro gaming experience.  Controller extension cables, to extra controllers, to travel cases, to wireless controllers, to video cables and even AC adaptors—we’ve got you covered.  Did you know that Best Buy Canada sells retro games? If you like to  , make sure to check out our retro games section. We’ve got games for the SNES, GameCube, Gameboy Color, Gameboy Advance, PlayStation, PlayStation 2, Xbox and Sega Dreamcast!  Stock is always changing so make sure to visit our retro games section on a frequent basis. You never know what you might find!    © Best Buy Canada Ltd. 8800 Glenlyon Parkway, Burnaby, BC V5J 5K3 You have no items in your shopping cart. You have no items in your shopping cart. Thanks for visiting our online store and considering buying from us. As a family run business, our reputation is everything! If you ever have any concerns or questions, please let us know. Every product that you find here on our website is updated live with what we have in-store. As soon as a product sells online, it is picked, packaged and sent on it's way. We know it is important to find out the information you need when you need it! Feel free to send us a message via email, livechat, facebook or any other method you can think of.  
                
                Free shipping on all orders over $100 before tax.
                
               
                
                Item not as expected?  We will take care of that for you.
                
               
                
                We take care of our customers!
                
               
      490 Mapleview Dr. W, Barrie, ON 
 
      Toll-Free: 1-866-238-8251 Local: (705) 503-4263 
 
 
Mon-Fri  / 12:00PM - 8:00PM Sat / 12:00PM - 6:00PM Sun / 12:00PM - 5:00PM 
 
       
			 
             
			
			
			 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 RetroGames.cz - radio 
                                                                                                                                          
			Play Free Online Games, Play Retro Games Online, PS1, Gameboy, Sega, Game Gear, Nintendo, NES. All your favourite Retro Games Online. No Download, Play Retro Games in your Browser. Best Selection of Retro Games. Play Retro Games Online Now
		 Make yourself known:   
 
 Retro Gamer is part of Future plc, an international media group and leading digital publisher.  . ©
       . All rights reserved. England and Wales company registration number 2008885.
     Top New Games Out On Switch, PS4, Xbox One, And PC This Week -- July 26 - August 1, 2020 Crash Bandicoot 4 Brings The Nostalgia And That Old-School Challenge New Fable Announced During Xbox Event By   on  Even though we're looking down the barrel of the next-generation consoles, there's never been a better time to play the games of our past. And with all of the retro game consoles, arcade cabinets, and retro-style controllers--not to mention gadgets that make it possible to play old consoles on modern TVs--available to buy these days, it's never been easier, either. Even game collections for modern consoles like the PS4, Xbox One, and Nintendo Switch have made older games easier to play, thanks to developers like Digital Eclipse paying proper homage to the classics. Unfortunately, there can be some confusion when it comes to which products are worth your time because there are just so many of them. That's why we've tested and corralled a wide selection of great retro game consoles, gadgets, and more that you can feel confident in buying. And while there is a whole world of console modding that grows by the day, we've opted to keep this guide more accessible and selected the best retro consoles that are ready to play out of the box. There's never been a better time to play old games, with the number of FPGA-based consoles, miniature consoles, home-friendly arcade cabinets, and excellent collections, all of which pay appropriate tribute to the classics. The Mega Sg is Analogue's FPGA-based Sega Genesis console, and it's quite the machine. FPGA boards allow Analogue to create a console that works exactly like the retro console it's trying to replicate--think of it as hardware emulation as opposed to software emulation. In this case, it's the Sega Genesis. It boasts zero lag, 1080p output, and compatibility with the entire Genesis, Mega Drive, and Master System library (it comes with an adapter that lets you play Sega Master System games). It's also compatible with all of the original console's controllers and accessories, including the Sega CD and 32X. You can learn more about the Mega Sg at  . Just remember that you should snag an  , as the Mega Sg doesn't include any.   Analogue's attempt at the SNES resulted in another fantastic FPGA-based console called the Super Nt. Like the Mega Sg, it features 1080p output with zero lag and compatibility with its original console's entire library and accessories. It comes in four different colours as well--SNES, Super Famicom, Black, and Transparent. If you're looking for the best way to play Super Nintendo games on a modern TV, then   is the way to go. Also, be sure to pick up an   if you buy the Super Nt, as it doesn't come with any controllers.   Analogue's Nt Mini was an incredible FPGA-based console that replicated the NES, but unfortunately, the company finished its last run of the console in early 2020. Thankfully, RetroUSB's AVS is the next best thing, and it's significantly cheaper than the Nt Mini's $500 price tag. The AVS is another FPGA-based NES console that outputs at 720p via HDMI and features four NES controller ports, no accessory required. It also comes with ports for both NES games and Famicom titles and boasts compatibility with all licensed controllers and accessories as well as the Famicom Disk System. The AVS doesn't come with any controllers, so be sure to buy yourself an   to play with it. You can learn more about the AVS at  .   The Sega Genesis Mini comes pre-loaded with 40 of the console's most beloved games (and two games that weren't released on Genesis), including Sonic the Hedgehog, Streets of Rage 2, and Shinobi III as well as Gunstar Heroes, Castlevania: Bloodlines, and Contra: Hard Corps. As far as microconsoles go, this one has the best library and is ready for two-player multiplayer out of the box, thanks to the two included game pads.   The TurboGrafx-16 Mini is a great microconsole with a huge library of games from both the console's North American and Japanese libraries. Not all of the games included are gems, and some are impossible for English-only speakers to play, but there are still a lot of excellent pre-loaded titles, including Castlevania: Rondo of Blood, Seirei Senshi Spriggan, and Bomberman '94. The 8-bit console is represented wonderfully, making this a must-buy for any retro gaming fan.   The Neo Geo Arcade Stick Pro comes with 20 classic SNK fighting games built-in, similar to how the Sega Genesis Mini and TurboGrafx-16 Mini operate. However, you use the actual arcade stick-console hybrid as a controller as well. You can also plug   into the Arcade Stick Pro if you want to play multiplayer. And if you get the  , you can use it with the Switch and PS4. The best part is that the console also boasts hidden games, which you can download from   and transfer to your Arcade Stick Pro.   Arcade1Up makes excellent 3/4-scale cabinets that attempt to replicate classic machines with a handful of pre-loaded games. They come with excellent-feeling controls and buttons that are appropriate for their included titles and make for a fun way to play classic arcade games. NBA Jam cabinet Features online multiplayer and three games TMNT cabinet Comes with two TMNT games Star Wars cabinet Comes with three Star Wars games Mortal Kombat cabinet Comes with three MK games Pac-Man cabinet Comes with seven classic games Golden Tee cabinet Comes with four Golden Tee games   Modern TVs aren't the best for playing old video games, mostly due to the fact that they don't feature the right connections and normally don't support the low resolutions of the '90s and early 2000s. Thankfully, there are a number of ways to get around this and make even a 4K TV a great display for retro gaming. The EON GCHD Mk II is an incredible little device that you plug into the back of your GameCube to get a clean HDMI signal from the classic console. However, it doesn't work with all GameCubes. You need a model DOL-001 GameCube, which features both the digital and analog video outputs. Once the GCHD is plugged in, all you have to do is plug in an HDMI cable, and you're good to go.   The Super64 is EON's plug-and-play HDMI device for the N64, making for an equally easy setup and cleaner signal. Thankfully, it's compatible with all N64 models and is simple to use. All you do is plug it into the back of your N64 and then use an HDMI cable to connect it to your TV--just make sure your TV supports 480p. There's also a "Slick Mode" that applies a post-processing filter that smooths out edges. HD Retrovision cables are specifically designed for classic consoles to work with your TV's component inputs--just make sure your TV supports 240p, 480p, or whichever other resolution your classic console outputs. The company's cables provide clean, crisp, and beautiful images for a variety of consoles, including the Genesis, Saturn, SNES, Dreamcast, PS1, PS2, PS3, Wii, and Wii U. The image is even better if your console is RGB-compatible or modded. Unfortunately, the cables are quite popular, so you may have a hard time finding them in stock. Genesis HD Retrovision cables Compatible with Model 2 Genesis Genesis Model 1 adapter Adapter for Genesis HD Retrovision cables Saturn adapter Adapter for Genesis HD Retrovision cables PS1 adapter Adapter for Genesis HD Retrovision cables SNES HD Retrovision cables Compatible with SNES and SFC PS2/PS3 HD Retrovision cables Compatible with PS2 and PS3   The mClassic is a plug-and-play graphics processor that applies a layer of post-processing effects to whatever you're feeding through it via HDMI. It also scales content up to 4K. It's not going to change the experience radically, but what it does do is make consoles like the Nintendo Switch look sharper on a 4K TV. It works with any HDMI-connected device, including GameCubes with the GCHD adapter, any HDMI-compatible retro console, and even modern consoles.     It's hard to deny the fact that retro designs are still better for some games than most modern controllers, especially when it comes to playing ports or collections of those classic games. A lot of companies try to replicate old designs, but only a small few succeed in creating controllers that are worth your money. 8Bitdo is the best third-party controller company out there today. It makes quality products that not only emulate the classics but oftentimes improve them. The best part is that many of the controllers work on both modern and classic consoles. However, there are a number of other companies that have made some pretty great controllers, including clones of the GameCube controller and more. 8bitdo M30 with 2.4G receiver Works with Switch (docked) and Genesis Mini 8Bitdo M30 Bluetooth Works with Switch and PC Retro-Bit Genesis pad, wireless Works with Switch, PC, and Sega Genesis Retro-Bit Genesis pad, wired Works with Switch, PC, and Sega Genesis   8Bitdo SN30 Pro+ controller Works with Switch and PC 8Bitdo SN30/SF30 Pro controller Works with Switch and PC 8Bitdo SN30 Pro controller, wired Works with Switch and PC 8Bitdo N30 Bluetooth controller Works with Switch and PC 8Bitdo N30 Pro Bluetooth controller Works with Switch and PC   PDP Wired Fight Pad Pro Works with Switch PowerA Wireless GameCube-style controller Works with Switch PowerA Wired GameCube-style controller Works with Switch   Nowadays, there's an influx of new controllers designed for retro consoles. Of course, not all of them are quality--and even fewer stack up against the original pads. Thankfully, a handful of companies have created some great modern alternatives that replicate or even try to improve on the original designs. Many of 8Bitdo's controllers replicate the pads of classic consoles, and thankfully, they also produce a number of 2.4GHz and Bluetooth wireless receivers that can be plugged straight into the controller port of a number of different consoles. My suggestion is to go with 2.4GHz as the connection is less prone to latency. However, the Bluetooth receiver gives you more options for which controller you can use--you can use almost any Bluetooth-enabled controller with the receivers, including a DualShock 4. M30 Genesis controller Comes with wireless receiver for Genesis SN30 SNES controller Comes with wireless receiver for SNES   Sega Genesis Bluetooth receiver Compatible with Genesis and Bluetooth controllers SNES Bluetooth receiver Compatible with SNES and Bluetooth controllers NES Bluetooth receiver Compatible with NES and Bluetooth controllers     Let's be honest: the Dreamcast controller is not great. Unfortunately, Sega--a company that has made some of the best controllers ever--tried to innovate with its last controller, and it resulted in a pad that's not always comfortable or easy to use. And while Retro Fighters' new take on the Dreamcast controller isn't perfect, it does provide a more modern and comfortable feel. If you're looking for a new pad to play Dreamcast games with, the StrikerDC is worth a look.     The Retro Fighters Brawler64 controller puts a modern spin on the classic console's pad. Turning the ergonomics into that of a modern controller, it also slides the Z button up to where a modern pad's triggers are located--yes, there are two Z buttons that do the exact same thing. The big winner here, however, is the analog stick. Improving drastically on the N64's analog stick, the Brawler64's feels like a mix between the GameCube's stick and a more modern controller's stick. It's a much-appreciated improvement that feels great to use in games like Ocarina of Time and Super Mario 64.     Retro-Bit's Sega Saturn and Genesis controller are surprisingly great, and it's always awesome to have a wireless option. Both feel faithful to the original design and work great with their respective console's games. I've used the Sega Saturn controller a lot in X-Men vs Street Fighter, and I never feel like I'm at a disadvantage because I'm using the third-party controller. If you're looking for some new Sega pads, these are the ones to go with. Saturn wired controller Only compatible with Sega Saturn Saturn wireless controller Compatible with Saturn, Switch, PC, and more   Genesis wired controller Only compatible with Sega Genesis Genesis wireless controller Compatible with Genesis, Switch, PC, and more The KeyMander 2 is a great little device that lets you plug keyboards, mice, and other platforms' controllers into a console and use them to control your games. It requires a lot of setup and can be confusing at first, but it's a particularly useful device if you want to use modern controllers on consoles like the Xbox 360 and PS3. Unfortunately, it only works with specific devices that have USB ports, so you won't be able to use it on any system older than the PS3/360 era.     The great thing is that you don't even need a retro console to play its classic games these days. A lot of old favourites have made their way digitally to the PlayStation Store, Xbox Store, Steam, and other marketplaces. There have also been some excellent collections that compile the games of an entire series, developer, or theme. The ones we've selected below are all physical copies of these collections, but there are a number of great digital-only packages that compile the best games of our past. These include Castlevania Anniversary Collection and Contra Anniversary Collection, both of which are available on the PS4, Xbox One, Switch, and PC. Street Fighter 30th Anniversary Collection Available for PS4, Xbox One, and Switch Collection of Mana Available only on Switch Sega Genesis Classics Available on PS4, Xbox One, and Switch Mega Man Legacy Collection 1 + 2 Available only on Switch Mega Man X Legacy Collection 1 + 2 Available on PS4, Xbox One, and Switch     More Tech Picks From GameSpot     Use your keyboard!  to comment JavaScript is required to view the Walmart Canada website.   Please   or  Cookies are small pieces of information stored securely on your computer. A browser capable of storing cookies is required to view the Walmart Canada website. We use cookies to save information like your language preference and the nearest Walmart store. Personal information like your shipping address is never saved in a cookie. Please   or  . You may also   without cookies. Les témoins sont de petits renseignements stockés de façon sécuritaire dans votre ordinateur. Un navigateur capable de stocker des témoins est requis pour consulter le site Web de Walmart Canada. Nous utilisons des témoins pour sauvegarder des renseignements, comme vos préférences en matière de langue et de magasin. Vos renseignements personnels, comme votre adresse d'expédition, ne sont jamais sauvegardés dans un témoin. Veuillez   ou  . Vous pouvez aussi   sans témoins. Buy used video games, original game systems and old school gaming accessories for sale at the largest family run retro video game online store. Shop all our vintage 100% authentic products, with a free 120 day warranty and free domestic shipping on orders over $10. Signup to get   deals and coupons on all your favorite old video games and classic game consoles! 
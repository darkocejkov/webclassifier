
  or simply   is a   and   written by   for the   as a   replacement for the  .  First released in 1989,  it has been used as the default   shell for most   distributions and all releases of     prior to  .  A version  .  It is also the default user shell in   11. 
 Bash is a   that typically runs in a   where the user types commands that cause actions. Bash can also read and execute commands from a file, called a  . Like all Unix shells, it supports filename   (wildcard matching),  ,  ,  ,  , and   for   and  . The  ,  ,   variables and other basic features of the   are all copied from  . Other features, e.g.,  , are copied from   and  . Bash is a  -compliant shell, but with a number of extensions.
 The shell's name is an acronym for  , a   on the name of the   that it replaces  and the notion of being " ". 
 A   in Bash dating from version 1.03 (August 1989),  dubbed  , was discovered in early September 2014 and quickly led to a range of   across the  .  Patches to fix the bugs were made available soon after the bugs were identified.
  began   Bash on January 10, 1988,  after   became dissatisfied with the lack of progress being made by a prior developer.  Stallman and the   (FSF) considered a free shell that could run existing shell scripts so strategic to a completely free system built from BSD and GNU code that this was one of the few projects they funded themselves, with Fox undertaking the work as an employee of FSF.  Fox released Bash as a beta, version .99, on June 8, 1989,  and remained the primary maintainer until sometime between mid-1992  and mid-1994,  when he was laid off from FSF  and his responsibility was transitioned to another early contributor, Chet Ramey. 
 Since then, Bash has become by far the most popular shell among users of Linux, becoming the default interactive shell on that operating system's various distributions  (although   may be the default scripting shell) and on Apple's macOS releases before   in October 2019.  Bash has also been ported to   and distributed with   and  , to   by the   project, to   and to   via various terminal emulation applications.
 In September 2014, Stéphane Chazelas, a Unix/Linux specialist,  discovered a   in the program. The bug, first disclosed on September 24, was named   and assigned the numbers  - , CVE-  and CVE- . The bug was regarded as severe, since   scripts using Bash could be vulnerable, enabling  . The bug was related to how Bash passes function definitions to subshells through  . 
 The Bash   syntax is a   of the Bourne shell command syntax. Bash supports  ,   (Programmable Completion).  basic debugging  and   (using  ) since bash 2.05a  among other features. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc. Bash command syntax includes ideas drawn from the   (ksh) and the   (csh) such as command line editing,   (  command),  the directory stack, the   and   variables, and POSIX   syntax  .
 When a user presses the   within an interactive command-shell, Bash automatically uses  , since beta version 2.04,  to match partly typed program names, filenames and variable names. The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.
 Bash's syntax has many extensions lacking in the Bourne shell. Bash can perform integer calculations ("arithmetic evaluation") without spawning external processes. It uses the   command and the   variable syntax for this purpose. Its syntax simplifies  . For example, it can redirect   (stdout) and   (stderr) at the same time using the   operator. This is simpler to type than the Bourne shell equivalent ' '. Bash supports   using the   and  syntax, which substitutes the output of (or input to) a command where a filename is normally used. (This is implemented through   unnamed pipes on systems that support that, or via temporary   where necessary).
 When using the 'function' keyword, Bash function declarations are not compatible with Bourne/Korn/POSIX scripts (the Korn shell has the same problem when using 'function'), but Bash accepts the same function declaration syntax as the Bourne and Korn shells, and is POSIX-conformant. Because of these and other differences, Bash shell scripts are rarely runnable under the Bourne or Korn shell interpreters unless deliberately written with that compatibility in mind, which is becoming less common as Linux becomes more widespread. But in POSIX mode, Bash conforms with POSIX more closely. 
 Bash supports  . Since version 2.05b Bash can redirect   (stdin) from a "here string" using the   operator.
 Bash 3.0 supports in-process   matching using a syntax reminiscent of  . 
 In February 2009,  Bash 4.0 introduced support for  .  Associative array indices are strings, in a manner similar to   or  .>  They can be used to emulate multidimensional arrays. Bash 4 also switches its license to  ; some users suspect this licensing change is why MacOS continues to use older versions. 
 Brace expansion, also called alternation, is a feature copied from the  . It generates a set of alternative combinations. Generated results need not exist as files. The results of each expanded string are not sorted and left to right order is preserved:
 Users should not use brace expansions in portable shell scripts, because the   does not produce the same output.
 When brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally. Hence, a listing of JPEG and PNG images in the current directory could be obtained using:
 In addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots. Newer versions of Bash allow a third integer to specify the increment.
 When brace expansion is combined with variable expansion the variable expansion is performed   the brace expansion, which in some cases may necessitate the use of the   built-in, thus:
 When Bash starts, it executes the commands in a variety of  . Though similar to Bash shell script commands, which have execute permission enabled and an   like  , the initialization files used by Bash require neither.
 The skeleton   below is compatible with the Bourne shell and gives semantics similar to csh for the   and  . The   are tests to see if the   exists and is readable, simply skipping the part after the   if it is not.
 Some versions of   and   contain Bash system startup scripts, generally under the   directories. Bash calls these as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence. The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup. The startup scripts that launch the   may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the  . These issues can often be addressed using a   or   file to read the   — which provides the environment variables that Bash shell windows spawned from the window manager need, such as   or  .
 Invoking Bash with the   option or stating   in a script causes Bash to conform very closely to the  .  Bash shell scripts intended for   should take into account at least the POSIX shell standard. Some bash features not found in POSIX are: 
 If a piece of code uses such a feature, it is called a "bashism" – a problem for portable use. Debian's   and Vidar Holen's   can be used to make sure that a script does not contain these parts.  The list varies depending on the actual target shell: Debian's policy allows some extensions in their scripts (as they are in  ),  while a script intending to support pre-POSIX Bourne shells, like  's  , are even more limited in the features they can use. 
 Bash uses readline to provide keyboard shortcuts for command line editing using the default ( ) key bindings.   can be enabled by running  . 
 The Bash shell has two modes of execution for commands:  , and concurrent mode.
 To execute commands in batch (i.e., in sequence) they must be separated by the character ";", or on separate lines:
 in this example, when command1 is finished, command2 is executed.
 A [Background process|background execution] of command1 can occur using (symbol &) at the end of an execution command, and process will be executed in background returning immediately control to the shell and allowing continued execution of commands.
 Or to have a concurrent execution of two command1 and command2, they must be executed in the Bash shell in the following way:
 In this case command1 is executed in the background   symbol, returning immediately control to the shell that executes command2 in the foreground.
 A process can be stopped and control returned to bash by typing  +  while the process is running in the foreground. 
 A list of all processes, both in the background and stopped, can be achieved by running  :
 In the output, the number in brackets refers to the job id. The plus sign signifies the default process for   and  . The text "Running" and "Stopped" refer to the  . The last string is the command that started the process. 
 The state of a process can be changed using various commands. The   command brings a process to the foreground, while   sets a stopped process running in the background.   and   can take a job id as their first argument, to specify the process to act on. Without one, they use the default process, identified by a plus sign in the output of  . The   command can be used to end a process prematurely, by sending it a  . The job id must be specified after a percent sign:
 Bash supplies "conditional execution" command separators that make execution of a command contingent on the   set by a precedent command. For example:
 Where   is only executed if the   (change directory) command was "successful" (returned an exit status of zero) and the   command would only be executed if either the   or the   command return an "error" (non-zero exit status).
 For all commands the exit status is stored in the special variable  . Bash also supports   and   forms of conditional command evaluation.
 An external command called   reports Bash shell bugs. When the command is invoked, it brings up the user's default editor with a form to fill in. The form is mailed to the Bash maintainers (or optionally to other email addresses). 
 Bash programmable completion,   and   commands  have been available since the beta version of 2.04  in 2000.  These facilities allow complex intelligent completion, such as offering to tab-complete available program options and then, after the user selects an option that requires a filename as its next input, only auto-completing file paths (and not other options) for the next token.
 
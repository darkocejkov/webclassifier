bash - GNU Bourne-Again SHell
 
  [options] [file]
 
 Bash is Copyright © 1989-2009 by the Free Software Foundation, Inc.
 
 
  is an  -compatible command language interpreter that executes commands read from the standard input or from a file.   also
incorporates useful features from the   and   shells (  and  ).
  is intended to be a conformant implementation of the Shell and Utilities portion of the IEEE POSIX specification (IEEE Standard 1003.1).
  can be configured to be POSIX-conformant by default.
 
 In addition to the single-character shell options documented in the description of the   builtin command,   interprets the following
options when it is invoked:
 If the   option is present, then commands are read from  . If there are arguments after the  , they are assigned to the
positional parameters, starting with  .

 
 If the   option is present, the shell is  .

 
 Make   act as if it had been invoked as a login shell (see   below).

 
 If the   option is present, the shell becomes   (see   below).

 
 If the   option is present, or if no arguments remain after option processing, then commands are read from the standard input. This option allows
the positional parameters to be set when invoking an interactive shell.

 
 A list of all double-quoted strings preceded by   is printed on the standard output. These are the strings that are subject to language translation
when the current locale is not   or  . This implies the   option; no commands will be executed.
 A   signals the end of options and disables further option processing. Any arguments after the   are treated as filenames and arguments. An
argument of   is equivalent to  .
 Display a usage message on standard output and exit successfully.
 Do not read and execute the personal initialization file   if the shell is interactive. This option is on by default if the shell is invoked
as  .
 
 
 If arguments remain after option processing, and neither the   nor the   option has been supplied, the first argument is assumed to be the
name of a file containing shell commands. If   is invoked in this fashion,   is set to the name of the file, and the positional parameters
are set to the remaining arguments.   reads and executes commands from this file, then exits.  's exit status is the exit status of the
last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory,
and, if no file is found, then the shell searches the directories in   for the script.
 
 A   is one whose first character of argument zero is a  , or one started with the   option.
 An   shell is one started without non-option arguments and without the   option whose standard input and error are both connected
to terminals (as determined by  (3)), or one started with the   option.   is set and   includes   if
  is interactive, allowing a shell script or a startup file to test this state.
 The following paragraphs describe how   executes its startup files. If any of the files exist but cannot be read,   reports an error.
Tildes are expanded in file names as described below under   in the   section.
 When   is invoked as an interactive login shell, or as a non-interactive shell with the   option, it first reads and executes
commands from the file  , if that file exists. After reading that file, it looks for  ,  , and
 , in that order, and reads and executes commands from the first one that exists and is readable. The   option may be used
when the shell is started to inhibit this behavior.
 When a login shell exits,   reads and executes commands from the files   and  , if the files
exists.
 When an interactive shell that is not a login shell is started,   reads and executes commands from  , if that file exists. This may
be inhibited by using the   option. The     option will force   to read and execute commands from  
instead of  .
 When   is started non-interactively, to run a shell script, for example, it looks for the variable   in the
environment, expands its value if it appears there, and uses the expanded value as the name of a file to read and execute.   behaves as if the
following command were executed:
 If   is invoked with the name  , it tries to mimic the startup behavior of historical versions of   as closely as possible, while
conforming to the POSIX standard as well. When invoked as an interactive login shell, or a non-interactive shell with the   option, it first
attempts to read and execute commands from   and  , in that order. The   option may be used to inhibit this
behavior. When invoked as an interactive shell with the name  ,   looks for the variable   expands
its value if it is defined, and uses the expanded value as the name of a file to read and execute. Since a shell invoked as   does not attempt to read
and execute commands from any other startup files, the   option has no effect. A non-interactive shell invoked with the name   does not
attempt to read any other startup files. When invoked as  ,   enters   mode after the startup files are read.
 When   is started in   mode, as with the   command line option, it follows the POSIX standard for startup files. In this
mode, interactive shells expand the   variable and commands are read and executed from the file whose name is the expanded value. No
other startup files are read.
  attempts to determine when it is being run with its standard input connected to a a network connection, as if by the remote shell daemon,
usually  , or the secure shell daemon  . If   determines it is being run in this fashion, it reads and executes commands from
 , if that file exists and is readable. It will not do this if invoked as  . The   option may be used to inhibit this
behavior, and the   option may be used to force another file to be read, but   does not generally invoke the shell with those options
or allow them to be specified.
 If the shell is started with the effective user (group) id not equal to the real user (group) id, and the   option is not supplied, no startup files
are read, shell functions are not inherited from the environment, the   and
  variables, if they appear in the environment, are ignored, and the effective user id is set to the real user id. If the
  option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset.
 
 
 The following definitions are used throughout the rest of this document.
 A space or tab.

 
 A sequence of characters considered as a single unit by the shell. Also known as a  .

 
 A   consisting only of alphanumeric characters and underscores, and beginning with an alphabetic character or an underscore. Also referred to as
an  .
 
 
  are words that have a special meaning to the shell. The following words are recognized as reserved when unquoted and either the first
word of a simple command (see   below) or the third word of a   or   command:
 
 
 
 The return value of a   is its exit status, or 128+  if the command is terminated by signal  .
 
 
 The return status of a pipeline is the exit status of the last command, unless the   option is enabled. If   is enabled, the
pipeline's return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. If the
reserved word   precedes a pipeline, the exit status of that pipeline is the logical negation of the exit status as described above. The shell waits for
all commands in the pipeline to terminate before returning a value.
 If the   reserved word precedes a pipeline, the elapsed as well as user and system time consumed by its execution are reported when the pipeline
terminates. The   option changes the output format to that specified by POSIX. The   variable may be set to a format
string that specifies how the timing information should be displayed; see the description of   under  
below.
 Each command in a pipeline is executed as a separate process (i.e., in a subshell).
 
 
 Of these list operators,   and   have equal precedence, followed by   and  , which have equal precedence.

 A sequence of one or more newlines may appear in a   instead of a semicolon to delimit commands.
 If a command is terminated by the control operator  , the shell executes the command in the   in a subshell. The shell does not
wait for the command to finish, and the return status is 0. Commands separated by a   are executed sequentially; the shell waits for each command to
terminate in turn. The return status is the exit status of the last command executed.
 AND and OR lists are sequences of one of more pipelines separated by the   and   control operators, respectively. AND and OR lists
are executed with left associativity. An AND list has the form
 An OR list has the form
 
 
  is executed in a subshell environment (see   below). Variable assignments and builtin commands
that affect the shell's environment do not remain in effect after the command completes. The return status is the exit status of  .
 When used with  , The   and   operators sort lexicographically using the current locale.
 When the   and   operators are used, the string to the right of the operator is considered a pattern and matched according to the rules
described below under  . If the shell option   is enabled, the match is performed without regard to the case of
alphabetic characters. The return value is 0 if the string matches ( ) or does not match ( ) the pattern, and 1 otherwise. Any part of the
pattern may be quoted to force it to be matched as a string.
 An additional binary operator,  , is available, with the same precedence as   and  . When it is used, the string to the right of the
operator is considered an extended regular expression and matched accordingly (as in  (3)). The return value is 0 if the string matches the pattern,
and 1 otherwise. If the regular expression is syntactically incorrect, the conditional expression's return value is 2. If the shell option  
is enabled, the match is performed without regard to the case of alphabetic characters. Any part of the pattern may be quoted to force it to be matched as a
string. Substrings matched by parenthesized subexpressions within the regular expression are saved in the array variable
  The element of   with index 0 is the portion of the string matching the
entire regular expression. The element of   with index   is the portion of the string matching the  th
parenthesized subexpression.
 Expressions may be combined using the following operators, listed in decreasing order of precedence:
 
 Returns the value of  . This may be used to override the normal precedence of operators.
 
 True if   is false.
 
 True if both   and   are true.
 
 True if either   or   is true.
 
 
 The format for a coprocess is:
 The return status of a coprocess is the exit status of  .
 
 
 
 
 In a non-interactive shell, or an interactive shell in which the   option to the   builtin is enabled (see
  below), a word beginning with   causes that word and all remaining characters on that line to be ignored.
An interactive shell without the   option enabled does not allow comments. The   option is on by default in
interactive shells.
 
  is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for
special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion.
 Each of the   listed above under   has special meaning to the shell and must be quoted if it is to
represent itself.
 When the command history expansion facilities are being used (see   below), the   character,
usually  , must be quoted to prevent history expansion.
 There are three quoting mechanisms: the  , single quotes, and double quotes.
 A non-quoted backslash ( ) is the  . It preserves the literal value of the next character that follows, with the exception of
<newline>. If a  <newline> pair appears, and the backslash is not itself quoted, the  <newline> is treated as a line
continuation (that is, it is removed from the input stream and effectively ignored).
 Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may not occur between single quotes,
even when preceded by a backslash.
 Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of  ,  ,  ,
and, when history expansion is enabled,  . The characters   and   retain their special meaning within double quotes. The backslash retains
its special meaning only when followed by one of the following characters:  ,  ,  ,  , or  . A double quote
may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an   appearing in double
quotes is escaped using a backslash. The backslash preceding the   is not removed.
 The special parameters   and   have special meaning when in double quotes (see   below).
 Words of the form  ' ' are treated specially. The word expands to  , with backslash-escaped characters replaced as specified
by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows:
 alert (bell)

 
 backspace

 
 
 an escape character

 
 form feed

 
 new line

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 backslash

 
 single quote

 
 double quote

 
 the eight-bit character whose value is the octal value   (one to three digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)

 
 a control-  character
 A double-quoted string preceded by a dollar sign ( " ") will cause the string to be translated according to the current locale. If the
current locale is   or  , the dollar sign is ignored. If the string is translated and replaced, the replacement is
double-quoted.
 
 
 A   is an entity that stores values. It can be a  , a number, or one of the special characters listed below under  . A   is a parameter denoted by a  . A variable has a   and zero or more  . Attributes are
assigned using the   builtin command (see   below in  
 A parameter is set if it has been assigned a value. The null string is a valid value. Once a variable is set, it may be unset only by using the  
builtin command (see   below).
 A   may be assigned to by a statement of the form
 In the context where an assignment statement is assigning a value to a shell variable or array index, the += operator can be used to append to or add to the
variable's previous value. When += is applied to a variable for which the integer attribute has been set,   is evaluated as an arithmetic expression
and added to the variable's current value, which is also evaluated. When += is applied to an array variable using compound assignment (see  
below), the variable's value is not unset (as it is when using =), and new values are appended to the array beginning at one greater than the array's maximum
index (for indexed arrays) or added as additional key-value pairs in an associative array. When applied to a string-valued variable,   is expanded
and appended to the variable's value.
 
 
 When a positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces (see  
below).
 
 
 Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, it expands to a single word with the value of each
parameter separated by the first character of the   special variable. That is, " " is equivalent to
" ", where   is the first character of the value of the   variable. If
  is unset, the parameters are separated by spaces. If   is null, the parameters are joined without intervening
separators.

 
 Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, each parameter expands to a separate word. That is,
" " is equivalent to " " " " ... If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined
with the beginning part of the original word, and the expansion of the last parameter is joined with the last part of the original word. When there are no
positional parameters, " " and   expand to nothing (i.e., they are removed).

 
 Expands to the number of positional parameters in decimal.

 
 Expands to the exit status of the most recently executed foreground pipeline.

 
 Expands to the current option flags as specified upon invocation, by the   builtin command, or those set by the shell itself (such as the  
option).

 
 Expands to the process ID of the shell. In a () subshell, it expands to the process ID of the current shell, not the subshell.

 
 Expands to the process ID of the most recently executed background (asynchronous) command.

 
 Expands to the name of the shell or shell script. This is set at shell initialization. If   is invoked with a file of commands,   is set
to the name of that file. If   is started with the   option, then   is set to the first argument after the string to be executed, if
one is present. Otherwise, it is set to the file name used to invoke  , as given by argument zero.

 
 At shell startup, set to the absolute pathname used to invoke the shell or shell script being executed as passed in the environment or argument list.
Subsequently, expands to the last argument to the previous command, after expansion. Also set to the full pathname used to invoke each command executed and
placed in the environment exported to that command. When checking mail, this parameter holds the name of the mail file currently being checked.
 
 
 Expands to the full file name used to invoke this instance of  .
 The major version number (the  ).

 1 
 The minor version number (the  ).

 2 
 The patch level.

 3 
 The build version.

 4 
 The release status (e.g.,  ).

 5 
 The value of  
 Expands to the effective user ID of the current user, initialized at shell startup. This variable is readonly.
 An array variable containing the list of groups of which the current user is a member. Assignments to   have no effect and return
an error status. If   is unset, it loses its special properties, even if it is subsequently reset.
 Each time this parameter is referenced, the shell substitutes a decimal number representing the current sequential line number (starting with 1) within a
script or function. When not in a script or function, the value substituted is not guaranteed to be meaningful. If   is unset, it
loses its special properties, even if it is subsequently reset.
 The previous working directory as set by the   command.

 
 The value of the last option argument processed by the   builtin command (see   below).

 
 The index of the next argument to be processed by the   builtin command (see   below).

 
 Automatically set to a string that describes the operating system on which   is executing. The default is system-dependent.
 The process ID of the shell's parent. This variable is readonly.

 
 The current working directory as set by the   command.

 
 Each time this parameter is referenced, a random integer between 0 and 32767 is generated. The sequence of random numbers may be initialized by assigning a
value to   If   is unset, it loses its special properties, even if it is subsequently
reset.

 
 Set to the line of input read by the   builtin command when no arguments are supplied.
 Incremented by one each time an instance of   is started.

 
 Expands to the user ID of the current user, initialized at shell startup. This variable is readonly.
 The search path for the   command. This is a colon-separated list of directories in which the shell looks for destination directories specified by
the   command. A sample value is ".:~:/usr".
 If   finds this variable in the environment when the shell starts with value "t", it assumes that the shell is running in an emacs shell buffer
and disables line editing.

 
 The default editor for the   builtin command.
 The home directory of the current user; the default argument for the   builtin command. The value of this variable is also used when performing
tilde expansion.
 The   that is used for word splitting after expansion and to split lines into words with the   builtin command. The
default value is ''<space><tab><newline>''.
 Used to determine the locale category for any category not specifically selected with a variable starting with  .

 
 This variable overrides the value of   and any other   variable specifying a locale category.
 Used by the   builtin command to determine the column length for printing selection lists. Automatically set upon receipt of a
 
 
 If this parameter is set to a file name and the   variable is not set,   informs the user of the arrival of mail in
the specified file.
 If set to the value 1,   displays error messages generated by the   builtin command (see  
below).   is initialized to 1 each time the shell is invoked or a shell script is executed.

 
 The search path for commands. It is a colon-separated list of directories in which the shell looks for commands (see  
below). A zero-length (null) directory name in the value of   indicates the current directory. A null directory name may appear as two
adjacent colons, or as an initial or trailing colon. The default path is system-dependent, and is set by the administrator who installs  . A common
value is ''/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
 The value of this parameter is expanded (see   below) and used as the primary prompt string. The default value is
''  ''.

 
 The value of this parameter is expanded as with   and used as the secondary prompt string. The default is ''  ''.

 
 The value of this parameter is used as the prompt for the   command (see   above).

 
 The value of this parameter is expanded as with   and the value is printed before each command   displays during an
execution trace. The first character of   is replicated multiple times, as necessary, to indicate multiple levels of indirection. The
default is ''  ''.

 
 The full pathname to the shell is kept in this environment variable. If it is not set when the shell starts,   assigns to it the full pathname of
the current user's login shell.
 A literal  .

 
 The elapsed time in seconds.

 
 The number of CPU seconds spent in user mode.

 
 The number of CPU seconds spent in system mode.

 
 The CPU percentage, computed as (%U + %S) / %R.
 The optional   specifies a longer format, including minutes, of the form  m . s. The value of   determines whether or
not the fraction is included.
 If this variable is not set,   acts as if it had the value  . If the value is null, no timing
information is displayed. A trailing newline is added when the format string is displayed.
 If set to a value greater than zero,   is treated as the default timeout for the   builtin. The   command
terminates if input does not arrive after   seconds when input is coming from a terminal. In an interactive shell, the value is
interpreted as the number of seconds to wait for input after issuing the primary prompt.   terminates after waiting for that number of seconds if
input does not arrive.

 
 If set,   uses its value as the name of a directory in which   creates temporary files for the shell's use.
 
 
 An indexed array is created automatically if any variable is assigned to using the syntax  [ ]= . The  
is treated as an arithmetic expression that must evaluate to a number greater than or equal to zero. To explicitly declare an indexed array, use     (see   below).     is also accepted;
the   is ignored.
 Associative arrays are created using    .
 Attributes may be specified for an array variable using the   and   builtins. Each attribute applies to all members of an array.

 Arrays are assigned to using compound assignments of the form  = value  ... value , where each   is of the
form [ ]= . Indexed array assignments do not require the bracket and subscript. When assigning to indexed arrays, if the optional
brackets and subscript are supplied, that index is assigned to; otherwise the index of the element assigned is the last index assigned to by the statement plus
one. Indexing starts at zero.
 When assigning to an associative array, the subscript is required.
 This syntax is also accepted by the   builtin. Individual array elements may be assigned to using the
 [ ]=  syntax introduced above.
 Any element of an array may be referenced using ${ [ ]}. The braces are required to avoid conflicts with pathname expansion. If
  is   or  , the word expands to all members of  . These subscripts differ only when the word appears within double
quotes. If the word is double-quoted, ${ [*]} expands to a single word with the value of each array member separated by the first character of the
  special variable, and ${ [@]} expands each element of   to a separate word. When there are no array members,
${ [@]} expands to nothing. If the double-quoted expansion occurs within a word, the expansion of the first parameter is joined with the beginning
part of the original word, and the expansion of the last parameter is joined with the last part of the original word. This is analogous to the expansion of the
special parameters   and   (see   above). ${# [ ]} expands to the length of
${ [ ]}. If   is   or  , the expansion is the number of elements in the array. Referencing an array
variable without a subscript is equivalent to referencing the array with a subscript of 0.
 An array variable is considered set if a subscript has been assigned a value. The null string is a valid value.
 The   builtin is used to destroy arrays.    [ ] destroys the array element at index  . Care
must be taken to avoid unwanted side effects caused by pathname expansion.    , where   is an array, or  
 [ ], where   is   or  , removes the entire array.
 The  ,  , and   builtins each accept a   option to specify an indexed array and a   option to specify
an associative array. The   builtin accepts a   option to assign a list of words read from the standard input to an array. The   and
  builtins display array values in a way that allows them to be reused as assignments.
 
 
 Expansion is performed on the command line after it has been split into words. There are seven kinds of expansion performed:  ,
 ,  ,  ,  ,  , and
 .
 The order of expansions is: brace expansion, tilde expansion, parameter, variable and arithmetic expansion and command substitution (done in a left-to-right
fashion), word splitting, and pathname expansion.
 On systems that can support it, there is an additional expansion available:  .
 Only brace expansion, word splitting, and pathname expansion can change the number of words of the expansion; other expansions expand a single word to a
single word. The only exceptions to this are the expansions of " " and " " as explained above (see
 
 
 Brace expansions may be nested. The results of each expanded string are not sorted; left to right order is preserved. For example, a d,c,b e
expands into 'ade ace abe'.
 A sequence expression takes the form  , where   and   are either integers or
single characters, and  , an optional increment, is an integer. When integers are supplied, the expression expands to each number between  
and  , inclusive. Supplied integers may be prefixed with   to force each term to have the same width. When either   or   begins
with a zero, the shell attempts to force all generated terms to contain the same number of digits, zero-padding where necessary. When characters are supplied,
the expression expands to each character lexicographically between   and  , inclusive. Note that both   and   must be of the same
type. When the increment is supplied, it is used as the difference between each term. The default increment is 1 or -1 as appropriate.
 Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result. It is strictly
textual.   does not apply any syntactic interpretation to the context of the expansion or the text between the braces.
 A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma or a valid sequence expression. Any
incorrectly formed brace expansion is left unchanged. A   or   may be quoted with a backslash to prevent its being considered part of a brace
expression. To avoid conflicts with parameter expansion, the string   is not considered eligible for brace expansion.
 This construct is typically used as shorthand when the common prefix of the strings to be generated is longer than in the above example:
 
 
 If the tilde-prefix is a '~+', the value of the shell variable   replaces the tilde-prefix. If the tilde-prefix is a '~-', the value
of the shell variable   if it is set, is substituted. If the characters following the tilde in the tilde-prefix
consist of a number  , optionally prefixed by a '+' or a '-', the tilde-prefix is replaced with the corresponding element from the directory stack, as
it would be displayed by the   builtin invoked with the tilde-prefix as an argument. If the characters following the tilde in the tilde-prefix
consist of a number without a leading '+' or '-', '+' is assumed.
 If the login name is invalid, or the tilde expansion fails, the word is unchanged.
 Each variable assignment is checked for unquoted tilde-prefixes immediately following a   or the first  . In these cases, tilde expansion is
also performed. Consequently, one may use file names with tildes in assignments to   and
  and the shell assigns the expanded value.
 
 
 When braces are used, the matching ending brace is the first ' ' not escaped by a backslash or within a quoted string, and not within an embedded
arithmetic expansion, command substitution, or parameter expansion.
 In each of the cases below,   is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion.

 When not performing substring expansion, using the forms documented below,   tests for a parameter that is unset or null. Omitting the colon
results in a test only for a parameter that is unset.
 
 
 When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by  ,  , or  .
The first backquote not preceded by a backslash terminates the command substitution. When using the $( ) form, all characters between the
parentheses make up the command; none are treated specially.
 Command substitutions may be nested. To nest when using the backquoted form, escape the inner backquotes with backslashes.
 If the substitution appears within double quotes, word splitting and pathname expansion are not performed on the results.
 
 
 The evaluation is performed according to the rules listed below under   If   is
invalid,   prints a message indicating failure and no substitution occurs.
 
 
 When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic
expansion.
 
 
 The shell treats each character of   as a delimiter, and splits the results of the other expansions into words on these characters.
If   is unset, or its value is exactly  , the default, then sequences of
 ,  , and   at the beginning and end of the results of the previous expansions are ignored, and any
sequence of   characters not at the beginning or end serves to delimit words. If   has a value other than the
default, then sequences of the whitespace characters   and   are ignored at the beginning and end of the word, as long as the whitespace
character is in the value of   (an   whitespace character). Any character in   that is
not   whitespace, along with any adjacent   whitespace characters, delimits a field. A sequence of
  whitespace characters is also treated as a delimiter. If the value of   is null, no word splitting occurs.

 Explicit null arguments (  or  ) are retained. Unquoted implicit null arguments, resulting from the expansion of parameters that have no
values, are removed. If a parameter with no value is expanded within double quotes, a null argument results and is retained.
 Note that if no expansion occurs, no splitting is performed.
 
 
 The   shell variable may be used to restrict the set of file names matching a  . If
  is set, each matching file name that also matches one of the patterns in   is removed from the
list of matches. The file names   and   are always ignored when   is set and not null. However, setting
  to a non-null value has the effect of enabling the   shell option, so all other file names beginning with a
  will match. To get the old behavior of ignoring file names beginning with a  , make   one of the patterns in
  The   option is disabled when   is unset.
 
 Any character that appears in a pattern, other than the special pattern characters described below, matches itself. The NUL character may not occur in a
pattern. A backslash escapes the following character; the escaping backslash is discarded when matching. The special pattern characters must be quoted if they
are to be matched literally.
 The special pattern characters have the following meanings:
 Matches any string, including the null string. When the   shell option is enabled, and   is used in a pathname expansion context, two
adjacent  s used as a single pattern will match all files and zero or more directories and subdirectories. If followed by a  , two adjacent
 s will match only directories and subdirectories.

 
 Matches any single character.

 
 Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a  ; any character that sorts between
those two characters, inclusive, using the current locale's collating sequence and character set, is matched. If the first character following the   is
a   or a   then any character not enclosed is matched. The sorting order of characters in range expressions is determined by the current locale
and the value of the   shell variable, if set. A   may be matched by including it as the first or last character in the
set. A   may be matched by including it as the first character in the set.
 Within   and  , an   can be specified using the syntax  , which matches all characters with
the same collation weight (as defined by the current locale) as the character  .
 Within   and  , the syntax   matches the collating symbol  .
 
 Matches zero or one occurrence of the given patterns
 
 Matches zero or more occurrences of the given patterns
 
 Matches one or more occurrences of the given patterns
 
 Matches one of the given patterns
 
 Matches anything except one of the given patterns

 
 
 
 Before a command is executed, its input and output may be   using a special notation interpreted by the shell. Redirection may also be used
to open and close files for the current shell execution environment. The following redirection operators may precede or appear anywhere within a   or may follow a  . Redirections are processed in the order they appear, from left to right.
 Each redirection that may be preceded by a file descriptor number may instead be preceded by a word of the form { }. In this case, for each
redirection operator except >&- and <&-, the shell will allocate a file descriptor greater than 10 and assign it to  . If >&-
or <&- is preceded by { }, the value of   defines the file descriptor to close.
 In the following descriptions, if the file descriptor number is omitted, and the first character of the redirection operator is  , the redirection
refers to the standard input (file descriptor 0). If the first character of the redirection operator is  , the redirection refers to the standard
output (file descriptor 1).
 The word following the redirection operator in the following descriptions, unless otherwise noted, is subjected to brace expansion, tilde expansion,
parameter expansion, command substitution, arithmetic expansion, quote removal, pathname expansion, and word splitting. If it expands to more than one word,
  reports an error.
 Note that the order of redirections is significant. For example, the command
  handles several filenames specially when they are used in redirections, as described in the following table:
 
 If   is a valid integer, file descriptor   is duplicated.
 
 File descriptor 0 is duplicated.
 
 File descriptor 1 is duplicated.
 
 File descriptor 2 is duplicated.
 
 If   is a valid hostname or Internet address, and   is an integer port number or service name,   attempts to open a TCP
connection to the corresponding socket.
 
 If   is a valid hostname or Internet address, and   is an integer port number or service name,   attempts to open a UDP
connection to the corresponding socket.
 Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.
 
 
 The general format for redirecting input is:
 
 
 The general format for redirecting output is:
 
 
 The general format for appending output is:
 
 
 There are two formats for redirecting standard output and standard error:
 
 
 The format for appending standard output and standard error is:
 
 
 The format of here-documents is:
 If the redirection operator is  , then all leading tab characters are stripped from input lines and the line containing  .
This allows here-documents within shell scripts to be indented in a natural fashion.
 
 
 
 
 The operator
 
 
 Similarly, the redirection operator
 
 
 
 
  allow a string to be substituted for a word when it is used as the first word of a simple command. The shell maintains a list of aliases that
may be set and unset with the   and   builtin commands (see   below). The first word of each
simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The characters  ,  ,
 , and   and any of the shell   or quoting characters listed above may not appear in an alias name. The replacement text may
contain any valid shell input, including shell metacharacters. The first word of the replacement text is tested for aliases, but a word that is identical to an
alias being expanded is not expanded a second time. This means that one may alias   to  , for instance, and   does not try to
recursively expand the replacement text. If the last character of the alias value is a  , then the next command word following the alias is also
checked for alias expansion.
 Aliases are created and listed with the   command, and removed with the   command.
 There is no mechanism for using arguments in the replacement text. If arguments are needed, a shell function should be used (see
  below).
 Aliases are not expanded when the shell is not interactive, unless the   shell option is set using   (see the description of
  under   below).
 The rules concerning the definition and use of aliases are somewhat confusing.   always reads at least one complete line of input before executing
any of the commands on that line. Aliases are expanded when a command is read, not when it is executed. Therefore, an alias definition appearing on the same
line as another command does not take effect until the next line of input is read. The commands following the alias definition on that line are not affected by
the new alias. This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is
executed, because a function definition is itself a compound command. As a consequence, aliases defined in a function are not available until after that
function is executed. To be safe, always put alias definitions on a separate line, and do not use   in compound commands.
 For almost every purpose, aliases are superseded by shell functions.
 
 A shell function, defined as described above under   stores a series of commands for later execution. When
the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Functions are executed in
the context of the current shell; no new process is created to interpret them (contrast this with the execution of a shell script). When a function is
executed, the arguments to the function become the positional parameters during its execution. The special parameter   is updated to reflect the change.
Special parameter 0 is unchanged. The first element of the   variable is set to the name of the function while the function is
executing.
 All other aspects of the shell execution environment are identical between a function and its caller with these exceptions: the  
and   traps (see the description of the   builtin under   below) are not inherited unless the
function has been given the   attribute (see the description of the   builtin below) or the   shell
option has been enabled with the   builtin (in which case all functions inherit the   and   traps), and the
  trap is not inherited unless the   shell option has been enabled.
 Variables local to the function may be declared with the   builtin command. Ordinarily, variables and their values are shared between the
function and its caller.
 If the builtin command   is executed in a function, the function completes and execution resumes with the next command after the function call.
Any command associated with the   trap is executed before execution resumes. When a function completes, the values of the positional parameters and
the special parameter   are restored to the values they had prior to the function's execution.
 Function names and definitions may be listed with the   option to the   or   builtin commands. The   option to
  or   will list the function names only (and optionally the source file and line number, if the   shell option is
enabled). Functions may be exported so that subshells automatically have them defined with the   option to the   builtin. A function
definition may be deleted using the   option to the   builtin. Note that shell functions and variables with the same name may result in
multiple identically-named entries in the environment passed to the shell's children. Care should be taken in cases where this may cause a problem.

 Functions may be recursive. No limit is imposed on the number of recursive calls.
 
 The shell allows arithmetic expressions to be evaluated, under certain circumstances (see the   and   builtin commands and
 ). Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error.
The operators and their precedence, associativity, and values are the same as in the C language. The following list of operators is grouped into levels of
equal-precedence operators. The levels are listed in order of decreasing precedence.
 unary minus and plus

 
 logical and bitwise negation

 
 exponentiation

 
 multiplication, division, remainder

 
 addition, subtraction

 
 left and right bitwise shifts
 equality and inequality

 
 bitwise AND

 
 bitwise exclusive OR

 
 bitwise OR

 
 logical AND

 
 logical OR
 Constants with a leading 0 are interpreted as octal numbers. A leading 0x or 0X denotes hexadecimal. Otherwise, numbers take the form [ ]n, where
  is a decimal number between 2 and 64 representing the arithmetic base, and   is a number in that base. If   is omitted, then base
10 is used. The digits greater than 9 are represented by the lowercase letters, the uppercase letters, @, and _, in that order. If   is less than or
equal to 36, lowercase and uppercase letters may be used interchangeably to represent numbers between 10 and 35.
 Operators are evaluated in order of precedence. Sub-expressions in parentheses are evaluated first and may override the precedence rules
above.
 
 
 Conditional expressions are used by the   compound command and the   and   builtin commands to test file attributes and perform
string and arithmetic comparisons. Expressions are formed from the following unary or binary primaries. If any   argument to one of the primaries is
of the form  , then file descriptor   is checked. If the   argument to one of the primaries is one of  ,
 , or  , file descriptor 0, 1, or 2, respectively, is checked.
 Unless otherwise specified, primaries that operate on files follow symbolic links and operate on the target of the link, rather than the link itself.

 When used with  , The   and   operators sort lexicographically using the current locale.
 True if file descriptor   is open and refers to a terminal.
 
 
 When a simple command is executed, the shell performs the following expansions, assignments, and redirections, from left to right.
 The words that the parser has marked as variable assignments (those preceding the command name) and redirections are saved for later processing.

 2.

 The words that are not variable assignments or redirections are expanded. If any words remain after expansion, the first word is taken to be the name of the
command and the remaining words are the arguments.

 3.

 Redirections are performed as described above under  
 4.

 The text after the   in each variable assignment undergoes tilde expansion, parameter expansion, command substitution, arithmetic expansion, and
quote removal before being assigned to the variable.
 If no command name results, redirections are performed, but do not affect the current shell environment. A redirection error causes the command to exit with
a non-zero status.
 If there is a command name left after expansion, execution proceeds as described below. Otherwise, the command exits. If one of the expansions contained a
command substitution, the exit status of the command is the exit status of the last command substitution performed. If there were no command substitutions, the
command exits with a status of zero.
 
 
 After a command has been split into words, if it results in a simple command and an optional list of arguments, the following actions are taken.

 If the command name contains no slashes, the shell attempts to locate it. If there exists a shell function by that name, that function is invoked as
described above in   If the name does not match a function, the shell searches for it in the list of shell
builtins. If a match is found, that builtin is invoked.
 If the name is neither a shell function nor a builtin, and contains no slashes,   searches each element of the   for a
directory containing an executable file by that name.   uses a hash table to remember the full pathnames of executable files (see   under
  below). A full search of the directories in   is performed only if the command is not
found in the hash table. If the search is unsuccessful, the shell searches for a defined shell function named  . If that function
exists, it is invoked with the original command and the original command's arguments as its arguments, and the function's exit status becomes the exit status
of the shell. If that function is not defined, the shell prints an error message and returns an exit status of 127.
 If the search is successful, or if the command name contains one or more slashes, the shell executes the named program in a separate execution environment.
Argument 0 is set to the name given, and the remaining arguments to the command are set to the arguments given, if any.
 If this execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a  , a file
containing shell commands. A subshell is spawned to execute it. This subshell reinitializes itself, so that the effect is as if a new shell had been invoked to
handle the script, with the exception that the locations of commands remembered by the parent (see   below under   are retained by the child.
 If the program is a file beginning with  , the remainder of the first line specifies an interpreter for the program. The shell executes the
specified interpreter on operating systems that do not handle this executable format themselves. The arguments to the interpreter consist of a single optional
argument following the interpreter name on the first line of the program, followed by the name of the program, followed by the command arguments, if
any.
 
 The shell has an  , which consists of the following:
 • the current working directory as set by  ,  , or  , or inherited by the shell at invocation

 • the file creation mode mask as set by   or inherited from the shell's parent

 • current traps set by  
 • shell parameters that are set by variable assignment or with   or inherited from the shell's parent in the environment

 • shell functions defined during execution or inherited from the shell's parent in the environment

 • options enabled at invocation (either by default or with command-line arguments) or by  
 • options enabled by  
 • shell aliases defined with  
 • various process IDs, including those of background jobs, the value of  , and the value of  
 • the current working directory

 • the file creation mode mask

 • shell variables and functions marked for export, along with variables exported for the command, passed in the environment

 • traps caught by the shell are reset to the values inherited from the shell's parent, and traps ignored by the shell are ignored
 Command substitution, commands grouped with parentheses, and asynchronous commands are invoked in a subshell environment that is a duplicate of the shell
environment, except that traps caught by the shell are reset to the values that the shell inherited from its parent at invocation. Builtin commands that are
invoked as part of a pipeline are also executed in a subshell environment. Changes made to the subshell environment cannot affect the shell's execution
environment.
 Subshells spawned to execute command substitutions inherit the value of the   option from the parent shell. When not in posix mode, Bash clears the
  option in such subshells.
 If a command is followed by a   and job control is not active, the default standard input for the command is the empty file  .
Otherwise, the invoked command inherits the file descriptors of the calling shell as modified by redirections.
 
 
 When a program is invoked it is given an array of strings called the  . This is a list of  -  pairs, of the form
 = .
 The shell provides several ways to manipulate the environment. On invocation, the shell scans its own environment and creates a parameter for each name
found, automatically marking it for   to child processes. Executed commands inherit the environment. The   and  
commands allow parameters and functions to be added to and deleted from the environment. If the value of a parameter in the environment is modified, the new
value becomes part of the environment, replacing the old. The environment inherited by any executed command consists of the shell's initial environment, whose
values may be modified in the shell, less any pairs removed by the   command, plus any additions via the   and  
commands.
 The environment for any   or function may be augmented temporarily by prefixing it with parameter assignments, as described above in
  These assignment statements affect only the environment seen by that command.
 If the   option is set (see the   builtin command below), then   parameter assignments are placed in the environment for a
command, not just those that precede the command name.
 When   invokes an external command, the variable   is set to the full file name of the command and passed to that command in its
environment.
 
 The exit status of an executed command is the value returned by the   system call or equivalent function. Exit statuses fall between 0 and 255,
though, as explained below, the shell may use values above 125 specially. Exit statuses from shell builtins and compound commands are also limited to this
range. Under certain circumstances, the shell will use special values to indicate specific failure modes.
 For the shell's purposes, a command which exits with a zero exit status has succeeded. An exit status of zero indicates success. A non-zero exit status
indicates failure. When a command terminates on a fatal signal  ,   uses the value of 128+  as the exit status.
 If a command is not found, the child process created to execute it returns a status of 127. If a command is found but is not executable, the return status
is 126.
 If a command fails because of an error during expansion or redirection, the exit status is greater than zero.
 Shell builtin commands return a status of 0 ( ) if successful, and non-zero ( ) if an error occurs while they execute. All builtins
return an exit status of 2 to indicate incorrect usage.
  itself returns the exit status of the last command executed, unless a syntax error occurs, in which case it exits with a non-zero value. See
also the   builtin command below.
 
 When   is interactive, in the absence of any traps, it ignores   (so that   does not kill an interactive
shell), and   is caught and handled (so that the   builtin is interruptible). In all cases,   ignores
  If job control is in effect,   ignores  
and  
 Non-builtin commands run by   have signal handlers set to the values inherited by the shell from its parent. When job control is not in effect,
asynchronous commands ignore   and   in addition to these inherited handlers. Commands run as a result
of command substitution ignore the keyboard-generated job control signals   and
 
 The shell exits by default upon receipt of a   Before exiting, an interactive shell resends the
  to all jobs, running or stopped. Stopped jobs are sent   to ensure that they receive the
  To prevent the shell from sending the signal to a particular job, it should be removed from the jobs table with
the   builtin (see   below) or marked to not receive   using  .
 If the   shell option has been set with  ,   sends a   to all jobs when an interactive login
shell exits.
 If   is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command
completes. When   is waiting for an asynchronous command via the   builtin, the reception of a signal for which a trap has been set will
cause the   builtin to return immediately with an exit status greater than 128, immediately after which the trap is executed.
 
  refers to the ability to selectively stop ( ) the execution of processes and continue ( ) their execution at a
later point. A user typically employs this facility via an interactive interface supplied jointly by the operating system kernel's terminal driver and
 .
 The shell associates a   with each pipeline. It keeps a table of currently executing jobs, which may be listed with the   command. When
  starts a job asynchronously (in the  ), it prints a line that looks like:
 To facilitate the implementation of the user interface to job control, the operating system maintains the notion of a  . Members of this process group (processes whose process group ID is equal to the current terminal process group ID) receive keyboard-generated signals
such as   These processes are said to be in the  .   processes are those whose
process group ID differs from the terminal's; such processes are immune to keyboard-generated signals. Only foreground processes are allowed to read from or,
if the user so specifies with  , write to the terminal. Background processes which attempt to read from (write to when  
is in effect) the terminal are sent a   signal by the kernel's terminal driver, which, unless caught, suspends the
process.
 If the operating system on which   is running supports job control,   contains facilities to use it. Typing the   character
(typically  , Control-Z) while a process is running causes that process to be stopped and returns control to  . Typing the   character (typically  , Control-Y) causes the process to be stopped when it attempts to read input from the terminal, and control to be
returned to  . The user may then manipulate the state of this job, using the   command to continue it in the background, the  
command to continue it in the foreground, or the   command to kill it. A   takes effect immediately, and has the additional side effect of
causing pending output and typeahead to be discarded.
 There are a number of ways to refer to a job in the shell. The character   introduces a job specification ( ). Job number   may
be referred to as  . A job may also be referred to using a prefix of the name used to start it, or using a substring that appears in its command line.
For example,   refers to a stopped   job. If a prefix matches more than one job,   reports an error. Using  , on the other
hand, refers to any job containing the string   in its command line. If the substring matches more than one job,   reports an error. The
symbols   and   refer to the shell's notion of the  , which is the last job stopped while it was in the foreground or started
in the background. The   may be referenced using  . If there is only a single job,   and   can both be used to refer
to that job. In output pertaining to jobs (e.g., the output of the   command), the current job is always flagged with a  , and the previous
job with a  . A single % (with no accompanying job specification) also refers to the current job.
 Simply naming a job can be used to bring it into the foreground:   is a synonym for  , bringing job 1 from the background into the
foreground. Similarly,   resumes job 1 in the background, equivalent to  .
 The shell learns immediately whenever a job changes state. Normally,   waits until it is about to print a prompt before reporting changes in a
job's status so as to not interrupt any other output. If the   option to the   builtin command is enabled,   reports such changes
immediately. Any trap on   is executed for each child that exits.
 If an attempt to exit   is made while jobs are stopped (or, if the   shell option has been enabled using the   builtin,
running), the shell prints a warning message, and, if the   option is enabled, lists the jobs and their statuses. The   command may
then be used to inspect their status. If a second attempt to exit is made without an intervening command, the shell does not print another warning, and any
stopped jobs are terminated.
 
 
 When executing interactively,   displays the primary prompt   when it is ready to read a command, and the secondary prompt
  when it needs more input to complete a command.   allows these prompt strings to be customized by inserting a number of
backslash-escaped special characters that are decoded as follows:
 an ASCII bell character (07)

 
 the date in "Weekday Month Date" format (e.g., "Tue May 26")
 
 the   is passed to  (3) and the result is inserted into the prompt string; an empty   results in a locale-specific
time representation. The braces are required
 an ASCII escape character (033)

 
 the hostname up to the first '.'

 
 the hostname

 
 the number of jobs currently managed by the shell

 
 the basename of the shell's terminal device name

 
 newline

 
 carriage return

 
 the name of the shell, the basename of   (the portion following the final slash)

 
 the current time in 24-hour HH:MM:SS format

 
 the current time in 12-hour HH:MM:SS format

 
 the current time in 12-hour am/pm format

 
 the current time in 24-hour HH:MM format

 
 the username of the current user

 
 the version of   (e.g., 2.00)

 
 the release of  , version + patch level (e.g., 2.00.0)

 
 the current working directory, with   abbreviated with a tilde (uses the value of the  
variable)

 
 the basename of the current working directory, with   abbreviated with a tilde

 
 the history number of this command

 
 the command number of this command

 
 if the effective UID is 0, a  , otherwise a  
 
 the character corresponding to the octal number  
 
 a backslash

 
 begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt

 
 end a sequence of non-printing characters
 
 
 This is the library that handles reading input when using an interactive shell, unless the   option is given at shell invocation. Line
editing is also used when using the   option to the   builtin. By default, the line editing commands are similar to those of emacs. A
vi-style line editing interface is also available. Line editing can be enabled at any time using the   or   options to the  
builtin (see   below). To turn off line editing after the shell is running, use the   or  
options to the   builtin.

 
 Readline commands may be given numeric  , which normally act as a repeat count. Sometimes, however, it is the sign of the argument that is
significant. Passing a negative argument to a command that acts in the forward direction (e.g.,  ) causes that command to act in a backward
direction. Commands whose behavior with arguments deviates from this are noted below.
 When a command is described as   text, the text deleted is saved for possible future retrieval ( ). The killed text is saved in a
 . Consecutive kills cause the text to be accumulated into one unit, which can be yanked all at once. Commands which do not kill text separate
the chunks of text on the kill ring.
 
 
 The default key-bindings may be changed with an   file. Other programs that use this library may add their own commands and bindings.

 For example, placing
 The following symbolic character names are recognized:  ,  ,  ,  ,  ,  ,  ,
 ,  , and  .
 In addition to command names, readline allows keys to be bound to a string that is inserted when the key is pressed (a  ).
 
 
 When using the form  :  or  ,   is the name of a key spelled out in English. For example:
 In the second form,  :  or  ,   differs from   above in that strings denoting an entire
key sequence may be specified by placing the sequence within double quotes. Some GNU Emacs style key escapes can be used, as in the following example, but the
symbolic character names are not recognized.
 The full set of GNU Emacs style escape sequences is
 control prefix

 
 meta prefix

 
 an escape character

 
 backslash

 
 literal "

 
 literal '
 alert (bell)

 
 backspace

 
 delete

 
 form feed

 
 newline

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 the eight-bit character whose value is the octal value   (one to three digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)
  allows the current readline key bindings to be displayed or modified with the   builtin command. The editing mode may be switched
during interactive use by using the   option to the   builtin command (see   below).
 
 
 
 
 The   construct allows bindings to be made based on the editing mode, the terminal being used, or the application using readline. The text of the
test extends to the end of the line; no characters are required to isolate it.
 The   form of the   directive is used to test whether readline is in emacs or vi mode. This may be used in conjunction with the   command, for instance, to set bindings in the   and   keymaps only if readline is starting out in emacs mode.

 
 The   form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal's function keys. The
word on the right side of the   is tested against the both full name of the terminal and the portion of the terminal name before the first  .
This allows   to match both   and  , for instance.
 
 The   construct is used to include application-specific settings. Each program using the readline library sets the  ,
and an initialization file can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance,
the following command adds a key sequence that quotes the current or previous word in Bash:

 
 This command, as seen in the previous example, terminates an   command.

 
 Commands in this branch of the   directive are executed if the test fails.
 
 
 Incremental searches begin before the user has finished typing the search string. As each character of the search string is typed, readline displays the
next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history
entry. The characters present in the value of the   variable are used to terminate an incremental search. If that variable has not
been assigned a value the Escape and Control-J characters will terminate an incremental search. Control-G will abort an incremental search and restore the
original line. When the search is terminated, the history entry containing the search string becomes the current line.
 To find other matching entries in the history list, type Control-S or Control-R as appropriate. This will search backward or forward in the history for the
next entry matching the search string typed so far. Any other key sequence bound to a readline command will terminate the search and execute that command. For
instance, a   will terminate the search and accept the line, thereby executing the command from the history list.
 Readline remembers the last incremental search string. If two Control-Rs are typed without any intervening characters defining a new search string, any
remembered search string is used.
 Non-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or
be part of the contents of the current line.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 First, the command name is identified. If the command word is the empty string (completion attempted at the beginning of an empty line), any compspec
defined with the   option to   is used. If a compspec has been defined for that command, the compspec is used to generate the list of
possible completions for the word. If the command word is a full pathname, a compspec for the full pathname is searched for first. If no compspec is found for
the full pathname, an attempt is made to find a compspec for the portion following the final slash. If those searches to not result in a compspec, any compspec
defined with the   option to   is used as the default.
 Once a compspec has been found, it is used to generate the list of matching words. If a compspec is not found, the default   completion as
described above under   is performed.
 First, the actions specified by the compspec are used. Only matches which are prefixed by the word being completed are returned. When the   or
  option is used for filename or directory name completion, the shell variable   is used to filter the matches.

 Any completions specified by a pathname expansion pattern to the   option are generated next. The words generated by the pattern need not match the
word being completed. The   shell variable is not used to filter the matches, but the   variable is
used.
 Next, the string specified as the argument to the   option is considered. The string is first split using the characters in the
  special variable as delimiters. Shell quoting is honored. Each word is then expanded using brace expansion, tilde expansion,
parameter and variable expansion, command substitution, and arithmetic expansion, as described above under   The
results are split using the rules described above under  . The results of the expansion are prefix-matched against the word being
completed, and the matching words become the possible completions.
 After these matches have been generated, any shell function or command specified with the   and   options is invoked. When the command or
function is invoked, the   and   variables are
assigned values as described above under  . If a shell function is being invoked, the   and
  variables are also set. When the function or command is invoked, the first argument is the name of the command whose arguments
are being completed, the second argument is the word being completed, and the third argument is the word preceding the word being completed on the current
command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in
generating the matches.
 Any function specified with   is invoked first. The function may use any of the shell facilities, including the   builtin described
below, to generate the matches. It must put the possible completions in the   array variable.
 Next, any command specified with the   option is invoked in an environment equivalent to command substitution. It should print a list of
completions, one per line, to the standard output. Backslash may be used to escape a newline, if necessary.
 After all of the possible completions are generated, any filter specified with the   option is applied to the list. The filter is a pattern as used
for pathname expansion; a   in the pattern is replaced with the text of the word being completed. A literal   may be escaped with a
backslash; the backslash is removed before attempting a match. Any completion that matches the pattern will be removed from the list. A leading  
negates the pattern; in this case any completion not matching the pattern will be removed.
 Finally, any prefix and suffix specified with the   and   options are added to each member of the completion list, and the result is
returned to the readline completion code as the list of possible completions.
 If the previously-applied actions do not generate any matches, and the   option was supplied to   when the compspec was
defined, directory name completion is attempted.
 If the   option was supplied to   when the compspec was defined, directory name completion is attempted and any matches are
added to the results of the other actions.
 By default, if a compspec is found, whatever it generates is returned to the completion code as the full set of possible completions. The default
  completions are not attempted, and the readline default of filename completion is disabled. If the   option was supplied to
  when the compspec was defined, the   default completions are attempted if the compspec generates no matches. If the  
option was supplied to   when the compspec was defined, readline's default completion will be performed if the compspec (and, if attempted, the
default   completions) generate no matches.
 When a compspec indicates that directory name completion is desired, the programmable completion functions force readline to append a slash to completed
names which are symbolic links to directories, subject to the value of the   readline variable, regardless of the setting of the
  readline variable.
 There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with
 . It's possible for shell functions executed as completion handlers to indicate that completion should be retried by returning an exit status
of 124. If a shell function returns 124, and changes the compspec associated with the command on which completion is being attempted (supplied as the first
argument when the function is executed), programmable completion restarts from the beginning, with an attempt to find a compspec for that command. This allows
a set of completions to be built dynamically as completion is attempted, rather than being loaded all at once.
 For instance, assuming that there is a library of compspecs, each kept in a file corresponding to the name of the command, the following default completion
function would load completions dynamically:
 
 
 
 When the   option to the   builtin is enabled, the shell provides access to the  , the list of commands
previously typed. The value of the   variable is used as the number of commands to save in a history list. The text of the last
  commands (default 500) is saved. The shell stores each command in the history list prior to parameter and variable expansion
(see   above) but after history expansion is performed, subject to the values of the shell variables
  and  
 On startup, the history is initialized from the file named by the variable   (default  ). The file named
by the value of   is truncated, if necessary, to contain no more than the number of lines specified by the value of
  When the history file is read, lines beginning with the history comment character followed immediately by a
digit are interpreted as timestamps for the preceding history line. These timestamps are optionally displayed depending on the value of the
  variable. When an interactive shell exits, the last   lines are copied from the history list
to   If the   shell option is enabled (see the description of   under   below), the lines are appended to the history file, otherwise the history file is overwritten. If  
is unset, or if the history file is unwritable, the history is not saved. If the   variable is set, time stamps are written
to the history file, marked with the history comment character, so they may be preserved across shell sessions. This uses the history comment character to
distinguish timestamps from other history lines. After saving the history, the history file is truncated to contain no more than
  lines. If   is not set, no truncation is performed.
 The builtin command   (see   below) may be used to list or edit and re-execute a portion of the history
list. The   builtin may be used to display or modify the history list and manipulate the history file. When using command-line editing, search
commands are available in each editing mode that provide access to the history list.
 The shell allows control over which commands are saved on the history list. The   and  
variables may be set to cause the shell to save only a subset of the commands entered. The   shell option, if enabled, causes the shell to attempt
to save each line of a multi-line command in the same history entry, adding semicolons where necessary to preserve syntactic correctness. The  
shell option causes the shell to save the command with embedded newlines instead of semicolons. See the description of the   builtin below under
  for information on setting and unsetting shell options.
 
 The shell supports a history expansion feature that is similar to the history expansion in   This section describes what syntax features are
available. This feature is enabled by default for interactive shells, and can be disabled using the   option to the   builtin command (see
  below). Non-interactive shells do not perform history expansion by default.
 History expansions introduce words from the history list into the input stream, making it easy to repeat commands, insert the arguments to a previous
command into the current input line, or fix errors in previous commands quickly.
 History expansion is performed immediately after a complete line is read, before the shell breaks it into words. It takes place in two parts. The first is
to determine which line from the history list to use during substitution. The second is to select portions of that line for inclusion into the current one. The
line selected from the history is the  , and the portions of that line that are acted upon are  . Various   are available
to manipulate the selected words. The line is broken into words in the same fashion as when reading input, so that several  -separated words
surrounded by quotes are considered one word. History expansions are introduced by the appearance of the history expansion character, which is   by
default. Only backslash ( ) and single quotes can quote the history expansion character.
 Several characters inhibit history expansion if found immediately following the history expansion character, even if it is unquoted: space, tab, newline,
carriage return, and  . If the   shell option is enabled,   will also inhibit expansion.
 Several shell options settable with the   builtin may be used to tailor the behavior of history expansion. If the   shell option
is enabled (see the description of the   builtin below), and   is being used, history substitutions are not immediately passed to the
shell parser. Instead, the expanded line is reloaded into the   editing buffer for further modification. If   is being used, and
the   shell option is enabled, a failed history substitution will be reloaded into the   editing buffer for correction. The
  option to the   builtin command may be used to see what a history expansion will do before using it. The   option to the
  builtin may be used to add commands to the end of the history list without actually executing them, so that they are available for subsequent
recall.
 The shell allows control of the various characters used by the history expansion mechanism (see the description of   above under  ). The shell uses the history comment character to mark history timestamps when writing the history file.

 
 Start a history substitution, except when followed by a  , newline, carriage return, = or ( (when the   shell option is enabled
using the   builtin).

 
 Refer to command line  .

 
 Refer to the current command line minus  .

 
 Refer to the previous command. This is a synonym for '!-1'.
 The entire command line typed so far.

 
 
 The  th word.

 
 The first argument. That is, word 1.

 
 The last argument.

 
 The word matched by the most recent '? ?' search.

 
 A range of words; '- ' abbreviates '0- '.

 
 All of the words but the zeroth. This is a synonym for ' '. It is not an error to use   if there is just one word in the event; the empty
string is returned in that case.

 
 Abbreviates  .

 
 Abbreviates   like  , but omits the last word.
 
 
 Remove a trailing file name component, leaving only the head.

 
 Remove all leading file name components, leaving the tail.

 
 Remove a trailing suffix of the form  , leaving the basename.

 
 Remove all but the trailing suffix.

 
 Print the new command but do not execute it.

 
 Quote the substituted words, escaping further substitutions.

 
 Quote the substituted words as with  , but break into words at   and newlines.
 Repeat the previous substitution.

 
 Cause changes to be applied over the entire event line. This is used in conjunction with ' ' (e.g.,
' ') or ' '. If used with ' ', any delimiter can be used in place of /, and the final
delimiter is optional if it is the last character of the event line. An   may be used as a synonym for  .

 
 Apply the following ' ' modifier once to each word in the event line.
 
 
 Unless otherwise noted, each builtin command documented in this section as accepting options preceded by   accepts   to signify the end of
the options. The  ,  ,  , and   builtins do not accept options and do not treat   specially. The  ,
 ,  ,  ,  , and   builtins accept and process arguments beginning with   without requiring
 . Other builtins that accept arguments but are not specified as accepting options interpret arguments beginning with   as invalid options and
require   to prevent this interpretation.
 
 Use   as the keymap to be affected by the subsequent bindings. Acceptable   names are  , and  .   is equivalent to  ;   is equivalent to
 .
 List the names of all   functions.

 
 Display   function names and bindings in such a way that they can be re-read.

 
 List current   function names and bindings.

 
 Display   key sequences bound to macros and the strings they output in such a way that they can be re-read.

 
 Display   key sequences bound to macros and the strings they output.

 
 Display   variable names and values in such a way that they can be re-read.

 
 List current   variable names and values.
 
 Read key bindings from  .
 
 Query about which keys invoke the named  .
 
 Unbind all keys bound to the named  .
 
 Remove any current binding for  .
 
 Cause   to be executed whenever   is entered. When   is executed, the shell sets the
  variable to the contents of the   line buffer and the   variable to the
current location of the insertion point. If the executed command changes the value of   or
  those new values will be reflected in the editing state.
 The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the
same flags. If   is specified, only those completions matching   will be displayed.
 The return value is true unless an invalid option is supplied, or no matches were generated.
 The process of applying these completion specifications when word completion is attempted is described above under  .

 Other options, if specified, have the following meanings. The arguments to the  ,  , and   options (and, if necessary, the  
and   options) should be quoted to protect them from expansion before the   builtin is invoked.
 
 The   controls several aspects of the compspec's behavior beyond the simple generation of completions.   may be one
of:

 
 Perform the rest of the default   completions if the compspec generates no matches.

 
 Use readline's default filename completion if the compspec generates no matches.

 
 Perform directory name completion if the compspec generates no matches.

 
 Tell readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting
special characters, or suppressing trailing spaces). Intended to be used with shell functions.

 
 Tell readline not to append a space (the default) to words completed at the end of the line.

 
 After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other
actions.
 
 The   may be one of the following to generate a list of possible completions:

 
 Alias names. May also be specified as  .

 
 Array variable names.

 
  key binding names.

 
 Names of shell builtin commands. May also be specified as  .

 
 Command names. May also be specified as  .

 
 Directory names. May also be specified as  .

 
 Names of disabled shell builtins.

 
 Names of enabled shell builtins.

 
 Names of exported shell variables. May also be specified as  .

 
 File names. May also be specified as  .

 
 Names of shell functions.

 
 Group names. May also be specified as  .

 
 Help topics as accepted by the   builtin.

 
 Hostnames, as taken from the file specified by the   shell variable.

 
 Job names, if job control is active. May also be specified as  .

 
 Shell reserved words. May also be specified as  .

 
 Names of running jobs, if job control is active.

 
 Service names. May also be specified as  .

 
 Valid arguments for the   option to the   builtin.

 
 Shell option names as accepted by the   builtin.

 
 Signal names.

 
 Names of stopped jobs, if job control is active.

 
 User names. May also be specified as  .

 
 Names of all shell variables. May also be specified as  .
 
 The pathname expansion pattern   is expanded to generate the possible completions.
 
 The   is split using the characters in the   special variable as delimiters, and each resultant word is expanded. The
possible completions are the members of the resultant list which match the word being completed.
 
  is executed in a subshell environment, and its output is used as the possible completions.
 
 The shell function   is executed in the current shell environment. When it finishes, the possible completions are retrieved from the value of
the   array variable.
 
  is a pattern as used for pathname expansion. It is applied to the list of possible completions generated by the preceding options and
arguments, and each completion matching   is removed from the list. A leading   in   negates the pattern; in this case,
any completion not matching   is removed.
 
  is added at the beginning of each possible completion after all other options have been applied.
 
  is appended to each possible completion after all other options have been applied.
 Each   is an indexed array variable (see   above).

 
 Each   is an associative array variable (see   above).

 
 Use function names only.

 
 The variable is treated as an integer; arithmetic evaluation (see   above) is performed when the variable is
assigned a value.

 
 When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.

 
 Make  s readonly. These names cannot then be assigned values by subsequent assignment statements or unset.

 
 Give each   the   attribute. Traced functions inherit the   and   traps from the calling shell. The trace
attribute has no special meaning for variables.

 
 When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.

 
 Mark  s for export to subsequent commands via the environment.
 Displays the  th entry counting from the left of the list shown by   when invoked without options, starting with zero.

 
 Displays the  th entry counting from the right of the list shown by   when invoked without options, starting with zero.

 
 Clears the directory stack by deleting all of the entries.

 
 Produces a longer listing; the default listing format uses a tilde to denote the home directory.

 
 Print the directory stack with one entry per line.

 
 Print the directory stack with one entry per line, prefixing each entry with its index in the stack.
 alert (bell)

 
 backspace

 
 suppress further output

 
 an escape character

 
 form feed

 
 new line

 
 carriage return

 
 horizontal tab

 
 vertical tab

 
 backslash

 
 the eight-bit character whose value is the octal value   (zero to three octal digits)

 
 the eight-bit character whose value is the hexadecimal value   (one or two hex digits)
 The   option suppresses the command numbers when listing. The   option reverses the order of the commands. If the   option is given,
the commands are listed on standard output. Otherwise, the editor given by   is invoked on a file containing those commands. If   is not
given, the value of the   variable is used, and the value of   if   is not
set. If neither variable is set,   is used. When editing is complete, the edited commands are echoed and executed.
 In the second form,   is re-executed after each instance of   is replaced by  . A useful alias to use with this is ''r="fc
-s"'', so that typing ''r cc'' runs the last command beginning with ''cc'' and typing ''r'' re-executes the last command.
 If the first form is used, the return value is 0 unless an invalid option is encountered or   or   specify history lines out of range.
If the   option is supplied, the return value is the value of the last command executed or failure if an error occurs with the temporary file of
commands. If the second form is used, the return status is that of the command re-executed, unless   does not specify a valid history line, in which
case   returns failure.
 When the end of options is encountered,   exits with a return value greater than zero.   is set to the index of the
first non-option argument, and   is set to ?.
  normally parses the positional parameters, but if more arguments are given in  ,   parses those instead.

  can report errors in two ways. If the first character of   is a colon,   error reporting is used. In normal
operation diagnostic messages are printed when invalid options or missing option arguments are encountered. If the variable   is set
to 0, no error messages will be displayed, even if the first character of   is not a colon.
 If an invalid option is seen,   places ? into   and, if not silent, prints an error message and unsets
  If   is silent, the option character found is placed in   and no
diagnostic message is printed.
 If a required argument is not found, and   is not silent, a question mark ( ) is placed in  ,   is
unset, and a diagnostic message is printed. If   is silent, then a colon ( ) is placed in   and   is
set to the option character found.
  returns true if an option, specified or unspecified, is found. It returns false if the end of options is encountered or an error
occurs.
 Display a short description of each  
 
 Display the description of each   in a manpage-like format

 
 Display only a short usage synopsis for each  
 Clear the history list by deleting all the entries.
 
 Delete the history entry at position  .
 Append the ''new'' history lines (history lines entered since the beginning of the current   session) to the history file.

 
 Read the history lines not already read from the history file into the current history list. These are lines appended to the history file since the
beginning of the current   session.

 
 Read the contents of the history file and use them as the current history.

 
 Write the current history to the history file, overwriting the history file's contents.

 
 Perform history substitution on the following   and display the result on the standard output. Does not store the results in the history list.
Each   must be quoted to disable normal history expansion.

 
 Store the   in the history list as a single entry. The last command in the history list is removed before the   are added.
 List process IDs in addition to the normal information.

 
 List only the process ID of the job's process group leader.

 
 Display information only about jobs that have changed status since the user was last notified of their status.

 
 Restrict output to running jobs.

 
 Restrict output to stopped jobs.
 If the   option is supplied,   replaces any   found in   or   with the corresponding process group ID,
and executes   passing it  , returning its exit status.
 Exit a login shell.
 Copy at most   lines. If   is 0, all lines are copied.

 
 Begin assigning to   at index  . The default index is 0.

 
 Discard the first   lines read.

 
 Remove a trailing newline from each line read.

 
 Read lines from file descriptor   instead of the standard input.

 
 Evaluate   each time   lines are read. The   option specifies  .

 
 Specify the number of lines read between each call to  .
 If not supplied with an explicit origin,   will clear   before assigning to it.
  returns successfully unless an invalid option or option argument is supplied,   is invalid or unassignable, or if   is
not an indexed array.
 Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.

 
 Removes the  th entry counting from the left of the list shown by  , starting with zero. For example: ''popd +0'' removes the first
directory, ''popd +1'' the second.

 
 Removes the  th entry counting from the right of the list shown by  , starting with zero. For example: ''popd -0'' removes the last
directory, ''popd -1'' the next to last.
 The   option causes the output to be assigned to the variable   rather than being printed to the standard output.
 The   is reused as necessary to consume all of the  . If the   requires more   than are supplied, the
extra format specifications behave as if a zero value or null string, as appropriate, had been supplied. The return value is zero on success, non-zero on
failure.
 Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.

 
 Rotates the stack so that the  th directory (counting from the left of the list shown by  , starting with zero) is at the top.

 
 Rotates the stack so that the  th directory (counting from the right of the list shown by  , starting with zero) is at the top.

 
 Adds   to the directory stack at the top, making it the new current working directory.
 
 The words are assigned to sequential indices of the array variable  , starting at 0.   is unset before any new values are assigned.
Other   arguments are ignored.
 
 The first character of   is used to terminate the input line, rather than newline.
 If the standard input is coming from a terminal,   (see   above) is used to obtain the line. Readline uses the
current (or default, if line editing was not previously active) editing settings.
 
 If   is being used to read the line,   is placed into the editing buffer before editing begins.
 
  returns after reading   characters rather than waiting for a complete line of input, but honor a delimiter if fewer than
  characters are read before the delimiter.
 
  returns after reading exactly   characters rather than waiting for a complete line of input, unless EOF is encountered or
  times out. Delimiter characters encountered in the input are not treated specially and do not cause   to return until  
characters are read.
 
 Display   on standard error, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming
from a terminal.
 Backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used
as a line continuation.

 
 Silent mode. If input is coming from a terminal, characters are not echoed.
 
 Cause   to time out and return failure if a complete line of input is not read within   seconds.   may be a decimal
number with a fractional portion following the decimal point. This option is only effective if   is reading input from a terminal, pipe, or other
special file; it has no effect when reading from regular files. If   is 0,   returns success if input is available on the specified file
descriptor, failure otherwise. The exit status is greater than 128 if the timeout is exceeded.
 Read input from file descriptor  .
 Automatically mark variables and functions which are modified or created for export to the environment of subsequent commands.

 
 Report the status of terminated background jobs immediately, rather than before the next primary prompt. This is effective only when job control is enabled.

 
 Exit immediately if a   (which may consist of a single  ), a   command enclosed in parentheses, or one of
the commands executed as part of a command list enclosed by braces (see   above) exits with a non-zero status. The shell does
not exit if the command that fails is part of the command list immediately following a   or   keyword, part of the test following the
  or   reserved words, part of any command executed in a   or   list except the command following the final
  or  , any command in a pipeline but the last, or if the command's return value is being inverted with  . A trap on  ,
if set, is executed before the shell exits. This option applies to the shell environment and each subshell environment separately (see   above), and may cause subshells to exit before executing all the commands in the subshell.

 
 Disable pathname expansion.

 
 Remember the location of commands as they are looked up for execution. This is enabled by default.

 
 All arguments in the form of assignment statements are placed in the environment for a command, not just those that precede the command name.

 
 Monitor mode. Job control is enabled. This option is on by default for interactive shells on systems that support it (see  
above). Background processes run in a separate process group and a line containing their exit status is printed upon their completion.

 
 Read commands but do not execute them. This may be used to check a shell script for syntax errors. This is ignored by interactive shells.
 
 The   can be one of the following:

 
 Same as  .

 
 Same as  .

 
 Use an emacs-style command line editing interface. This is enabled by default when the shell is interactive, unless the shell is started with the
  option. This also affects the editing interface used for  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Enable command history, as described above under   This option is on by default in interactive shells.

 
 The effect is as if the shell command ''IGNOREEOF=10'' had been executed (see   above).

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Currently ignored.

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 Same as  .

 
 If set, the return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands in the pipeline
exit successfully. This option is disabled by default.

 
 Change the behavior of   where the default operation differs from the POSIX standard to match the standard ( ).

 
 Same as  .

 
 Same as  .

 
 Use a vi-style command line editing interface. This also affects the editing interface used for  .

 
 Same as  .

 If   is supplied with no  , the values of the current options are printed. If   is supplied with no  , a
series of   commands to recreate the current option settings is displayed on the standard output.
 Turn on   mode. In this mode, the   and   files are not processed, shell functions
are not inherited from the environment, and the   and
  variables, if they appear in the environment, are ignored. If the shell is started with the effective user (group) id not
equal to the real user (group) id, and the   option is not supplied, these actions are taken and the effective user id is set to the real user id. If
the   option is supplied at startup, the effective user id is not reset. Turning this option off causes the effective user and group ids to be set to
the real user and group ids.

 
 Exit after reading and executing one command.

 
 Treat unset variables and parameters other than the special parameters "@" and "*" as an error when performing parameter expansion. If expansion is
attempted on an unset variable or parameter, the shell prints an error message, and, if not interactive, exits with a non-zero status.

 
 Print shell input lines as they are read.

 
 After expanding each  ,   command,   command,   command, or arithmetic   command, display the
expanded value of   followed by the command and its expanded arguments or associated word list.

 
 The shell performs brace expansion (see   above). This is on by default.

 
 If set,   does not overwrite an existing file with the  ,  , and   redirection operators. This may be
overridden when creating output files by using the redirection operator   instead of  .

 
 If set, any trap on   is inherited by shell functions, command substitutions, and commands executed in a subshell environment. The   trap
is normally not inherited in such cases.

 
 Enable   style history substitution. This option is on by default when the shell is interactive.

 
 If set, the shell does not follow symbolic links when executing commands such as   that change the current working directory. It uses the physical
directory structure instead. By default,   follows the logical chain of directories when performing commands which change the current directory.

 
 If set, any traps on   and   are inherited by shell functions, command substitutions, and commands executed in a subshell
environment. The   and   traps are normally not inherited in such cases.

 
 If no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters are set to the  s, even if some
of them begin with a  .

 
 Signal the end of options, cause all remaining  s to be assigned to the positional parameters. The   and   options are turned off.
If there are no  s, the positional parameters remain unchanged.
 Enable (set) each  .

 
 Disable (unset) each  .

 
 Suppresses normal output (quiet mode); the return status indicates whether the   is set or unset. If multiple   arguments are
given with  , the return status is zero if all   are enabled; non-zero otherwise.

 
 Restricts the values of   to be those defined for the   option to the   builtin.
 The return status when listing options is zero if all   are enabled, non-zero otherwise. When setting or unsetting options, the return status
is zero unless an   is not a valid shell option.
 The list of   options is:
 If set, a command name that is the name of a directory is executed as if it were the argument to the   command. This option is only used by
interactive shells.
 
 If set, an argument to the   builtin command that is not a directory is assumed to be the name of a variable whose value is the directory to change
to.
 If set, minor errors in the spelling of a directory component in a   command will be corrected. The errors checked for are transposed characters, a
missing character, and one character too many. If a correction is found, the corrected file name is printed, and the command proceeds. This option is only used
by interactive shells.
 
 If set,   checks that a command found in the hash table exists before trying to execute it. If a hashed command no longer exists, a normal path
search is performed.
 
 If set,   lists the status of any stopped and running jobs before exiting an interactive shell. If any jobs are running, this causes the exit to
be deferred until a second exit is attempted without an intervening command (see   above). The shell always postpones exiting
if any jobs are stopped.
 
 If set,   checks the window size after each command and, if necessary, updates the values of   and
 
 If set,   attempts to save all lines of a multiple-line command in the same history entry. This allows easy re-editing of multi-line
commands.
 
 If set,   changes its behavior to that of version 3.1 with respect to quoted arguments to the conditional command's =~ operator.

 
 If set,   changes its behavior to that of version 3.2 with respect to locale-specific string comparison when using the conditional command's <
and > operators.
 
 If set,   changes its behavior to that of version 4.0 with respect to locale-specific string comparison when using the conditional command's <
and > operators and the effect of interrupting a command list.
 
 If set,   attempts spelling correction on directory names during word completion if the directory name initially supplied does not exist.

 If set,   includes filenames beginning with a '.' in the results of pathname expansion.
 
 If set, a non-interactive shell will not exit if it cannot execute the file specified as an argument to the   builtin command. An interactive
shell does not exit if   fails.
 
 If set, aliases are expanded as described above under   This option is enabled by default for interactive
shells.
 
 If set, behavior intended for use by debuggers is enabled:
 The   option to the   builtin displays the source file name and line number corresponding to each function name supplied as an
argument.

 
 If the command run by the   trap returns a non-zero value, the next command is skipped and not executed.

 
 If the command run by the   trap returns a value of 2, and the shell is executing in a subroutine (a shell function or a shell script executed by
the   or   builtins), a call to   is simulated.

 
  and   are updated as described in their descriptions above.

 
 Function tracing is enabled: command substitution, shell functions, and subshells invoked with       inherit the   and
  traps.

 
 Error tracing is enabled: command substitution, shell functions, and subshells invoked with       inherit the   trap.

 
 If set, the extended pattern matching features
 
 If set,  ' ' and  " " quoting is performed within   expansions enclosed in double
quotes. This option is enabled by default.
 
 If set, patterns which fail to match filenames during pathname expansion result in an expansion error.
 
 If set, the suffixes specified by the   shell variable cause words to be ignored when performing word completion even if the
ignored words are the only possible completions. See   above for a description of
  This option is enabled by default.
 
 If set, the pattern   used in a pathname expansion context will match a files and zero or more directories and subdirectories. If the pattern is
followed by a  , only directories and subdirectories match.
 
 If set, shell error messages are written in the standard GNU error message format.
 
 If set, the history list is appended to the file named by the value of the   variable when the shell exits, rather than
overwriting the file.
 
 If set, and   is being used, a user is given the opportunity to re-edit a failed history substitution.
 
 If set, and   is being used, the results of history substitution are not immediately passed to the shell parser. Instead, the resulting line
is loaded into the   editing buffer, allowing further modification.
 
 If set, and   is being used,   will attempt to perform hostname completion when a word containing a   is being completed (see
  under   above). This is enabled by default.
 
 If set,   will send   to all jobs when an interactive login shell exits.
 
 If set, allow a word beginning with   to cause that word and all remaining characters on that line to be ignored in an interactive shell (see
  above). This option is enabled by default.
 If set, and the   option is enabled, multi-line commands are saved to the history with embedded newlines rather than using semicolon separators
where possible.
 
 The shell sets this option if it is started as a login shell (see   above). The value may not be changed.

 
 If set, and a file that   is checking for mail has been accessed since the last time it was checked, the message ''The mail in   has
been read'' is displayed.
 
 If set, and   is being used,   will not attempt to search the   for possible completions when completion is
attempted on an empty line.
 
 If set,   matches filenames in a case-insensitive fashion when performing pathname expansion (see   above).

 
 If set,   matches patterns in a case-insensitive fashion when performing matching while executing   or   conditional
commands.
 
 If set,   allows patterns which match no files (see   above) to expand to a null string, rather than themselves.

 
 If set, the programmable completion facilities (see   above) are enabled. This option is enabled by default.

 
 If set, prompt strings undergo parameter expansion, command substitution, arithmetic expansion, and quote removal after being expanded as described in
  above. This option is enabled by default.
 
 The shell sets this option if it is started in restricted mode (see   below). The value may not be changed. This is not
reset when the startup files are executed, allowing the startup files to discover whether or not a shell is restricted.
 
 If set, the   builtin prints an error message when the shift count exceeds the number of positional parameters.
 
 If set, the   ( ) builtin uses the value of   to find the directory containing the file supplied as an argument.
This option is enabled by default.
 
 If set, the   builtin expands backslash-escape sequences by default.
 Expressions may be combined using the following operators, listed in decreasing order of precedence. The evaluation depends on the number of arguments; see
below.
 True if   is false.
 
 Returns the value of  . This may be used to override the normal precedence of operators.
 
 True if both   and   are true.
 
 True if either   or   is true.
 
 The expression is false.
 
 The expression is true if and only if the argument is not null.
 
 If the first argument is  , the expression is true if and only if the second argument is null. If the first argument is one of the unary conditional
operators listed above under   the expression is true if the unary test is true. If the first
argument is not a valid unary conditional operator, the expression is false.
 
 If the second argument is one of the binary conditional operators listed above under   the
result of the expression is the result of the binary test using the first and third arguments as operands. The   and   operators are considered
binary operators when there are three arguments. If the first argument is  , the value is the negation of the two-argument test using the second and
third arguments. If the first argument is exactly   and the third argument is exactly  , the result is the one-argument test of the second
argument. Otherwise, the expression is false.
 
 If the first argument is  , the result is the negation of the three-argument expression composed of the remaining arguments. Otherwise, the
expression is parsed and evaluated according to precedence using the rules listed above.
 
 The expression is parsed and evaluated according to precedence using the rules listed above.
 Print the accumulated user and system times for the shell and for processes run from the shell. The return status is 0.
 If a   is   (0) the command   is executed on exit from the shell. If a   is
  the command   is executed before every  ,   command,   command,
  command, every arithmetic   command, and before the first command executes in a shell function (see  
above). Refer to the description of the   option to the   builtin for details of its effect on the   trap. If a
  is   the command   is executed each time a shell function or a script executed with the
  or   builtins finishes executing.
 If a   is   the command   is executed whenever a simple command has a non-zero exit status,
subject to the following conditions. The   trap is not executed if the failed command is part of the command list immediately following
a   or   keyword, part of the test in an   statement, part of a command executed in a   or   list, or if
the command's return value is being inverted via  . These are the same conditions obeyed by the   option.
 Signals ignored upon entry to the shell cannot be trapped, reset or listed. Trapped signals that are not being ignored are reset to their original values in
a subshell or subshell environment when one is created. The return status is false if any   is invalid; otherwise   returns
true.
 All current limits are reported

 
 The maximum socket buffer size

 
 The maximum size of core files created

 
 The maximum size of a process's data segment

 
 The maximum scheduling priority ("nice")

 
 The maximum size of files written by the shell and its children

 
 The maximum number of pending signals

 
 The maximum size that may be locked into memory

 
 The maximum resident set size (many systems do not honor this limit)

 
 The maximum number of open file descriptors (most systems do not allow this value to be set)

 
 The pipe size in 512-byte blocks (this may not be set)

 
 The maximum number of bytes in POSIX message queues

 
 The maximum real-time scheduling priority

 
 The maximum stack size

 
 The maximum amount of cpu time in seconds

 
 The maximum number of processes available to a single user

 
 The maximum amount of virtual memory available to the shell

 
 The maximum number of file locks

 
 The maximum number of threads
 
 
 If   is started with the name  , or the   option is supplied at invocation, the shell becomes restricted. A restricted shell is
used to set up an environment more controlled than the standard shell. It behaves identically to   with the exception that the following are
disallowed or not performed:
 • setting or unsetting the values of   or  
 • specifying command names containing  
 • specifying a file name containing a   as an argument to the   builtin command

 • Specifying a filename containing a slash as an argument to the   option to the   builtin command

 • importing function definitions from the shell environment at startup

 • parsing the value of   from the shell environment at startup

 • redirecting output using the >, >|, <>, >&, &>, and >> redirection operators

 • using the   builtin command to replace the shell with another command

 • adding or deleting builtin commands with the   and   options to the   builtin command

 • Using the   builtin command to enable disabled shell builtins

 • specifying the   option to the   builtin command

 • turning off restricted mode with   or  .
 When a command that is found to be a shell script is executed (see   above),   turns off any restrictions
in the shell spawned to execute the script.
 
 
 , Brian Fox and Chet Ramey
 
 
 
 
 
 Brian Fox, Free Software Foundation 
 
 Chet Ramey, Case Western Reserve University 
 
 
 If you find a bug in   you should report it. But first, you should make sure that it really is a bug, and that it appears in the latest version
of  . The latest version is always available from  .
 Once you have determined that a bug actually exists, use the   command (from the source package) to submit a bug report. If you have a fix, you
are encouraged to mail that as well! Suggestions and 'philosophical' bug reports may be mailed to   or posted to the Usenet newsgroup
 .
 ALL bug reports should include:
 
 
 It's too big and too slow.
 There are some subtle differences between   and traditional versions of  , mostly because of the  
specification.
 Aliases are confusing in some uses.
 Shell builtin commands and functions are not stoppable/restartable.
 Compound commands and command sequences of the form 'a ; b ; c' are not handled gracefully when process suspension is attempted. When a process is stopped,
the shell immediately executes the next command in the sequence. It suffices to place the sequence of commands between parentheses to force it into a subshell,
which may be stopped as a unit.
 Array variables may not (yet) be exported.
 There may be only one active coprocess at a time.

  google_ad_section_end  
 
 (1),
 (1),
 (1),
 (7),
 (5),
 (7),
 (8),
 (5),
 (7),
 (1),
 (5),
 (1),
 (3),
 (5),
 (5),
 (5),
 (1),
 (1),
 (3),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (5),
 (1),
 (2),
 (7),
 (3),
 (1),
 (1),
 (1),
 (3),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1),
 (1)
 
 

 
 Get the highlights in your inbox every week. When a computer boots up, a kernel (whether it's Linux, BSD, Mach, or NT) recognizes all the physical hardware and enables each component to talk with one another and be orchestrated by some basic software. A computer's most basic set of instructions simply keeps it powered on and in a safe state: activating fans periodically to prevent overheating, using subsystems to monitor disk space or "listen" for newly attached devices, and so on. If this was all computers did, they'd be about as interesting as a convection oven. Computer scientists recognized this early on, so   a   for Unix computers that operates outside of the kernel (or   the kernel, like a shell in nature) and allows humans to interact with the computer whenever they want to. It was an exciting development at a time when people were feeding punchcards into computers to tell them what to do. Of all the shells available, Bash is one of the most popular, the most powerful, and the most friendly. When you start a terminal (such as the   or   on Linux or   on macOS) running the Bash shell, you're greeted with a  . A prompt is a symbol, usually a dollar sign ( ), indicating that the shell is waiting for your input. Of course, knowing what you're supposed to type is another matter entirely. This probably comes across as unfriendly, but it's actually a perfectly succinct representation of the many connotations around the term "Bash." To many new users, there's no separation between the concept of Bash and the concept of Linux or Unix: it's the proverbial black-screen-with-green-text into which you're supposed to code what your computer does next. That conflates the Bash shell with the   you type into the shell. It's important to understand that they're two separate things: Bash is just an application, and its primary job is to run   applications (in the form of commands) that are installed on the same system. You can learn Bash, but only in the context of learning the operating system that it's running on. Without knowing commands, there's not much you can do with Bash. On Linux and Unix (such as BSD and macOS), most commands are stored by default in system directories like   and  . By nature, Bash doesn't know these commands any more than you naturally know Klingonese, but just as you can look up Klingon words, Bash can look up commands. When you issue a command to Bash, it searches specific directories on your system to see whether such a command exists. If the command does exist, then Bash executes it. Bash is also a command, and it's usually the default command executed when you open a terminal window or log into a text console. To find out where any command is located on your system, Bash included, you can use the   command in a terminal: A few commands are built into Bash. Most built-in commands are specific to Bash scripting or low-level environment settings, but a few are universally useful, such as   (for  ). Built-in commands don't show up when you search for them because they don't exist in your usual executable path: They're still available, though, because they're built into Bash, and Bash is what you're running. Most modern Linux and Unix distributions provide a Bash shell by default. They do this because Bash is well-known, and it has several convenience functions that other shells don't. However, some systems use another shell by default. To find out whether you're running a Bash shell, you can use the   command along with a special variable representing the name of the currently running process: If you're not running Bash, but you'd like to try it, you can probably download and   from your software center, software repository, or ports tree. Or you can use   or Homebrew on macOS. If all else fails, visit the   for more information. Bash is a legitimate interface to your computer, and it's not just for server admins and programmers. It can be your desktop, your word processor, your graphics editing application, and much, much more. Some people use Bash more than they use desktop apps. There are hundreds of commands available for Linux and Unix, and it might surprise you just how diverse they are. For instance, you can resize and crop photos without ever opening the photo in a viewer or editor: You can play music with commands like   or  , convert audio with  , adjust and edit video with  , edit text with   or  , check email with   or  , browse the internet with  , browse files with   or  , and do much, much more. It's all done in Bash, using the commands you find on your system or in your software repository. One reason Bash (and Linux in general) is considered so powerful is because it's scriptable. Anything you can type into Bash manually, you can also list in a plain-text file and have Bash run it for you. Instead of spending an afternoon manually running a hundred commands, you can   the commands and have your computer execute them while you tend to more important matters. Because nearly everything on Linux runs on top of the Bash shell, nearly everything on Linux can be scripted through Bash. While there are exceptions to this (graphical applications may have their own scripting language, for instance, or no scripting at all), scripting your OS opens up tens of thousands of possible functions you can make happen on your computer without doing them yourself. The amount of work this saves Linux users each day is impossible to estimate. It's not the usual automation that makes the difference, though; it's the bespoke workflows that people invent for themselves, the things nobody else thinks need automation. When experienced users say that they want to learn Bash, if they don't mean they want to learn Linux commands, then they probably mean that they want to improve the way they script their commands. For instance, this is an extremely rudimentary Bash script that converts a temporary file (imagine it's a file created by a separate process) to a specific directory: That's valid Bash. You can verify it by copying and pasting the command (the last line beginning with  ) into a terminal. As long as there's a file called   and a directory called  , the command works. Learning Bash, though, is all about understanding how a simple command like this can be improved for the sake of automation. For instance, if the file   doesn't exist, then the script fails. If this script is a key component to, for instance, a blogging site that requires a new image each day so that a custom header image can be constructed, then the script's failure could cause catastrophic errors elsewhere. A user who knows Bash could add resiliency using Bash syntax: This is just one example of the process of learning to script with Bash, but it demonstrates how learning both Linux and Bash are equally useful and not entirely separate tasks. Bash is as powerful as other shells but adds convenience functions like the double brackets (  and  ) in the sample code. These "Bashisms" are much loved by Bash users because they avoid the sometimes verbose and awkward syntax in other shells like tcsh or ash. However, they are unique to Bash and are not  -compliant, which could cause compatibility issues on systems not running Bash. Then again, Bash is open source  , so most users can install it if they need it. The lack of compatibility only forces an extra dependency and does not exclude anyone from using a script. If you want to learn Bash, you can read any number of   on  . Or, you can take an   and even join in on some no-cost  . Best of all, you can also   to learn Bash. Good luck, and happy hacking! Get the highlights in your inbox every week.  
 For more discussion on open source and the role of the CIO in the enterprise, join us at  . The opinions expressed on this website are those of each author, not of the author's employer or of Red Hat. Opensource.com aspires to publish all content under a   but may not be able to do so in all cases. You are responsible for ensuring that you have the necessary permission to reuse any work on this site. Red Hat and the Red Hat logo are trademarks of Red Hat, Inc., registered in the United States and other countries. Copyright ©2020 Red Hat, Inc. 
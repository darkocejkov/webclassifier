
 
 Version 1.11 Last updated 20081227Â Edition  The primary reason for writing this document is that a lot of readers feel the existing   to be too short and incomplete, while the   guide is too much of a reference work.  There is nothing in between these two extremes.  I also wrote this guide on the general principal that not enough free basic courses are available, though they should be. This is a practical guide which, while not always being too serious, tries to give real-life instead of theoretical examples.  I partly wrote it because I don't get excited with stripped down and over-simplified examples written by people who know what they are talking about, showing some really cool Bash feature so much out of its context that you cannot ever use it in practical circumstances.  You can read that sort of stuff after finishing this book, which contains exercises and examples that will help you survive in the real world. From my experience as UNIX/Linux user, system administrator and trainer, I know that people can have years of daily interaction with their systems, without having the slightest knowledge of task automation.  Thus they often think that UNIX is not userfriendly, and even worse, they get the impression that it is slow and old-fashioned.  This problem is another one that can be remedied by this guide. Everybody working on a UNIX or UNIX-like system who wants to make life easier on themselves, power users and sysadmins alike, can benefit from reading this book.  Readers who already have a grasp of working the system using the command line will learn the ins and outs of shell scripting that ease execution of daily tasks.  System administration relies a great deal on shell scripting; common tasks are often automated using simple scripts.  This document is full of examples that will encourage you to write your own and that will inspire you to improve on existing scripts. Prerequisites/not in this course: You should be an experienced UNIX or Linux user, familiar with basic commands, man pages and documentation Being able to use a text editor Understand system boot and shutdown processes, init and initscripts Create users and groups, set passwords Permissions, special modes Understand naming conventions for devices, partitioning, mounting/unmounting file systems Adding/removing software on your system See   (or your local  ) if you haven't mastered one or more of these topics.  Additional information can be found in your system documentation (man and info pages), or at  . The most recent edition can be found at  .  You should find the same version at  . This guide is available in print from  . This guide has been translated: Chinese translation at  , by Wang Wei. Ukrainian translation at  , by Yaroslav Fedevych and his team. A french translation is in the making and will be linked to as soon as it is finished.   
 Thanks to all the friends who helped (or tried to) and to my husband; your encouraging words made this work possible.  Thanks to all the people who submitted bug reports, examples and remarks - among many, many others: Hans Bol, one of the groupies Mike Sim, remarks on style Dan Richter, for array examples Gerg Ferguson, for ideas on the title Mendel Leo Cooper, for making room #linux.be, for keeping my feet on the ground Frank Wang, for his detailed remarks on all the things I did wrong ;-) Special thanks to Tabatha Marshall, who volunteered to do a complete review and spell and grammar check.  We make a great team: she works when I sleep.  And vice versa ;-) Missing information, missing links, missing characters, remarks?  Mail it to 
 
the maintainer of this document.
 The author and publisher have made every effort in the preparation of this book to ensure the accuracy of the information.  However, the information contained in this book is offered without warranty, either express or implied.  Neither the author nor the publisher nor any dealer or distributor will be held liable for any damages caused or alleged to be caused either directly or indirectly by this book. The logos, trademarks and symbols used in this book are the properties of
their respective owners. , available from  .  The Bash shell is available on nearly every Linux system, and can these days be found on a wide variety of UNIX systems. Compiles easily if you need to make your own, tested on a wide variety of UNIX, Linux, MS Windows and other systems. The following typographic and usage conventions occur in this text:
   This guide discusses concepts useful in the daily life of the serious Bash user.  While a basic knowledge of the usage of the shell is required, we start with a discussion of the basic shell components and practices in the first three chapters. Chapters four to six are discussions of basic tools that are commonly used in shell scripts. Chapters eight to twelve discuss the most common constructs in shell scripts. All chapters come with exercises that will test your preparedness for the
next chapter. : Bash basics: why Bash is so good, building blocks, first guidelines on developing good scripts. : Script basics: writing and debugging. : The Bash Environment: initialization files, variables, quoting characters, shell expansion order, aliases, options. : Regular expressions: an introduction. : Sed: an introduction to the sed line editor. :Awk: introduction to the awk programming language. : Conditional statements: constructs used in Bash to test conditions. : Interactive scripts: making scripts user-friendly, catching user input. : Executing commands repetitively: constructs used in Bash to automate command execution. : Advanced variables: specifying variable types, introduction to arrays of variables, operations on variables. : Functions: an introduction. : Catching signals: introduction to process signalling, trapping user-sent signals. In this introduction module we Describe some common shells Point out GNU Bash advantages and features Describe the shell's building blocks Discuss Bash initialization files See how the shell executes commands Look into some simple script examples The UNIX shell program interprets user commands, which are either directly entered by the user, or which can be read from a file called the shell script or shell program.  Shell scripts are interpreted, not compiled.  The shell reads commands from the script line per line and searches for those commands on the system (see  ), while a compiler converts a program into machine readable form, an executable file - which may then be used in a shell script. Apart from passing commands to the kernel, the main task of a shell is providing a user environment, which can be configured individually using shell resource configuration files. Just like people know different languages and dialects, your UNIX system will usually offer a variety of shell types:  or Bourne Shell: the original shell still
used on UNIX systems and in UNIX-related environments.  This is the basic shell, a small program with few features.  While this is not the standard shell, it is still available on every Linux system for compatibility with UNIX programs.  or Bourne Again shell: the standard GNU
shell, intuitive and flexible.  Probably most advisable for beginning users while being at the same time a powerful tool for the advanced and professional user.  On Linux,   is the standard shell for common users.  This shell is a so-called   of the Bourne shell, a set
of add-ons and plug-ins.  This means that the Bourne Again shell is compatible with the Bourne shell: commands that work in  , also work in
 .  However, the reverse is not always the case.  All examples and exercises in this book use  .  or C shell: the syntax of this shell resembles that of the C programming language.  Sometimes asked for by programmers.  or TENEX C shell: a superset of the common C shell, enhancing user-friendliness and speed.  That is why some also call it the Turbo C shell.  or the Korn shell: sometimes appreciated
by people with a UNIX background.  A superset of the Bourne shell; with standard configuration a nightmare for beginning users. The file   gives an overview of known shells on a Linux system: Your default shell is set in the   file, like this line for user  : To switch from one shell to another, just enter the name of the new shell
in the active terminal.  The system finds the directory where the name occurs using the   settings, and since a shell is an executable file (program), the current shell activates it and it gets executed.  A new prompt is usually shown, because each shell has its typical appearance: The GNU project (GNU's Not UNIX) provides tools for UNIX-like system administration which are free software and comply to UNIX standards. Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use; these include command line editing, unlimited size command history, job control, shell functions and aliases, indexed arrays of unlimited size, and integer arithmetic in any base from two to sixty-four. Bash can run most sh scripts without modification. Like the other GNU projects, the bash initiative was started to preserve, protect and promote the freedom to use, study, copy, modify and redistribute software.  It is generally known that such conditions stimulate creativity.  This was also the case with the bash program, which has a lot of extra features that other shells can't offer. In addition to the single-character shell command line options which can generally be configured using the   shell built-in command, there are several multi-character options that you can use.  We will come across a couple of the more popular options in this and the following chapters; the complete list can be found in the Bash info pages,  -> . Startup files are scripts that are read and executed by Bash when it starts.  The following subsections describe different ways to start the shell, and the startup files that are read consequently. Interactive means you can enter commands.  The shell is not running because a script has been activated.  A login shell means that you got the shell after authenticating to the system, usually by giving your user name and password. Files read: ,   or  : first existing readable file is read  upon logout. Error messages are printed if configuration files exist but are not readable.  If a file does not exist, bash searches for the next. A non-login shell means that you did not have to authenticate to the system.  For instance, when you open a terminal using an icon, or a menu item, that is a non-login shell. Files read: This file is usually referred to in  :   See   for more information on the   construct. All scripts use non-interactive shells.  They are programmed to do certain tasks and cannot be instructed to do other jobs than those for which they are programmed. Files read: defined by   is not used to search for this file, so if you want to use it, best refer to it by giving the full path and file name. Bash tries to behave as the historical Bourne   program while conforming to the POSIX standard as well. Files read: When invoked interactively, the   variable can point to extra startup information. This option is enabled either using the   built-in:   or by calling the   program with the   option.  Bash will then try to behave as compliant as possible to the POSIX standard for shells.  Setting the   variable does the same. Files read: defined by   variable. Files read when invoked by  : Be aware of the dangers when using tools such as  ,  ,   and  .  They are intrinsically insecure because confidential data is sent over the network unencrypted.  If you need tools for remote execution, file transfer and so on, use an implementation of Secure SHell, generally known as SSH, freely available from  .  Different client programs are available for non-UNIX systems as well, see your local software mirror. No startup files are read in this case. An interactive shell generally reads from, and writes to, a user's terminal: input and output are connected to a terminal.  Bash interactive behavior is started when the   command is called upon without non-option arguments, except when the option is a string to read from or when the shell is invoked to read from standard input, which allows for positional parameters to be set (see   ). Test by looking at the content of the special parameter  , it contains an 'i' when the shell is interactive: In non-interactive shells, the prompt,  , is unset. Differences in interactive mode: Bash reads startup files. Job control enabled by default. Prompts are set,   is enabled for multi-line commands, it is usually set to  .  This is also the prompt you get when the shell thinks you entered an unfinished command, for instance when you forget quotes, command structures that cannot be left out, etc. Commands are by default read from the command line using  . Bash interprets the shell option   instead of exiting immediately upon receiving EOF (End Of File). Command history and history expansion are enabled by default.  History is saved in the file pointed to by   when the shell exits.  By default,   points to  . Alias expansion is enabled. In the absence of traps, the   signal is ignored. In the absence of traps,   is caught and handled.  Thus, typing  + , for example, will not quit your interactive shell. Sending   signals to all jobs on exit is configured with the   option. Commands are executed upon read. Bash checks for mail periodically. Bash can be configured to exit when it encounters unreferenced variables.  In interactive mode this behavior is disabled. When shell built-in commands encounter redirection errors, this will not cause the shell to exit. Special built-ins returning errors when used in POSIX mode don't cause the shell to exit.  The built-in commands are listed in  . Failure of   will not exit the shell. Parser syntax errors don't cause the shell to exit. Simple spell check for the arguments to the   built-in is enabled by default. Automatic exit after the length of time specified in the   variable has passed, is enabled. More information: See   for more about signals.  discusses the various expansions performed upon entering a command. Conditional expressions are used by the   compound command and by the   and   built-in commands. Expressions may be unary or binary.  Unary expressions are often used to examine the status of a file.  You only need one object, for instance a file, to do the operation on. There are string operators and numeric comparison operators as well; these are binary operators, requiring two objects to do the operation on.  If the   argument to one of the primaries is in the form  , then file descriptor N is checked.  If the   argument to one of the primaries is one of  ,   or  , then file descriptor 0, 1 or 2 respectively is checked. Conditionals are discussed in detail in  . More information about the file descriptors in  . The shell allows arithmetic expressions to be evaluated, as one of
the shell expansions or by the   built-in. Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error.  The operators and their precedence and associativity are the same as in the C language, see  . Aliases allow a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the   and   commands. Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed. We will discuss aliases in detail in  . Bash provides one-dimensional array variables.  Any variable may be used as an array; the   built-in will explicitly declare an array.  There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously.  Arrays are zero-based.  See  . The directory stack is a list of recently-visited directories.  The   built-in adds directories to the stack as it changes the current directory, and the   built-in removes specified directories from the stack and changes the current directory to the directory removed. Content can be displayed issuing the   command or by checking the content of the   variable. More information about the workings of this mechanism can be found in the Bash info pages. Bash makes playing with the prompt even more fun.  See the section   in the Bash info pages. When invoked as   or with the   or   option, the following happens: The   built-in is disabled. Setting or unsetting  ,  ,   or   is not possible. Command names can no longer contain slashes. Filenames containing a slash are not allowed with the   ( ) built-in command. The   built-in does not accept slashes with the   option. Import of functions at startup is disabled.  is ignored at startup. Output redirection using  ,  ,  ,  ,   and   is disabled. The   built-in is disabled. The   and   options are disabled for the   built-in. A default   cannot be specified with the   built-in. Turning off restricted mode is not possible. When a command that is found to be a shell script is executed,   turns off any restrictions in the shell spawned to execute the script. More information: -> -> : advanced redirection Bash determines the type of program that is to be executed.  Normal programs are system commands that exist in compiled form on your system.  When such a program is executed, a new process is created because Bash makes an exact copy of itself.  This child process has the same environment as its parent, only the process ID number is different.  This procedure is called  . After the forking process, the address space of the child process is overwritten with the new process data.  This is done through an   call to the system. The   mechanism thus switches an old command with a new, while the environment in which the new program is executed remains the same, including configuration of input and output devices, environment variables and priority.  This mechanism is used to create all UNIX processes, so it also applies to the Linux operating system.  Even the first process,  , with process ID 1, is forked during the boot procedure in the so-called   procedure. Built-in commands are contained within the shell itself.  When the name of a built-in command is used as the first word of a simple command, the shell executes the command directly, without creating a new process.  Built-in commands are necessary to implement functionality impossible or inconvenient to obtain with separate utilities. Bash supports 3 types of built-in commands: Bourne Shell built-ins: ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Bash built-in commands: ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Special built-in commands: When Bash is executing in POSIX mode, the special built-ins differ from other built-in commands in three respects: Special built-ins are found before shell functions during command lookup. If a special built-in returns an error status, a non-interactive shell exits. Assignment statements preceding the command stay in effect in the shell environment after the command completes. The POSIX special built-ins are  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Most of these built-ins will be discussed in the next chapters.  For those commands for which this is not the case, we refer to the Info pages. When the program being executed is a shell script, bash will create a new bash process using a  .  This subshell reads the lines from the shell script one line at a time.  Commands on each line are read, interpreted and executed as if they would have come directly from the keyboard. While the subshell processes each line of the script, the parent shell waits for its child process to finish.  When there are no more lines in the shell script to read, the subshell terminates.  The parent shell awakes and displays a new prompt. If input is not commented, the shell reads it and divides it into words and operators, employing quoting rules to define the meaning of each character of input.  Then these words and operators are translated into commands and other constructs, which return an exit status available for inspection or processing.  The above fork-and-exec scheme is only applied after the shell has analyzed input in the following way: The shell reads its input from a file, from a string or from the user's terminal. Input is broken up into words and operators, obeying the quoting rules, see  .  These tokens are separated by  .  Alias expansion is performed. The shell   (analyzes and substitutes) the tokens into simple and compound commands. Bash performs various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Redirection is performed if necessary, redirection operators and their operands are removed from the argument list. Commands are executed. Optionally the shell waits for the command to complete and collects its exit status. A simple shell command such as   consists of the command itself followed by arguments, separated by spaces. More complex shell commands are composed of simple commands arranged together in a variety of ways: in a pipeline in which the output of one command becomes the input of a second, in a loop or conditional construct, or in some other grouping.  A couple of examples:     Shell functions are a way to group commands for later execution using a single name for the group.  They are executed just like a   command.  When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Shell functions are executed in the current shell context; no new process is created to interpret them. Functions are explained in  . A parameter is an entity that stores values.  It can be a name, a number or a special value.  For the shell's purpose, a variable is a parameter that stores a name.  A variable has a value and zero or more attributes.  Variables are created with the   shell built-in command. If no value is given, a variable is assigned the null string.  Variables can only be removed with the   built-in. Assigning variables is discussed in  , advanced use of variables in  . Shell expansion is performed after each command line has been split into tokens.  These are the expansions performed: Brace expansion Tilde expansion Parameter and variable expansion Command substitution Arithmetic expansion Word splitting Filename expansion We'll discuss these expansion types in detail in  . Before a command is executed, its input and output may be redirected using a special notation interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment. When executing a command, the words that the parser has marked as variable assignments (preceding the command name) and redirections are saved for later reference.  Words that are not variable assignments or redirections are expanded; the first remaining word after expansion is taken to be the name of the command and the rest are arguments to that command.  Then redirections are performed, then strings assigned to variables are expanded.  If no command name results, variables will affect the current shell environment. An important part of the tasks of the shell is to search for commands.  Bash does this as follows: Check whether the command contains slashes.  If not, first check with the function list to see if it contains a command by the name we are looking for. If command is not a function, check for it in the built-in list. If command is neither a function nor a built-in, look for it analyzing the directories listed in  .  Bash uses a   (data storage area in memory) to remember the full path names of executables so extensive   searches can be avoided. If the search is unsuccessful, bash prints an error message and returns an exit status of 127. If the search was successful or if the command contains slashes, the shell executes the command in a separate execution environment. If execution fails because the file is not executable and not a directory, it is assumed to be a shell script. If the command was not begun asynchronously, the shell waits for the command to complete and collects its exit status. When a file containing shell commands is used as the first non-option argument when invoking Bash (without   or  , this will create a non-interactive shell.  This shell first searches for the script file in the current directory, then looks in   if the file cannot be found there. This guide is mainly about the last shell building block, scripts.  Some general considerations before we continue: A script should run without errors. It should perform the task for which it is intended. Program logic is clearly defined and apparent. A script does not do unnecessary work. Scripts should be reusable. The structure of a shell script is very flexible.  Even though in Bash a lot of freedom is granted, you must ensure correct logic, flow control and efficiency so that users executing the script can do so easily and correctly. When starting on a new script, ask yourself the following questions: Will I be needing any information from the user or from the user's environment? How will I store that information? Are there any files that need to be created?  Where and with which permissions and ownerships? What commands will I use?  When using the script on different systems, do all these systems have these commands in the required versions? Does the user need any notifications?  When and why? The table below gives an overview of programming terms that you need to be familiar with: In order to speed up the developing process, the logical order of a program should be thought over in advance.  This is your first step when developing a script. A number of methods can be used; one of the most common is working with lists.  Itemizing the list of tasks involved in a program allows you to describe each process.  Individual tasks can be referenced by their item number. Using your own spoken language to pin down the tasks to be executed by your program will help you to create an understandable form of your program.  Later, you can replace the everyday language statements with shell language words and constructs. The example below shows such a logic flow design.  It describes the rotation of log files.  This example shows a possible repetitive loop, controlled by the number of base log files you want to rotate: Do you want to rotate logs? If yes: Enter directory name containing the logs to be rotated. Enter base name of the log file. Enter number of days logs should be kept. Make settings permanent in user's crontab file. If no, go to step 3. Do you want to rotate another set of logs? If yes: repeat step 1. If no: go to step 3. Exit The user should provide information for the program to do something.  Input from the user must be obtained and stored.  The user should be notified that his crontab will change. The   script below executes some well-known commands ( ,  ,  ,  ) to display information about you and your machine. A script always starts with the same two characters,  .  After that, the shell that will execute the commands following the first line is defined.  This script starts with clearing the screen on line 2.  Line 3 makes it print a message, informing the user about what is going to happen.  Line 5 greets the user.  Lines 6, 9, 13, 16 and 20 are only there for orderly output display purposes.  Line 8 prints the current date and the number of the week.  Line 11 is again an informative message, like lines 3, 18 and 22.  Line 12 formats the output of the  ; line 15 shows operating system and CPU information.  Line 19 gives the uptime and load information. Both   and   are Bash built-in commands.  The first always exits with a 0 status, and simply prints arguments followed by an end of line character on the standard output, while the latter allows for definition of a formatting string and gives a non-zero exit status code upon failure. This is the same script using the   built-in: Creating user friendly scripts by means of inserting messages is treated in  . This implies that the   program is installed in  . If you execute a script from cron, supply full path names and redirect output and errors.  Since the shell runs in non-interactive mode, any errors will cause the script to exit prematurely if you don't think about this. The following chapters will discuss the details of the above scripts. An init script starts system services on UNIX and Linux machines.  The system log daemon, the power management daemon, the name and mail daemons are common examples.  These scripts, also known as startup scripts, are stored in a specific location on your system, such as   or  .  Init, the initial process, reads its configuration files and decides which services to start or stop in each run level.  A run level is a configuration of processes; each system has a single user run level, for instance, for performing administrative tasks, for which the system has to be in an unused state as much as possible, such as recovering a critical file system from a backup.  Reboot and shutdown run levels are usually also configured. The tasks to be executed upon starting a service or stopping it are listed in the startup scripts.  It is one of the system administrator's tasks to configure  , so that services are started and stopped at the correct moment.  When confronted with this task, you need a good understanding of the startup and shutdown procedures on your system.  We therefore advise that you read the man pages for   and   before starting on your own initialization scripts. Here is a very simple example, that will play a sound upon starting and stopping your machine: The   statement often used in this kind of script is described in  . Bash is the GNU shell, compatible with the Bourne shell and incorporating many useful features from other shells.  When the shell is started, it reads its configuration files.  The most important are: Bash behaves different when in interactive mode and also has a POSIX compliant and a restricted mode. Shell commands can be split up in three groups: the shell functions, shell built-ins and existing commands in a directory on your system.  Bash supports additional built-ins not found in the plain Bourne shell. Shell scripts consist of these commands arranged as shell syntax dictates.  Scripts are read and executed line per line and should have a logical structure. These are some exercises to warm you up for the next chapter: Where is the   program located on your system? Use the   option to find out which version you are running. Which shell configuration files are read when you login to your system using the graphical user interface and then opening a terminal window? Are the following shells interactive shells?  Are they login shells? A shell opened by clicking on the background of your graphical desktop, selecting   or such from a menu. A shell that you get after issuing the command  . A shell that you get when logging in to the console in text mode. A shell obtained by the command  . A shell opened by the   script. A shell that you get on a remote host, for which you didn't have to give the login and/or password because you use SSH and maybe SSH keys. Can you explain why   does not exit when you type  +  on the command line? Display directory stack content. If it is not yet the case, set your prompt so that it displays your location in the file system hierarchy, for instance add this line to  :   Display hashed commands for your current shell session. How many processes are currently running on your system?  Use   and  , the first line of output of   is not a process! How to display the system hostname?  Only the name, nothing more! After going through this chapter, you will be able to: Write a simple script Define the shell type that should execute the script Put comments in a script Change permissions on a script Execute and debug a script A shell script is a sequence of commands for which you have a repeated use.  This sequence is typically executed by entering the name of the script on the command line.  Alternatively, you can use scripts to automate tasks using the cron facility.  Another use for scripts is in the UNIX boot and shutdown procedure, where operation of daemons and services are defined in init scripts. To create a shell script, open a new empty file in your editor.  Any text editor will do:  ,  ,  ,   et cetera are all valid.  You might want to chose a more advanced editor like   or  , however, because these can be configured to recognize shell and Bash syntax and can be a great help in preventing those errors that beginners frequently make, such as forgetting brackets and semi-colons. In order to activate syntax highlighting in  , use the command   or   or   You can add this setting to your   file to make it permanent. Put UNIX commands in the new empty file, like you would enter them on the command line.   As discussed in the previous chapter (see  ), commands can be shell functions, shell built-ins, UNIX commands and other scripts. Give your script a sensible name that gives a hint about what the script does.  Make sure that your script name does not conflict with existing commands.  In order to ensure that no confusion can rise, script names often end in  ; even so, there might be other scripts on your system with the same name as the one you chose.  Check using  ,   and other commands for finding information about programs and files:       In this example we use the   Bash built-in to inform the user about what is going to happen, before the task that will create the output is executed.  It is strongly advised to inform users about what a script is doing, in order to prevent them from becoming nervous  .  We will return to the subject of notifying users in  . Write this script for yourself as well.  It might be a good idea to create a directory   to hold your scripts.  Add the directory to the contents of the   variable:   If you are just getting started with Bash, use a text editor that uses different colours for different shell constructs.  Syntax highlighting is supported by  ,  ,  ,   and many other editors; check the documentation of your favorite editor. The prompts throughout this course vary depending on the author's mood.  This resembles much more real life situations than the standard educational   prompt.  The only convention we stick to, is that the   prompt ends in a hash mark (#). The script should have execute permissions for the correct owners in order to be runnable.  When setting permissions, check that you really obtained the permissions that you want.  When this is done, the script can run like any other command: This is the most common way to execute a script.  It is preferred to execute the script like this in a subshell.  The variables, functions and aliases created in this subshell are only known to the particular bash session of that subshell.  When that shell exits and the parent regains control, everything is cleaned up and all changes to the state of the shell made by the script, are forgotten. If you did not put the   directory in your  , and   (the current directory) is not in the   either, you can activate the script like this:   A script can also explicitly be executed by a given shell, but generally we only do this if we want to obtain special behavior, such as checking if the script works with another shell or printing traces for debugging:       The specified shell will start as a subshell of your current shell and execute the script.  This is done when you want the script to start up with specific options or under specific conditions which are not specified in the script. If you don't want to start a new shell but execute the script in the current shell, you   it:   The Bash   built-in is a synonym for the Bourne shell   (dot) command. The script does not need execute permission in this case.  Commands are executed in the current shell context, so any changes made to your environment will be visible when the script finishes execution: When running a script in a subshell, you should define which shell should run the script.  The shell type in which you wrote the script might not be the default on your system, so commands you entered might result in errors when executed by the wrong shell. The first line of the script determines the shell to start.  The first two characters of the first line should be  , then follows the path to the shell that should interpret the commands that follow.  Blank lines are also considered to be lines, so don't start your script with an empty line. For the purpose of this course, all scripts will start with the line   As noted before, this implies that the Bash executable can be found in  . You should be aware of the fact that you might not be the only person reading your code.  A lot of users and system administrators run scripts that were written by other people.  If they want to see how you did it, comments are useful to enlighten the reader. Comments also make your own life easier.  Say that you had to read a lot of man pages in order to achieve a particular result with some command that you used in your script.   You won't remember how it worked if you need to change your script after a few weeks or months, unless you have commented what you did, how you did it and/or why you did it. Take the   example and copy it to  , which we edit so that the comments reflect what the script does.  Everything the shell encounters after a hash mark on a line is ignored and only visible upon opening the shell script file: In a decent script, the first lines are usually comment about what to expect.  Then each big chunk of commands will be commented as needed for clarity's sake.  Linux init scripts, as an example, in your system's   directory, are usually well commented since they have to be readable and editable by everyone running Linux. When things don't go according to plan, you need to determine what exactly causes the script to fail.  Bash provides extensive debugging features.  The most common is to start up the subshell with the   option, which will run the entire script in debug mode.  Traces of each command plus its arguments are printed to standard output after the commands have been expanded but before they are executed. This is the   script ran in debug mode.  Note again that the added comments are not visible in the output of the script. There is now a full-fledged debugger for Bash, available at  .  These debugging features are available in most modern versions of Bash, starting from 3.x. Using the   Bash built-in you can run in normal mode those portions of the script of which you are sure they are without fault, and display debugging information only for troublesome zones.  Say we are not sure what the   command will do in the example  , then we could enclose it in the script like this: Output then looks like this: You can switch debugging mode on and off as many times as you want within the same script. The table below gives an overview of other useful Bash options: The dash is used to activate a shell option and a plus to deactivate it.  Don't let this confuse you! In the example below, we demonstrate these options on the command line: Alternatively, these modes can be specified in the script itself, by adding the desired options to the first line shell declaration.  Options can be combined, as is usually the case with UNIX commands:   Once you found the buggy part of your script, you can add   statements before each command of which you are unsure, so that you will see exactly where and why things don't work.  In the example   script, it could be done like this, still assuming that the displaying of users gives us problems: In more advanced scripts, the   can be inserted to display the content of variables at different stages in the script, so that flaws can be detected: A shell script is a reusable series of commands put in an executable text file.  Any text editor can be used to write scripts. Scripts start with   followed by the path to the shell executing the commands from the script.  Comments are added to a script for your own future reference, and also to make it understandable for other users.  It is better to have too many explanations than not enough. Debugging a script can be done using shell options.  Shell options can be used for partial debugging or for analyzing the entire script.  Inserting   commands at strategic locations is also a common troubleshooting technique. This exercise will help you to create your first script. Write a script using your favorite editor.  The script should display the path to your homedirectory and the terminal type that you are using.  Additionally it shows all the services started up in runlevel 3 on your system.  (hint: use  ,   and  ) Add comments in your script. Add information for the users of your script. Change permissions on your script so that you can run it. Run the script in normal mode and in debug mode.  It should run without errors. Make errors in your script: see what happens if you misspell commands, if you leave out the first line or put something unintelligible there, or if you misspell shell variable names or write them in lower case characters after they have been declared in capitals.  Check what the debug comments say about this. In this chapter we will discuss the various ways in which the Bash environment can be influenced: Editing shell initialization files Using variables Using different quote styles Perform arithmetic calculations Assigning aliases Using expansion and substitution When invoked interactively with the   option or when invoked as  , Bash reads the   instructions.  These usually set the shell variables  ,  ,  ,   and  . On some systems, the   value is configured in  ; on other systems this file holds pointers to other configuration files such as: , the system-wide Readline initialization file where you can configure the command line bell-style. the   directory, which contains files configuring system-wide behavior of specific programs. All settings that you want to apply to all your users' environments should be in this file.  It might look like this: This configuration file sets some basic shell environment variables as well as some variables required by users running Java and/or Java applications in their web browser.  See  . See   for more on the conditional   used in this file;   discusses loops such as the   construct. The Bash source contains sample   files for general or individual use.  These and the one in the example above need changes in order for them to work in your environment! On systems offering multiple types of shells, it might be better to put Bash-specific configurations in this file, since   is also read by other shells, such as the Bourne shell.  Errors generated by shells that don't understand the Bash syntax are prevented by splitting the configuration files for the different types of shells.  In such cases, the user's   might point to   in order to include it in the shell initialization process upon login. You might also find that   on your system only holds shell environment and program startup settings, while   contains system-wide definitions for shell functions and aliases.  The   file might be referred to in   or in individual user shell initialization files. The source contains sample   files, or you might find a copy in  .  This is part of the   that comes with the Bash documentation: Apart from general aliases, it contains useful aliases which make commands work even if you misspell them.  We will discuss aliases in  .  This file contains a function,  ; functions will be studied in detail in  . These files might not be in your home directory by default; create them if needed. This is the preferred configuration file for configuring user environments individually.  In this file, users can add extra configuration options or change default settings: This user configures the backspace character for login on different operating systems.  Apart from that, the user's   and   are read. This file contains specific settings that are normally only executed when you log in to the system.  In the example, we use it to configure the   value and to show a list of connected users upon login.  This user also gets the calendar for the current month: In the absence of  , this file will be read. In the absence of   and  ,   is read.  It can hold the same configurations, which are then also accessible by other shells.  Mind that other shells might not understand the Bash syntax. Today, it is more common to use a non-login shell, for instance when logged in graphically using X terminal windows.  Upon opening such a window, the user does not have to provide a user name or password; no authentication is done.  Bash searches for   when this happens, so it is referred to in the files read upon login as well, which means you don't have to enter the same settings in multiple files. In this user's   a couple of aliases are defined and variables for specific programs are set after the system-wide   is read: More examples can be found in the Bash package.  Remember that sample files might need changes in order to work in your environment. Aliases are discussed in  . This file contains specific instructions for the logout procedure.  In the example, the terminal window is cleared upon logout.  This is useful for remote connections, which will leave a clean window after closing them. When making changes to any of the above files, users have to either reconnect to the system or   the altered file for the changes to take effect.  By interpreting the script this way, changes are applied to the current shell session: Most shell scripts execute in a private environment: variables are not inherited by child processes unless they are exported by the parent shell.  Sourcing a file containing shell commands is a way of applying changes to your own environment and setting variables in the current shell. This example also demonstrates the use of different prompt settings by different users.  In this case, red means danger.  When you have a green prompt, don't worry too much. Note that   is the same as  . Should you get lost in all these configuration files, and find yourself confronted with settings of which the origin is not clear, use   statements, just like for debugging scripts; see  .  You might add lines like this: or like this: As seen in the examples above, shell variables are in uppercase
characters by convention.  Bash keeps a list of two types of variables: Global variables or environment variables are available in all shells.  The   or   commands can be used to display environment variables.  These programs come with the   package. Below is a typical output: Local variables are only available in the current shell.  Using the   built-in command without any options will display a list of all variables (including environment variables) and functions.  The output will be sorted according to the current locale and displayed in a reusable format. Below is a diff file made by comparing   and   output, after leaving out the functions which are also displayed by the   command: the GNU Awk programming language is explained in  . Apart from dividing variables in local and global variables, we can also divide them in categories according to the sort of content the variable contains.  In this respect, variables come in 4 types: String variables Integer variables Constant variables Array variables We'll discuss these types in  .  For now, we will work with integer and string values for our variables. Variables are case sensitive and capitalized by default.  Giving local variables a lowercase name is a convention which is sometimes applied.  However, you are free to use the names you want or to mix cases.  Variables can also contain digits, but a name starting with a digit is not allowed: To set a variable in the shell, use   Putting spaces around the equal sign will cause errors.  It is a good habit to quote content strings when assigning values to variables: this will reduce the chance that you make errors. Some examples using upper and lower cases, numbers and spaces: A variable created like the ones in the example above is only available to the current shell.  It is a local variable: child processes of the current shell will not be aware of this variable.  In order to pass variables to a subshell, we need to   them using the   built-in command.  Variables that are exported are referred to as environment variables.  Setting and exporting is usually done in one step:   A subshell can change variables it inherited from the parent, but the changes made by the child don't affect the parent.  This is demonstrated in the example: When first trying to read the value of   in a subshell, it is not there (  shows a null string).  The subshell quits, and   is exported in the parent - a variable can be exported after it has been assigned a value.  Then a new subshell is started, in which the variable exported from the parent is visible.  The variable is changed to hold another name, but the value for this variable in the parent stays the same. Bash uses certain shell variables in the same way as the Bourne shell.  In some cases, Bash assigns a default value to the variable.  The table below gives an overview of these plain shell variables: These variables are set or used by Bash, but other shells do not normally treat them specially. Check the Bash man, info or doc pages for extended information.  Some variables are read-only, some are set automatically and some lose their meaning when set to a different value than the default. The shell treats several parameters specially.  These parameters may only be referenced; assignment to them is not allowed. The implementation of   has always been a problem and realistically should have been replaced with the behavior of  .  In almost every case where coders use  , they mean  .    Can cause bugs and even security holes in your software. The positional parameters are the words following the name of a shell script.  They are put into the variables  ,  ,   and so on.  As long as needed, variables are added to an internal array.    holds the total number of parameters, as is demonstrated with this simple script: Upon execution one could give any numbers of arguments: More on evaluating these parameters is in   and  . Some examples on the other special parameters: User   starts entering the   command, which results in the assignment of the   variable.  The process ID of his shell is 10662.  After putting a job in the background, the   holds the process ID of the backgrounded job.  The shell running is  .  When a mistake is made,   holds an exit code different from 0 (zero). Apart from making the script more readable, variables will also enable you to faster apply a script in another environment or for another purpose.  Consider the following example, a very simple script that makes a backup of  's home directory to a remote server: First of all, you are more likely to make errors if you name files and directories manually each time you need them.  Secondly, suppose   wants to give this script to  , then carol will have to do quite some editing before she can use the script to back up her home directory.  The same is true if   wants to use this script for backing up other directories.  For easy recycling, make all files, directories, usernames, servernames etcetera variable.  Thus, you only need to edit a value once, without having to go through the entire script to check where a parameter occurs.  This is an example: The above is purely an example that everybody can understand, using a small directory and a host on the same subnet.  Depending on your bandwidth, the size of the directory and the location of the remote server, it can take an awful lot of time to make backups using this mechanism.  For larger directories and lower bandwidth, use   to keep the directories at both ends synchronized. A lot of keys have special meanings in some context or other.  Quoting is used to remove the special meaning of characters or words: quotes can disable special treatment for special characters, they can prevent reserved words from being recognized as such and they can disable parameter expansion. Escape characters are used to remove the special meaning from a single character.  A non-quoted backslash, \, is used as an escape character in Bash.  It preserves the literal value of the next character that follows, with the exception of  .  If a newline character appears immediately after the backslash, it marks the continuation of a line when it is longer that the width of the terminal; the backslash is removed from the input stream and effectively ignored. In this example, the variable   is created and set to hold a value.  The first   displays the value of the variable, but for the second, the dollar sign is escaped. Single quotes ('') are used to preserve the literal value of each character enclosed within the quotes.  A single quote may not occur between single quotes, even when preceded by a backslash. We continue with the previous example: Using double quotes the literal value of all characters enclosed is preserved, except for the dollar sign, the backticks (backward single quotes, ``) and the backslash. The dollar sign and the backticks retain their special meaning within the double quotes. The backslash retains its meaning only when followed by dollar, backtick, double quote, backslash or newline.  Within double quotes, the backslashes are removed from the input stream when followed by one of these characters.  Backslashes preceding characters that don't have a special meaning are left unmodified for processing by the shell interpreter. A double quote may be quoted within double quotes by preceding it with a backslash. Words in the form   are treated in a special way.  The word expands to a string, with backslash-escaped characters replaced as specified by the ANSI-C standard.  Backslash escape sequences can be found in the Bash documentation. A double-quoted string preceded by a dollar sign will cause the string to be translated according to the current locale.  If the current locale is   or  , the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted. After the command has been split into   (see  ), these tokens or words are expanded or resolved.  There are eight kinds of expansion performed, which we will discuss in the next sections, in the order that they are expanded. After all expansions, quote removal is performed. Brace expansion is a mechanism by which arbitrary strings may be generated.  Patterns to be brace-expanded take the form of an optional  , followed by a series of comma-separated strings between a pair of braces, followed by an optional  .  The preamble is prefixed to each string contained within the braces, and the postscript is then appended to each resulting string, expanding left to right. Brace expansions may be nested.  The results of each expanded string are not sorted; left to right order is preserved: Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result.  It is strictly textual.  Bash does not apply any syntactic interpretation to the context of the expansion or the text between the braces.  To avoid conflicts with parameter expansion, the string   is not considered eligible for brace expansion. A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma.  Any incorrectly formed brace expansion is left unchanged. If a word begins with an unquoted tilde character ( ), all of the characters up to the first unquoted slash (or all characters, if there is no unquoted slash) are considered a  .  If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login name.  If this login name is the null string, the tilde is replaced with the value of the   shell variable.  If   is unset, the home directory of the user executing the shell is substituted instead.  Otherwise, the tilde-prefix is replaced with the home directory associated with the specified login name. If the tilde-prefix is  , the value of the shell variable   replaces the tilde-prefix.  If the tilde-prefix is  , the value of the shell variable  , if it is set, is substituted. If the characters following the tilde in the tilde-prefix consist of a number N, optionally prefixed by a   or a  , the tilde-prefix is replaced with the corresponding element from the directory stack, as it would be displayed by the   built-in invoked with the characters following tilde in the tilde-prefix as an argument.  If the tilde-prefix, without the tilde, consists of a number without a leading   or  ,   is assumed. If the login name is invalid, or the tilde expansion fails, the word
is left unchanged. Each variable assignment is checked for unquoted tilde-prefixes immediately following a   or  .  In these cases, tilde expansion is also performed.  Consequently, one may use file names with tildes in assignments to  ,  , and  , and the shell assigns the expanded value. Example:  will be expanded to  , so if   is  , the directory   will be added to the content of the   variable. The   character introduces parameter expansion, command substitution, or arithmetic expansion.  The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name. When braces are used, the matching ending brace is the first   not escaped by a backslash or within a quoted string, and not within an embedded arithmetic expansion, command substitution, or parameter expansion. The basic form of parameter expansion is  .  The value of   is substituted.  The braces are required when   is a positional parameter with more than one digit, or when   is followed by a character that is not to be interpreted as part of its name. If the first character of   is an exclamation point,  Bash uses the value of the variable formed from the rest of   as the name of the variable; this variable is then expanded and that value is used in the rest of the substitution, rather than the value of   itself.  This is known as  . You are certainly familiar with straight parameter expansion, since it happens all the time, even in the simplest of cases, such as the one above or the following: The following is an example of indirect expansion: Note that this is not the same as  . The following construct allows for creation of the named variable if it does not yet exist:   Example: Special parameters, among others the positional parameters, may not be assigned this way, however. We will further discuss the use of the curly braces for treatment of variables in  .  More information can also be found in the Bash info pages. Command substitution allows the output of a command to replace the
command itself.  Command substitution occurs when a command is enclosed like this:   or like this using backticks:   Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted.  Embedded newlines are not deleted, but they may be removed during word splitting. When the old-style backquoted form of substitution is used, backslash retains its literal meaning except when followed by  ,  , or  .  The first backticks not preceded by a backslash terminates the command substitution.  When using the   form, all characters between the parentheses make up the command; none are treated specially. Command substitutions may be nested.  To nest when using the backquoted form, escape the inner backticks with backslashes. If the substitution appears within double quotes, word splitting and file name expansion are not performed on the results. Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.  The format for arithmetic expansion is:   The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially.  All tokens in the expression undergo parameter expansion, command substitution, and quote removal.  Arithmetic substitutions may be nested. Evaluation of arithmetic expressions is done in fixed-width integers with no check for overflow - although division by zero is trapped and recognized as an error.  The operators are roughly the same as in the C programming language.  In order of decreasing precedence, the list looks like this: Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated.  Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax.  The value of a variable is evaluated as an arithmetic expression when it is referenced.  A shell variable need not have its integer attribute turned on to be used in an expression. Constants with a leading 0 (zero) are interpreted as octal numbers.  A
leading   or   denotes hexadecimal.  Otherwise, numbers take the form  , where   is a decimal number between 2 and 64 representing the arithmetic base, and N is a number in that base.  If   is omitted, then base 10 is used.  The digits greater than 9 are represented by the lowercase letters, the uppercase letters,  , and  , in that order.  If   is less than or equal to 36, lowercase and uppercase letters may be used interchangably to represent numbers between 10 and 35. Operators are evaluated in order of precedence.  Sub-expressions in parentheses are evaluated first and may override the precedence rules above. Wherever possible, Bash users should try to use the syntax with square brackets:   However, this will only calculate the result of  , and do no tests: See  , among others, for practical examples in scripts. Process substitution is supported on systems that support named pipes (FIFOs) or the   method of naming open files.  It takes the form of   or   The process   is run with its input or output connected to a FIFO or some file in  .  The name of this file is passed as an argument to the current command as the result of the expansion.  If the   form is used, writing to the file will provide input for  .  If the   form is used, the file passed as an argument should be read to obtain the output of  .  Note that no space may appear between the < or > signs and the left parenthesis, otherwise the construct would be interpreted as a redirection. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion. More information in  . The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. The shell treats each character of   as a delimiter, and splits the results of the other expansions into words on these characters.  If   is unset, or its value is exactly  , the default, then any sequence of   characters serves to delimit words.  If   has a value other than the default, then sequences of the whitespace characters   and   are ignored at the beginning and end of the word, as long as the whitespace character is in the value of   (an   whitespace character).  Any character in   that is not   whitespace, along with any adjacent   whitespace characters, delimits a field.  A sequence of   whitespace characters is also treated as a delimiter.  If the value of   is null, no word splitting occurs. Explicit null arguments (  or  ) are retained.  Unquoted implicit null arguments, resulting from the expansion of parameters that have no values, are removed.  If a parameter with no value is expanded within double quotes, a null argument results and is retained. If no expansion occurs, no splitting is performed. After word splitting, unless the   option has been set (see  ), Bash scans each word for the characters  ,  , and  .  If one of these characters appears, then the word is regarded as a  , and replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are found, and the shell option   is disabled, the word is left unchanged.  If the   option is set, and no matches are found, the word is removed.  If the shell option   is enabled, the match is performed without regard to the case of alphabetic characters. When a pattern is used for file name generation, the character   at the start of a file name or immediately following a slash must be matched explicitly, unless the shell option   is set.  When matching a file name, the slash character must always be matched explicitly.  In other cases, the   character is not treated specially. The   shell variable may be used to restrict the set of file names matching a pattern.  If   is set, each matching file name that also matches one of the patterns in   is removed from the list of matches.  The file names   and   are always ignored, even when   is set.  However, setting   has the effect of enabling the   shell option, so all other file names beginning with a   will match.  To get the old behavior of ignoring file names beginning with a  , make   one of the patterns in  .  The   option is disabled when   is unset. An alias allows a string to be substituted for a word when it is used as the first word of a simple command.  The shell maintains a list of aliases that may be set and unset with the   and   built-in commands.  Issue the   without options to display a list of aliases known to the current shell. Aliases are useful for specifying the default version of a command that exists in several versions on your system, or to specify default options to a command.  Another use for aliases is for correcting incorrect spelling. The first word of each simple command, if unquoted, is checked to see if it has an alias.  If so, that word is replaced by the text of the alias.  The alias name and the replacement text may contain any valid shell input, including shell metacharacters, with the exception that the alias name may not contain  .  The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time.  This means that one may alias   to  , for instance, and Bash will not try to recursively expand the replacement text. If the last character of the alias value is a space or tab character, then the next command word following the alias is also checked for alias expansion. Aliases are not expanded when the shell is not interactive, unless
the   option is set using the   shell built-in. Aliases are created using the   shell built-in.  For permanent use, enter the   in one of your shell initialization files; if you just enter the alias on the command line, it is only recognized within the current shell. Bash always reads at least one complete line of input before executing any of the commands on that line.  Aliases are expanded when a command is read, not when it is executed.  Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read.  The commands following the alias definition on that line are not affected by the new alias.  This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command.  As a consequence, aliases defined in a function are not available until after that function is executed.  To be safe, always put alias definitions on a separate line, and do not use   in compound commands. Aliases are not inherited by child processes.  Bourne shell ( ) does not recognize aliases. More about functions is in  . Aliases are looked up after functions and thus resolving is slower.  While aliases are easier to understand, shell functions are preferred over aliases for almost every purpose. We already discussed a couple of Bash options that are useful for debugging your scripts.  In this section, we will take a more in-depth view of the Bash options. Use the   option to   to display all shell options: See the Bash Info pages, section  ->  for a description of each option.  A lot of options have one-character shorthands: the   option, for instance, is equal to specifying  . Shell options can either be set different from the default upon calling the shell, or be set during shell operation.  They may also be included in the shell resource configuration files. The following command executes a script in POSIX-compatible mode: For changing the current environment temporarily, or for use in a script,
we would rather use  .  Use   (dash) for enabling an option,   for disabling: The above example demonstrates the   option, which prevents existing files from being overwritten by redirection operations.  The same goes for one-character options, for instance  , which will treat unset variables as an error when set, and exits a non-interactive shell upon
encountering such errors: This option is also useful for detecting incorrect content assignment to variables: the same error will also occur, for instance, when assigning a character string to a variable that was declared explicitly as one holding only integer values. One last example follows, demonstrating the   option, which prevents special characters from being expanded: The Bash environment can be configured globally and on a per user basis.  Various configuration files are used to fine-tune the behavior of the shell. These files contain shell options, settings for variables, function definitions and various other building blocks for creating ourselves a cosy environment. Except for the reserved Bourne shell, Bash and special parameters, variable names can be chosen more or less freely. Because a lot of characters have double or even triple meanings, depending on the environment, Bash uses a system of quoting to take away special meaning from one or multiple characters when special treatment is not wanted. Bash uses various methods of expanding command line entries in order to determine which commands to execute. For this exercise, you will need to read the   man pages, because we are going to use the   directory to hold default shell configuration files, which are copied to the home directory of each newly added user. First we will do some general exercises on setting and displaying variables. Create 3 variables,  ,   and  ; initialize them to hold the values  ,   and   respectively. Display the values of all three variables. Are these local or global variables? Remove  . Can you see the two remaining variables in a new terminal window? Edit   so that all users are greeted upon login (test this). For the   account, set the prompt to something like  , preferably in a bright color such as red or pink or in reverse video mode. Make sure that newly created users also get a nice personalized prompt which informs them on which system in which directory they are working.  Test your changes by adding a new user and logging in as that user. Write a script in which you assign two integer values to two variables.  The script should calculate the surface of a rectangle which has these proportions.  It should be aired with comments and generate elegant output. Don't forget to   your scripts! In this chapter we discuss: Using regular expressions Regular expression metacharacters Finding patterns in files or output Character ranges and classes in Bash A   is a pattern that describes a set of strings.  Regular expressions are constructed analogously to arithmetic expressions by using various operators to combine smaller expressions. The fundamental building blocks are the regular expressions that match a single character.  Most characters, including all letters and digits, are regular expressions that match themselves.  Any metacharacter with special meaning may be quoted by preceding it with a backslash. A regular expression may be followed by one of several repetition operators (metacharacters): Two regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating two substrings that respectively match the concatenated subexpressions. Two regular expressions may be joined by the infix operator  ; the resulting regular expression matches any string matching either subexpression. Repetition takes precedence over concatenation, which in turn takes precedence over alternation.  A whole subexpression may be enclosed in parentheses to override these precedence rules. In basic regular expressions the metacharacters  ,  ,  ,  ,  , and   lose their special meaning; instead use the backslashed versions  ,  ,  ,  ,  , and  . Check in your system documentation whether commands using regular expressions support extended expressions.  searches the input files for lines containing a match to a given pattern list.  When it finds a match in a line, it copies the line to standard output (by default), or whatever other sort of output you have requested with options. Though   expects to do the matching on text, it has no limits on input line length other than available memory, and it can match arbitrary characters within a line.  If the final byte of an input file is not a  ,   silently supplies one.  Since newline is also a separator for the list of patterns, there is no way to match newline characters in a text. Some examples: With the first command, user   displays the lines from   containing the string  . Then she displays the line numbers containing this search string. With the third command she checks which users are not using  , but accounts with the   shell are not displayed. Then she counts the number of accounts that have   as the shell. The last command displays the lines from all the files in her home directory starting with  , excluding matches containing the string  , so as to exclude matches from   which might contain the same string, in upper or lower cases.  Note that the search is for the    , and not for the    . Now let's see what else we can do with grep, using regular expressions. We use GNU   in these examples, which supports extended regular expressions.  GNU   is the default on Linux systems.  If you are working on proprietary systems, check with the   option which version you are using.  GNU   can be downloaded from  . From the previous example, we now exclusively want to display lines starting with the string  : If we want to see which accounts have no shell assigned whatsoever, we search for lines ending in  : To check that   is exported in  , first select   lines and then search for lines starting with the string  , so as not to display   and other possible paths: Similarly,   matches the end of a word. If you want to find a string that is a separate word (enclosed by spaces), it is better use the  , as in this example where we are displaying information for the root partition: If this option is not used, all the lines from the file system table will be displayed. A   is a list of characters enclosed by   and  .  It matches any single character in that list; if the first character of the list is the caret,  , then it matches any character NOT in the list.  For example, the regular expression   matches any single digit. Within a bracket expression, a   consists of two characters separated by a hyphen.  It matches any single character that sorts between the two characters, inclusive, using the locale's collating sequence and character set.  For example, in the default C locale,   is equivalent to  .  Many locales sort characters in dictionary order, and in these locales   is typically not equivalent to  ; it might be equivalent to  , for example.  To obtain the traditional interpretation of bracket expressions, you can use the C locale by setting the   environment variable to the value  . Finally, certain named classes of characters are predefined within bracket expressions.  See the   man or info pages for more information about these predefined expressions. In the example, all the lines containing either a   or   character are displayed. Use the   for a single character match.  If you want to get a list of all five-character English dictionary words starting with   and ending in   (handy for solving crosswords): If you want to display lines containing the literal dot character, use the   option to  . For matching multiple characters, use the asterisk.  This example selects all words starting with   and ending in   from the system's dictionary: If you want to find the literal asterisk character in a file or output, use single quotes.  Cathy in the example below first tries finding the asterisk character in   without using quotes, which does not return any lines.  Using quotes, output is generated: Apart from   and regular expressions, there's a good deal of pattern matching that you can do directly in the shell, without having to use an external program. As you already know, the asterisk (*) and the question mark (?) match any string or any single character, respectively.  Quote these special characters to match them literally: But you can also use the square braces to match any enclosed character or range of characters, if pairs of characters are separated by a hyphen.  An example: This lists all files in  's home directory, starting with  ,  ,  ,  ,   or  . If the first character within the braces is   or  , any character not enclosed will be matched.  To match the dash ( ), include it as the first or last character in the set.  The sorting depends on the current locale and of the value of the   variable, if it is set.  Mind that other locales might interpret   as   if sorting is done in dictionary order.  If you want to be sure to have the traditional interpretation of ranges, force this behavior by setting   or   to  . Character classes can be specified within the square braces, using the syntax  , where CLASS is defined in the POSIX standard and has one of the values ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   or  . Some examples: When the   shell option is enabled (using the   built-in), several extended pattern matching operators are recognized.  Read more in the Bash info pages, section  -> -> -> . Regular expressions are powerful tools for selecting particular lines from files or output.  A lot of UNIX commands use regular expressions:  ,  , the   database and so on.  They can be made available in any language or application using external libraries, and they even found their way to non-UNIX systems.  For instance, regular expressions are used in the Excell spreadsheet that comes with the MicroSoft Windows Office suite.  In this chapter we got the feel of the   command, which is indispensable in any UNIX environment. The   command can do much more than the few tasks we discussed here; we only used it as an example for regular expressions.  The GNU   version comes with plenty of documentation, which you are strongly advised to read! Bash has built-in features for matching patterns and can recognize character classes and ranges. These exercises will help you master regular expressions. Display a list of all the users on your system who log in with the Bash shell as a default. From the   directory, display all lines starting with the string  . Print all the lines from the same file that don't contain the string. Display localhost information from the   file, display the line number(s) matching the search string and count the number of occurrences of the string. Display a list of   subdirectories containing information about shells. How many   files do these subdirectories contain?  Don't count anything in the form of  . Make a list of files in your home directory that were changed less that 10 hours ago, using  , but leave out directories. Put these commands in a shell script that will generate comprehensible output. Can you find an alternative for  , using  ? Using the file system table (  for instance), list local disk devices. Make a script that checks whether a user exists in  .  For now, you can specify the user name in the script, you don't have to work with arguments and conditionals at this stage. Display configuration files in   that contain numbers in their names. At the end of this chapter you will know about the following topics: What is  ? Interactive use of  Regular expressions and stream editing Using   commands in scripts   These explanations are far from complete and certainly not meant to be used as the definite user manual for  .  This chapter is only included in order to show some more interesting topics in the next chapters, and because every power user should have a basic knowledge of things that can be done with this editor. For detailed information, refer to the   info and man pages. 
 A   is used to perform basic transformations on text read from a file or a pipe.  The result is sent to standard output.  The syntax for the   command has no output file specification, but results can be saved to a file using output redirection.  The editor does not modify the original input. What distinguishes   from other editors, such as   and  , is its ability to filter text that it gets from a pipeline feed.  You do not need to interact with the editor while it is running; that is why   is sometimes called a  .  This feature allows use of editing commands in scripts, greatly easing repetitive editing tasks.  When facing replacement of text in a large number of files,   is a great help. The   program can perform text pattern substitutions and deletions using regular expressions, like the ones used with the   command; see  . The editing commands are similar to the ones used in the   editor: Apart from editing commands, you can give options to  .  An overview is in the table below: The   info pages contain more information; we only list the most frequently used commands and options here. This is something you can do with  , of course, but you can't do a   using that command.  This is just to get you started. This is our example text file: We want   to find all the lines containing our search pattern, in this case  .  We use the   to obtain the result: As you notice,   prints the entire file, but the lines containing the search string are printed twice.  This is not what we want.  In order to only print those lines matching our pattern, use the   option: We use the same example text file.  Now we only want to see the lines   containing the search string: The   command results in excluding lines from being displayed. Matching lines starting with a given pattern and ending in a second pattern are showed like this: Note that the last dot needs to be escaped in order to actually match.  In our example the expression just matches any character, including the last dot. This time we want to take out the lines containing the errors.  In the example these are lines 2 to 4.  Specify this range to address, together with the   command: To print the file starting from a certain line until the end of the file, use a command similar to this: This only prints the first two lines of the example file. The following command prints the first line containing the pattern  , up to and including the next line containing the pattern  : In the example file, we will now search and replace the errors instead of only (de)selecting the lines containing the search string. As you can see, this is not exactly the desired effect: in line 4, only the first occurrence of the search string has been replaced, and there is still an 'eror' left.  Use the   command to indicate to   that it should examine the entire line instead of stopping at the first occurrence of your string: To insert a string at the beginning of each line of a file, for instance for quoting: Insert some string at the end of each line: Multiple find and replace commands are separated with individual   options: Keep in mind that by default   prints its results to the standard output, most likely your terminal window.  If you want to save the output to a file, redirect it:   Plenty of   examples can be found in the startup scripts for your machine, which are usually in   or  .  Change into the directory containing the initscripts on your system and issue the following command:   Multiple   commands can be put in a file and executed using the   option.  When creating such a file, make sure that: No trailing white spaces exist at the end of lines. No quotes are used. When entering text to add or replace, all except the last line end in a backslash. Writing output is done using the output redirection operator  .  This is an example script used to create very simple HTML files from plain text files.  holds the first argument to a given command, in this case the name of the file to convert: More on positional parameters in  . This is not really how it is done; this example just demonstrates   capabilities.  See   for a more decent solution to this problem, using     and   constructs. Advanced editors, supporting syntax highlighting, can recognize   syntax.  This can be a great help if you tend to forget backslashes and such. The   stream editor is a powerful command line tool, which can handle streams of data: it can take input lines from a pipe.  This makes it fit for non-interactive use.  The   editor uses  -like commands and accepts regular expressions. The   tool can read commands from the command line or from a script.  It is often used to perform find-and-replace actions on lines containing a pattern. These exercises are meant to further demonstrate what   can do. Print a list of files in your   directory, ending in  .  Mind that you might have to unalias  .  Put the result in a temporary file. Make a list of files in   that have the letter   as the second character.  Put the result in a temporary file. Delete the first 3 lines of each temporary file. Print to standard output only the lines containing the pattern  . Create a file holding   commands to perform the previous two tasks.  Add an extra command to this file that adds a string like   in the line preceding every occurence of the string  .  Check the results. A long listing of the root directory,  , is used for input.  Create a file holding   commands that check for symbolic links and plain files.  If a file is a symbolic link, precede it with a line like  .  If the file is a plain file, add a string on the same line, adding a comment like  . Create a script that shows lines containing trailing white spaces from a file.  This script should use a   script and show sensible information to the user. In this chapter we will discuss: What is  ? Using   commands on the command line How to format text with  How   uses regular expressions  in scripts  and variables As with  , entire books have been written about various versions of  .  This introduction is far from complete and is only intended for understanding examples in the following chapters.  For more information, best start with the documentation that comes with  :  .  is the GNU version of the commonly available UNIX   program, another popular stream editor.  Since the   program is often just a link to  , we will refer to it as  . The basic function of   is to search files for lines or other text units containing one or more patterns.  When a line matches one of the patterns, special actions are performed on that line. Programs in   are different from programs in most other languages, because   programs are  : you describe the data you want to work with and then what to do when you
find it.  Most other languages are    You have to describe, in great detail, every step the program is to take.  When working with procedural languages, it is usually much harder to clearly describe the data your program will process.  For this reason,   programs are often refreshingly easy to read and write. Back in the 1970s, three programmers got together to create this language.  Their names were Aho, Kernighan and Weinberger.  They took the first character of each of their names and put them together.  So the name of the language might just as well have been  . When you run  , you specify an     that tells   what to do.  The program consists of a series of  .  (It may also
contain function definitions, loops, conditions and other programming constructs, advanced features that we will ignore for now.)  Each rule specifies one pattern to search for and one action to perform upon finding the pattern. There are several ways to run  .  If the program is short, it is easiest to run it on the command line:   If multiple changes have to be made, possibly regularly and on multiple files, it is easier to put the   commands in a script.  This is read like this:   The   command in   outputs selected data from the input file. When   reads a line of a file, it divides the line in fields based on the specified  ,  , which is an   variable (see  ).  This variable is predefined to be one or more spaces or tabs. The variables  ,  ,  , ...,   hold the values of the first, second, third until the last field of an input line.  The variable   (zero) holds the value of the entire line.  This is depicted in the image below, where we see six colums in the output of the   command: In the output of  , there are 9 columns.  The   statement uses these fields as follows: This command printed the fifth column of a long file listing, which contains the file size, and the last column, the name of the file.  This output is not very readable unless you use the official way of referring to columns, which is to separate the ones that you want to print with a comma.  In that case, the default output separater character, usually a space, will be put in between each output field. Note that the configuration of the output of the   command might be different on your system.  Display of time and date is dependent on your locale setting. Without formatting, using only the output separator, the output looks rather poor.  Inserting a couple of tabs and a string to indicate what output this is will make it look a lot better: Note the use of the backslash, which makes long input continue on the next line without the shell interpreting this as a separate command.  While your command line input can be of virtually unlimited length, your monitor is not, and printed paper certainly isn't.  Using the backslash also allows for copying and pasting of the above lines into a terminal window. The   option to   is used for supplying humanly readable size formats for bigger files.  The output of a long listing displaying the total amount of blocks in the directory is given when a directory is the argument.  This line is useless to us, so we add an asterisk.  We also add the   option for the same reason, in case asterisk expands to a directory. The backslash in this example marks the continuation of a line. See  . You can take out any number of columns and even reverse the order.  In the example below this is demonstrated for showing the most critical partitions: The table below gives an overview of special formatting characters: Quotes, dollar signs and other meta-characters should be escaped with a backslash. A regular expression can be used as a pattern by enclosing it in slashes.  The regular expression is then tested against the entire text of each record.  The syntax is as follows:   The following example displays only local disk device information, networked file systems are not shown: Slashes need to be escaped, because they have a special meaning to the   program. Below another example where we search the   directory for files ending in   and starting with either      , using extended regular expressions: This example illustrates the special meaning of the dot in regular expressions: the first one indicates that we want to search for any character after the first search string, the second is escaped because it is part of a string to find (the end of the file name). In order to precede output with comments, use the   statement: The   statement can be added for inserting text after the entire input is processed: As commands tend to get a little longer, you might want to put them in a script, so they are reusable.  An   script contains   statements defining patterns and actions. As an illustration, we will build a report that displays our most loaded partitions.  See  .  first prints a begin message, then formats all the lines that contain an eight or a nine at the beginning of a word, followed by one other number and a percentage sign.  An end message is added. Awk is a programming language.  Its syntax is recognized by most editors that can do syntax highlighting for other languages, such as C, Bash, HTML, etc. As   is processing the input file, it uses several variables.  Some are editable, some are read-only. The  , which is either a single character or a regular expression, controls the way   splits up an input record into fields.  The input record is scanned for character sequences that match the separator definition; the fields themselves are the text between the matches. The field separator is represented by the built-in variable  .  Note that this is something different from the   variable used by POSIX-compliant shells. The value of the field separator variable can be changed in the   program with the assignment operator  .  Often the right time to do this is at the beginning of execution before any input has been processed, so that the very first record is read with the proper separator.  To do this, use the special   pattern. In the example below, we build a command that displays all the users on your system with a description: In an   script, it would look like this: Choose input field separators carefully to prevent problems.  An example to illustrate this: say you get input in the form of lines that look like this: You write a command line or a script, which prints out the name of the person in that record:   But a person might have a PhD, and it might be written like this: Your   will give the wrong output for this line.  If needed, use an extra   or   to uniform data input formats. The default input field separator is one or more whitespaces or tabs. Fields are normally separated by spaces in the output.  This becomes apparent when you use the correct syntax for the   command, where arguments are separated by commas: If you don't put in the commas,   will treat the items to output as one argument, thus omitting the use of the default  ,  . Any character string may be used as the output field separator by setting this built-in variable. The output from an entire   statement is called an  .  Each   command results in one output record, and then outputs a string called the  ,  .  The default value for this variable is  , a newline character.  Thus, each   statement generates a separate line. To change the way output fields and records are separated, assign new values to   and  : If the value of   does not contain a newline, the program's output is run together on a single line. The built-in   holds the number of records that are processed.  It is incremented after reading a new input line.  You can use it at the end to count the total number of records, or in each output record: Apart from the built-in variables, you can define your own.  When   encounters a reference to a variable which does not exist (which is not predefined), the variable is created and initialized to a null string.  For all subsequent references, the value of the variable is whatever value was assigned last.  Variables can be a string or a numeric value.  Content of input fields can also be assigned to variables. Values can be assigned directly using the   operator, or you can use the current value of the variable in combination with other operators: C-like shorthands like   are also accepted. The example from   becomes much easier when we use an   script: And the command to execute is also much more straightforward when using   instead of  : We refer again to the directory containing the initscripts on your system.  Enter a command similar to the following to see more practical examples of the widely spread usage of the   command:   For more precise control over the output format than what is normally provided by  , use  .  The   command can be used to specify the field width to use for each item, as well as various formatting choices for numbers (such as what output base to use, whether to print an exponent, whether to print a sign, and how many digits to print after the decimal point).  This is done by supplying a string, called the  , that controls how and where to print the other arguments. The syntax is the same as for the C-language   statement; see your C introduction guide.  The   info pages contain full explanations. The   utility interprets a special-purpose programming language, handling simple data-reformatting jobs with just a few lines of code.  It is the free version of the general UNIX   command. This tools reads lines of input data and can easily recognize columned output.  The   program is the most common for filtering and formatting defined fields. On-the-fly variable declaration is straightforward and allows for simple calculation of sums, statistics and other operations on the processed input stream.  Variables and commands can be put in   scripts for background processing. Other things you should know about  : The language remains well-known on UNIX and alikes, but for executing similar tasks,   is now more commonly used.  However,   has a much steeper learning curve (meaning that you learn a lot in a very short time).  In other words,   is more difficult to learn. Both   and   share the reputation of being incomprehensible, even to the actual authors of the programs that use these languages.  So document your code! These are some practical examples where   can be useful. For the first exercise, your input is lines in the following form: Make an   script that will convert such a line to an LDAP record in this format: Create a file containing a couple of test records and check. Create a Bash script using   and standard UNIX commands that will show the top three users of disk space in the   file system (if you don't have the directory holding the homes on a separate partition, make the script for the   partition; this is present on every UNIX system).  First, execute the commands from the command line.  Then put them in a script.  The script should create sensible output (sensible as in readable by the boss).  If everything proves to work, have the script email its results to you (use for instance  ). If the quota daemon is running, use that information; if not, use  . Create XML-style output from a  -separated list in the following form: The output should read: Additionally, if you know anything about XML, write a BEGIN and END script to complete the table.  Or do it in HTML. In this chapter we will discuss the use of conditionals in Bash scripts.  This includes the following topics:   The   statement Using the exit status of a command Comparing and testing input and files  constructs  constructs Using and testing the positional parameters Nested   statements Boolean expressions Using   statements 
 At times you need to specify different courses of action to be taken in a shell script, depending on the success or failure of a command.  The   construction allows you to specify such conditions. The most compact syntax of the   command is:   The   list is executed, and if its return status is zero, the   list is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true. The   often involves numerical or string comparison tests, but it can also be any command that returns a status of zero when it succeeds and some other status when it fails.  Unary expressions are often used to examine the status of a file.  If the   argument to one of the primaries is of the form  , then file descriptor   is checked.   ,   and   and their respective file descriptors may also be used for tests. The table below contains an overview of the so-called   that make up the   command or list of commands.  These primaries are put between square brackets to indicate the test of a conditional expression. Expressions may be combined using the following operators, listed in decreasing order of precedence: The   (or  ) built-in evaluates conditional expressions using a set of rules based on the number of arguments.  More information about this subject can be found in the Bash documentation.  Just like the   is closed with  , the opening square bracket should be closed after the conditions have been listed. The   list that follows the   statement can be any valid UNIX command, any executable program, any executable shell script or any shell statement, with the exception of the closing  .  It is important to remember that the   and   are considered to be separated statements in the shell.  Therefore, when issued on the command line, they are separated by a semi-colon. In a script, the different parts of the   statement are usually well-separated.  Below, a couple of simple examples. The first example checks for the existence of a file: To add in your Bash configuration files: The above example will work when entered on the command line: However, if you use testing of conditions that depend on the environment, you might get different results when you enter the same command in a script, because the script will open a new shell, in which expected variables and options might not be set automatically. The   variable holds the exit status of the previously executed command (the most recently completed foreground process). The following example shows a simple test: The following example demonstrates that   might be any UNIX command that returns an exit status, and that   again returns an exit status of zero: The same result can be obtained as follows: The examples below use numerical comparisons: This script is executed by cron every Sunday.  If the week number is even, it reminds you to put out the garbage cans: An example of comparing strings for testing the user ID: With Bash, you can shorten this type of construct.  The compact equivalent of the above test is as follows: Similar to the   expression which indicates what to do if the test proves true,   specifies what to do if the test is false. Regular expressions may also be used in comparisons: Most programmers will prefer to use the   built-in command, which is equivalent to using square brackets for comparison, like this: If you invoke the   in a subshell, it will not pass variables to the parent.  Use { and } instead of ( and ) if you do not want Bash to fork a subshell. See the info pages for Bash for more information on pattern matching with the   and   constructs. This is the construct to use to take one course of action if the   commands test true, and another if it tests false.  An example: Contrary to  ,   prevents word splitting of variable values.  So, if  , you do not need to double quote   in a test - eventhough using quotes remains a good habit.  Also,   prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames.  Using  ,   and   interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance:  . Like the   list following the   statement, the   list following the   statement can hold any UNIX-style command that returns an exit status. Another example, extending the one from  : We switch to the   account to demonstrate the effect of the   statement - your   is usually a local account while your own user account might be managed by a central system, such as an LDAP server. Instead of setting a variable and then executing a script, it is frequently more elegant to put the values for the variables on the command line. We use the positional parameters  ,  , ...,   for this purpose.    refers to the number of command line arguments.    refers to the name of the script. The following is a simple example: Here's another example, using two arguments: The following example shows how to change the previous script so that it prints a message if more or less than 2 arguments are given: The first argument is referred to as  , the second as   and so on.  The total number of arguments is stored in  . Check out   for a more elegant way to print usage messages. This test is done in a lot of scripts, because there's no use in starting a lot of programs if you know they're not going to work: Note that the file is referred to using a variable; in this case it is the first argument to the script.  Alternatively, when no arguments are given, file locations are usually stored in variables at the beginning of a script, and their content is referred to using these variables.  Thus, when you want to change a file name in a script, you only need to do it once. The above example will fail if the value of   can be parsed as multiple words.  In that case, the   command can be fixed either using double quotes around the filename, or by using   instead of  . This is the full form of the   statement:             The   list is executed, and if its return status is zero, the   list is executed.  If
  returns a non-zero status, each   list is executed in turn, and if its exit status is zero, the corresponding   is executed and the command completes.  If   is followed by an   list, and the final command in the final   or   clause has a non-zero exit status, then   is executed.  The return status is the exit status of the last command executed, or zero if no condition tested true. This is an example that you can put in your crontab for daily execution: Inside the   statement, you can use another   statement.  You may use as many levels of nested  s as you can logically manage. This is an example testing leap years: The above script can be shortened using the Boolean operators   (&&) and   (||). We use the double brackets for testing an arithmetic expression, see  .  This is equivalent to the   statement.  You will get stuck using square brackets here, if you try something like  , because here, the square brackets don't represent an actual command by themselves. Among other editors,   is one of those supporting colour schemes according to the file format; such editors are useful for detecting errors in your code. We already briefly met the   statement in  .  It terminates execution of the entire script.  It is most often used if the input requested from the user is incorrect, if a statement did not run successfully or if some other error occurred. The   statement takes an optional argument.  This argument is the integer exit status code, which is passed back to the parent and stored in the   variable. A zero argument means that the script ran successfully.  Any other value may be used by programmers to pass back different messages to the parent, so that different actions can be taken according to failure or success of the child process.  If no argument is given to the   command, the parent shell uses the current value of the   variable. Below is an example with a slightly adapted   script, which sends its exit status back to the parent,  : This script is called upon in the next one, which therefore exports its variables   and  : As you can see, exit status codes can be chosen freely.  Existing commands usually have a series of defined codes; see the programmer's manual for each command for more information. Nested   statements might be nice, but as soon as you are confronted with a couple of different possible actions to take, they tend to confuse.  For the more complex conditionals, use the   syntax:   Each case is an expression matching a pattern.  The commands in the   for the first match are executed.  The   symbol is used for separating multiple patterns, and the   operator terminates a pattern list.  Each case plus its according commands are called a  .  Each clause must be terminated with  .  Each   statement is ended with the   statement. In the example, we demonstrate use of cases for sending a more selective warning message with the   script: Of course you could have opened your mail program to check the results; this is just to demonstrate that the script sends a decent mail with  ,   and   header lines. Many more examples using   statements can be found in your system's init script directory.  The startup scripts use   and   cases to run or stop system processes.  A theoretical example can be found in the next section. Initscripts often make use of   statements for starting, stopping and querying system services.  This is an excerpt of the script that starts  , a daemon that runs commands periodically with a frequency specified in days. The tasks to execute in each case, such as stopping and starting the daemon, are defined in functions, which are partially sourced from the   file.  See   for more explanation. In this chapter we learned how to build conditions into our scripts so that different actions can be undertaken upon success or failure of a command.  The actions can be determined using the   statement.  This allows you to perform arithmetic and string comparisons, and testing of exit code, input and files needed by the script. A simple   test often preceeds commands in a shell script in order to prevent output generation, so that the script can easily be run in the background or through the   facility.  More complex definitions of conditions are usually put in a   statement. Upon successful condition testing, the script can explicitly inform the parent using the   status.  Upon failure, any other number may be returned.  Based on the return code, the parent program can take appropriate action. Here are some ideas to get you started using   in scripts: Use an   construct that prints information about the current month.  The script should print the number of days in this month, and give information about leap years if the current month is February. Do the same, using a   statement and an alternative use of the   command. Modify   so that you get a special greeting message when you connect to your system as  . Edit the   script from   so that it requires one argument, the year.  Test that exactly one argument is supplied. Write a script called   that checks if the   and   daemons are running on your system.  If an   is running, the script should print a message like,    Use   to check on processes. Write a script that makes a backup of your home directory on a remote machine using  .  The script should report in a log file, for instance  .  If you don't have a second machine to copy the backup to, use   to test copying it to the localhost.  This requires SSH keys between the two hosts, or else you have to supply a password.  The creation of SSH keys is explained in  . Adapt the script from the first example in   to include the case of exactly 90% disk space usage, and lower than 10% disk space usage. The script should use   for the creation of the backup and   or   for compressing the   file.  Put all filenames in variables.  Put the name of the remote server and the remote directory in a variable.  This will make it easier to re-use the script or to make changes to it in the future. The script should check for the existence of a compressed archive.  If this exists, remove it first in order to prevent output generation. The script should also check for available diskspace.  Keep in mind that at any given moment you could have the data in your home directory, the data in the   file and the data in the compressed archive all together on your disk.  If there is not enough diskspace, exit with an error message in the log file. The script should clean up the compressed archive before it exits. In this chapter we will discuss how to interact with the users of our scripts:   Printing user friendly messages and explanations Catching user input Prompting for user input Using the file descriptors to read from and write to multiple files 
 Some scripts run without any interaction from the user at all.  Advantages of non-interactive scripts include: The script runs in a predictable way every time. The script can run in the background. Many scripts, however, require input from the user, or give output to the user as the script is running.  The advantages of interactive scripts are, among others: More flexible scripts can be built. Users can customize the script as it runs or make it behave in different ways. The script can report its progress as it runs. When writing interactive scripts, never hold back on comments.  A script that prints appropriate messages is much more user-friendly and can be more easily debugged.  A script might do a perfect job, but you will get a whole lot of support calls if it does not inform the user about what it is doing.  So include messages that tell the user to wait for output because a calculation is being done.  If possible, try to give an indication of how long the user will have to wait.  If the waiting should regularly take a long time when executing a certain task, you might want to consider integrating some processing indication in the output of your script. When prompting the user for input, it is also better to give too much than too little information about the kind of data to be entered.  This applies to the checking of arguments and the accompanying usage message as well. Bash has the   and   commands to provide comments for users, and although you should be familiar with at least the use of   by now, we will discuss some more examples in the next sections. The   built-in command outputs its arguments, separated by spaces and terminated with a newline character.  The return status is always zero.    takes a couple of options: : interprets backslash-escaped characters. : suppresses the trailing newline. As an example of adding comments, we will make the   and   from   a bit better: More about escape characters can be found in  .  The following table gives an overview of sequences recognized by the   command: For more information about the   command and the way it allows you to format output, see the Bash info pages.  Keep in mind that there might be differences between different versions of Bash. The   built-in command is the counterpart of the   and   commands.  The syntax of the   command is as follows:   One line is read from the standard input, or from the file descriptor supplied as an argument to the   option.  The first word of the line is assigned to the first name,  , the second word to the second name, and so on, with leftover words and their intervening separators assigned to the last name,  .  If there are fewer words read from the input stream than there are names, the remaining names are assigned empty values. The characters in the value of the   variable are used to split the input line into words or tokens; see  .  The backslash character may be used to remove any special meaning for the next character read and for line continuation. If no names are supplied, the line read is assigned to the variable  . The return code of the   command is zero, unless an end-of-file character is encountered, if   times out or if an invalid file descriptor is supplied as the argument to the   option. The following options are supported by the Bash   built-in: This is a straightforward example, improving on the   script from the previous chapter: The following example shows how you can use prompts to explain what the user should enter. Note that no output is omitted here.  The script only stores information about the people Michel is interested in, but it will always say you are added to the list, unless you are already in it. Other people can now start executing the script: After a while, the   list begins to look like this: Of course, this situation is not ideal, since everybody can edit (but not delete) Michel's files.  You can solve this problem using special access modes on the script file, see   in the Introduction to Linux guide. As you know from basic shell usage, input and output of a command may be redirected before it is executed, using a special notation - the redirection operators - interpreted by the shell.  Redirection may also be used to open and close files for the current shell execution environment. Redirection can also occur in a script, so that it can receive input from a file, for instance, or send output to a file.  Later, the user can review the output file, or it may be used by another script as input. File input and output are accomplished by integer handles that track all open files for a given process.  These numeric values are known as file descriptors.  The best known file descriptors are  ,   and  , with file descriptor numbers 0, 1 and 2, respectively.  These numbers and respective devices are reserved.  Bash can take TCP or UDP ports on networked hosts as file descriptors as well. The output below shows how the reserved file descriptors point to actual devices: Note that each process has its own view of the files under  , as it is actually a symbolic link to  . You might want to check   and   for more information about   subdirectories and the way your system handles standard file descriptors for each running process. When excuting a given command, the following steps are excuted, in order: If the standard output of a previous command is being piped to the standard input of the current command, then   is updated to target the same anonymous pipe as  . If the standard output of the current command is being piped to the standard input of the next command, then   is updated to target another anonymous pipe. Redirection for the current command is processed from left to right. Redirection   or   after a command has the effect of creating or updating the symbolic link   with the same target as the symbolic link  . The redirections   and   have the effect of creating or updating the symbolic link   with the target file. File descriptor closure   has the effect of deleting the symbolic link  . Only now is the current command executed. When you run a script from the command line, nothing much changes because the child shell process will use the same file descriptors as the parent.  When no such parent is available, for instance when you run a script using the   facility, the standard file descriptors are pipes or other (temporary) files, unless some form of redirection is used.  This is demonstrated in the example below, which shows output from a simple   script: And one with  : From the previous examples, it is clear that you can provide input and output files for a script (see   for more), but some tend to forget about redirecting errors - output which might be depended upon later on.  Also, if you are lucky, errors will be mailed to you and eventual causes of failure might get revealed.  If you are not as lucky, errors will cause your script to fail and won't be caught or sent anywhere, so that you can't start to do any worthwhile debugging. When redirecting errors, note that the order of precedence is significant.  For example, this command, issued in  will redirect standard output of the   command to the file   in  .  The command will direct both standard input and standard error to the file  .  The command directs only the standard output to the destination file, because the standard error is copied to standard output before the standard output is redirected. For convenience, errors are often redirected to  , if it is sure they will not be needed.  Hundreds of examples can be found in the startup scripts for your system. Bash allows for both standard output and standard error to be redirected to the file whose name is the result of the expansion of   with this construct:   This is the equivalent of  , the construct used in the previous set of examples.  It is also often combined with redirection to  , for instance when you just want a command to execute, no matter what output or errors it gives. The   directory contains entries named  ,  ,  , and so on.  Opening the file   is equivalent to duplicating file descriptor  .  If your system provides  ,   and  , you will see that these are equivalent to  ,   and  , respectively. The main use of the   files is from the shell.  This mechanism allows for programs that use pathname arguments to handle standard input and standard output in the same way as other pathnames.  If   is not available on a system, you'll have to find a way to bypass the problem.  This can be done for instance using a hyphen ( ) to indicate that a program should read from a pipe.  An example: The   command first reads the file  , next its standard input which is the output of the   command, and last the   file.  The special meaning of the hyphen as a command-line argument to refer to the standard input or standard output is a misconception that has crept into many programs.  There might also be problems when specifying hyphen as the first argument, since it might be interpreted as an option to the preceding command.  Using   allows for uniformity and prevents confusion: In this clean example, all output is additionally piped through   to send it to the default printer. Another way of looking at file descriptors is thinking of them as a way to assign a numeric value to a file.  Instead of using the file name, you can use the file descriptor number.  The   built-in command can be used to replace the shell of the current process or to alter the file descriptors of the current shell.  For example, it can be used to assign a file descriptor to a file.  Use   for assigning file descriptor N to   for output, and   for assigning file descriptor N to   for input.  After a file descriptor has been assigned to a file, it can be used with the shell redirection operators, as is demonstrated in the following example: Using this file descriptor might cause problems, see  , chapter 16.  You are strongly advised not to use it. The following is an example that shows how you can alternate between file input and command line input: Since child processes inherit open file descriptors, it is good practice to close a file descriptor when it is no longer needed.  This is done using the   syntax.  In the above example, file descriptor 7, which has been assigned to standard input, is closed each time the user needs to have access to the actual standard input device, usually the keyboard. The following is a simple example redirecting only standard error to a pipe: Frequently, your script might call on another program or script that requires input.  The   document provides a way of instructing the shell to read input from the current source until a line containing only the search string is found (no trailing blanks).  All of the lines read up to that point are then used as the standard input for a command. The result is that you don't need to call on separate files; you can use shell-special characters, and it looks nicer than a bunch of  's: Although we talk about a  , it is supposed to be a construct within the same script.  This is an example that installs a package automatically, eventhough you should normally confirm: And this is how the script runs.  When prompted with the   string, the script answers   automatically: In this chapter, we learned how to provide user comments and how to prompt for user input.  This is usually done using the  /  combination.  We also discussed how files can be used as input and output using file descriptors and redirection, and how this can be combined with getting input from the user. We stressed the importance of providing ample message for the users of our scripts.  As always when others use your scripts, it is better to give too much information than not enough.    documents is a type of shell construct that allows creation of lists, holding choices for the users.  This construct can also be used to execute otherwise interactive tasks in the background, without intervention. These exercises are practical applications of the constructs discussed in this chapter.  When writing the scripts, you may test by using a test directory that does not contain too much data.  Write each step, then test that portion of code, rather than writing everything at once. Write a script that asks for the user's age.  If it is equal to or higher than 16, print a message saying that this user is allowed to drink alcohol.  If the user's age is below 16, print a message telling the user how many years he or she has to wait before legally being allowed to drink. As an extra, calculate how much beer an 18+ user has drunk statistically (100 liters/year) and print this information for the user. Write a script that takes one file as an argument.  Use a   document that presents the user with a couple of choices for compressing the file.  Possible choices could be  ,  ,   and  .  Write a script called   that automates   so the person executing the script always uses the desired options ( ) and backup destination directory ( ) to make a backup of his or her home directory.  Implement the following features: Test for the number of arguments.  The script should run without arguments.  If any arguments are present, exit after printing a usage message. Determine whether the   directory has enough free space to hold the backup. Ask the user whether a full or an incremental backup is wanted.  If the user does not have a full backup file yet, print a message that a full backup will be taken.  In case of an incremental backup, only do this if the full backup is not older than a week. Compress the backup using any compression tool.  Inform the user that the script is doing this, because it might take some time, during which the user might start worrying if no output appears on the screen. Print a message informing the user about the size of the compressed backup. See   or  , chapter 9:   for background information. Write a script called   that adds a local user to the system.  This script should: Take only one argument, or else exit after printing a usage message. Check   and decide on the first free user ID.  Print a message containing this ID. Create a private group for this user, checking the   file.  Print a message containing the group ID. Gather information from the operator user: a comment describing this user, choice from a list of shells (test for acceptability, else exit printing a message), expiration date for this account, extra groups of which the new user should be a member. With the obtained information, add a line to  ,   and  ; create the user's home directory (with correct permissions!); add the user to the desired secondary groups. Set the password for this user to a default known string. Rewrite the script from   so that it reads input from the user instead of taking it from the first argument. Upon completion of this chapter, you will be able to   Use  ,   and   loops, and decide which loop fits which occasion. Use the   and   Bash built-ins. Write scripts using the   statement. Write scripts that take a variable number of arguments. The   loop is the first of the three shell looping constructs.  This loop allows for specification of a list of values.  A list of commands is executed for each value in the list. The syntax for this loop is:   If   is not present, it is replaced with   and   executes the   once for each positional parameter that is set (see   and  ). The return status is the exit status of the last command that executes.  If no commands are executed because   does not expand to any items, the return status is zero.  can be any variable name, although   is used very often.    can be any list of words, strings or numbers, which can be literal or generated by any command.  The   to execute can also be any operating system commands, script, program or shell statement.  The first time through the loop,   is set to the first item in  .  The second time, its value is set to the second item in the list, and so on.  The loop terminates when   has taken on each of the values from   and no items are left in  . The first is a command line example, demonstrating the use of a   loop that makes a backup copy of each   file.  After issuing the command, it is safe to start working on your sources: This one lists the files in   that are just plain text files, and possibly scripts: The following is a specific application script for converting HTML files, compliant with a certain scheme, to PHP files.  The conversion is done by taking out the first 25 and the last 21 lines, replacing these with two PHP tags that provide header and footer lines: Since we don't do a line count here, there is no way of knowing the line number from which to start deleting lines until reaching the end.  The problem is solved using  , which reverses the lines in a file. Instead of using   to replace the   suffix with  , it would be cleaner to use the   command.  Read the man page for more info. You will run into problems if the list expands to file names containing spaces and other irregular characters.  A more ideal construct to obtain the list would be to use the shell's globbing feature, like this: The   construct allows for repetitive execution of a list of commands, as long as the command controlling the   loop executes successfully (exit status of zero).  The syntax is:    can be any command(s) that can exit with a success or failure status.  The   can be any program, script or shell construct. As soon as the   fails, the loop exits.  In a script, the command following the   statement is executed. The return status is the exit status of the last   command, or zero if none was executed. Here is an example for the impatient: The example below was written to copy pictures that are made with a webcam to a web directory.  Every five minutes a picture is taken.  Every hour, a new directory is created, holding the images for that hour.  Every day, a new directory is created containing 24 subdirectories.  The script runs in the background. Note the use of the   statement.  This means: continue execution until we are forcibly interrupted (with   or  + ). This small script can be used for simulation testing; it generates files: Note the use of the   command to generate all kinds of file and directory names.  See the man page for more. The previous example is for the sake of demonstration.  Regular checks can easily be achieved using the system's   facility.  Do not forget to redirect output and errors when using scripts that are executed from your crontab! This script can be interrupted by the user when a  +  sequence is entered: A   document is used to present the user with possible choices.  And again, the   test repeats the commands from the   list over and over again. This script calculates the average of user input, which is tested before it is processed: if input is not within range, a message is printed.  If   is pressed, the loop exits: Note how the variables in the last lines are left unquoted in order to do arithmetic. The   loop is very similar to the   loop, except that the loop executes until the   executes successfully.  As long as this command fails, the loop continues.  The syntax is the same as for the   loop:   The return status is the exit status of the last command executed in the   list, or zero if none was executed.    can, again, be any command that can exit with a success or failure status, and   can be any UNIX command, script or shell construct. As we already explained previously, the   may be replaced with one or more newlines wherever it appears. An improved   script (see  ), which tests for available disk space.  If not enough disk space is available, remove pictures from the previous months: Note the initialization of the   and   variables and the use of options with   and   in order to obtain a correct listing for  . Instead of controlling a loop by testing the result of a command or by user input, you can specify a file from which to read input that controls the loop.  In such cases,   is often the controlling command.  As long as input lines are fed into the loop, execution of the loop commands continues.  As soon as all the input lines are read the loop exits. Since the loop construct is considered to be one command structure (such as  ), the redirection should occur after the   statement, so that it complies with the form   This kind of redirection also works with other kinds of loops. In the example below, output of the   command is used as input for the   command controlling a   loop: Files are compressed before they are moved into the archive directory. The   statement is used to exit the current loop before its normal ending.  This is done when you don't know in advance how many times the loop will have to execute, for instance because it is dependent on user input. The example below demonstrates a   loop that can be interrupted.  This is a slightly improved version of the   script from  . Mind that   exits the loop, not the script.  This can be demonstrated by adding an   command at the end of the script.  This   will also be executed upon input that causes   to be executed (when the user types  ). In nested loops,   allows for specification of which loop to exit.  See the Bash   pages for more. The   statement resumes iteration of an enclosing  ,  ,   or   loop. When used in a   loop, the controlling variable takes on the value of the next element in the list.  When used in a   or   construct, on the other hand, execution resumes with   at the top of the loop. In the following example, file names are converted to lower case.  If no conversion needs to be done, a   statement restarts execution of the loop.  These commands don't eat much system resources, and most likely, similar problems can be solved using   and  .  However, it is useful to know about this kind of construction when executing heavy jobs, that might not even be necessary when tests are inserted at the correct locations in a script, sparing system resources. This script has at least one disadvantage: it overwrites existing files.  The   option to Bash is only useful when redirection occurs.  The   option to the   command provides more security, but is only safe in case of one accidental overwrite, as is demonstrated in this test: The   is part of the   package; it can perform all kinds of character transformations. The   construct allows easy menu generation.  The syntax is quite similar to that of the   loop:    is expanded, generating a list of items.  The expansion is printed to standard error; each item is preceded by a number.  If   is not present, the positional parameters are printed, as if   would have been specified.    is only printed once. Upon printing all the items, the   prompt is printed and one line from standard input is read.  If this line consists of a number corresponding to one of the items, the value of   is set to the name of that item.  If the line is empty, the items and the   prompt are displayed again.  If an   (End Of File) character is read, the loop exits.  Since most users don't have a clue which key combination is used for the EOF sequence, it is more user-friendly to have a   command as one of the items.  Any other value of the read line will set   to be a null string. The read line is saved in the   variable. The   are executed after each selection until the number representing the   is read.  This exits the loop. This is a very simple example, but as you can see, it is not very user-friendly: Setting the   prompt and adding a possibility to quit makes it better: Any statement within a   construct can be another   loop, enabling (a) submenu(s) within a menu. By default, the   variable is not changed when entering a nested   loop.  If you want a different prompt in the submenu, be sure to set it at the appropriate time(s). The   command is one of the Bourne shell built-ins that comes with Bash.  This command takes one argument, a number.  The positional parameters are shifted to the left by this number,  .  The positional parameters from   to   are renamed to variable names from   to  . Say you have a command that takes 10 arguments, and N is 4, then   becomes  ,   becomes   and so on.    becomes   and the original  ,   and   are thrown away. If N is zero or greater than  , the positional parameters are not changed (the total number of arguments, see  ) and the command has no effect.  If N is not present, it is assumed to be 1.  The return status is zero unless N is greater than   or less than zero; otherwise it is non-zero. A shift statement is typically used when the number of arguments to a command is not known in advance, for instance when users can give as many arguments as they like.  In such cases, the arguments are usually processed in a   loop with a test condition of  .  This condition is true as long as the number of arguments is greater than zero.  The   variable and the   statement process each argument.  The number of arguments is reduced each time   is executed and eventually becomes zero, upon which the   loop exits. The example below,  , uses   statements to process each file in the list generated by  : The above   command can be replaced with the following:   The   command builds and executes command lines from standard input.  This has the advantage that the command line is filled until the system limit is reached.  Only then will the command to execute be called, in the above example this would be  .  If there are more arguments, a new command line will be used, until that one is full or until there are no more arguments.  The same thing using   calls on the command to execute on the found files every time a file is found.  Thus, using   greatly speeds up your scripts and the performance of your machine. In the next example, we modified the script from   so that it accepts multiple packages to install at once: In this chapter, we discussed how repetitive commands can be incorporated in loop constructs.  Most common loops are built using the  ,   or   statements, or a combination of these commands.  The   loop executes a task a defined number of times.  If you don't know how many times a command should execute, use either   or   to specify when the loop should end. Loops can be interrupted or reiterated using the   and   statements. A file can be used as input for a loop using the input redirection operator, loops can also read output from commands that is fed into the loop using a pipe. The   construct is used for printing menus in interactive scripts.  Looping through the command line arguments to a script can be done using the   statement. Remember: when building scripts, work in steps and test each step before incorporating it in your script. Create a script that will take a (recursive) copy of files in   so that a beginning system administrator can edit files without fear. Write a script that takes exactly one argument, a directory name.  If the number of arguments is more or less than one, print a usage message.  If the argument is not a directory, print another message.  For the given directory, print the five biggest files and the five files that were most recently modified. Can you explain why it is so important to put the variables in between double quotes in the example from  ? Write a script similar to the one in  , but think of a way of quitting after the user has executed 3 loops. Think of a better solution than   for the script from   to prevent overwriting of existing files.  For instance, test whether or not a file exists.  Don't do unnecessary work! Rewrite the   script from  , so that it: Prints a list of servers to check, such as Apache, the SSH server, the NTP daemon, a name daemon, a power management daemon, and so on. For each choice the user can make, print some sensible information, like the name of the web server, NTP trace information, and so on. Optionally, build in a possibility for users to check other servers than the ones listed.  For such cases, check that at least the given process is running. Review the script from  .  Note how character input other than   is processed.  Rebuild this script so that it prints a message if characters are given as input. In this chapter, we will discuss the advanced use of variables and arguments.  Upon completion, you will be able to:   Declare and use an array of variables Specify the sort of variable you want to use Make variables read-only Use   to assign a value to a variable 
 As we already saw, Bash understands many different kinds of variables or parameters.  Thus far, we haven't bothered much with what kind of variables we assigned, so our variables could hold any value that we assigned to them.  A simple command line example demonstrates this: There are cases when you want to avoid this kind of behavior, for instance when handling telephone and other numbers.  Apart from integers and variables, you may also want to specify a variable that is a constant.  This is often done at the beginning of a script, when the value of the constant is declared.  After that, there are only references to the constant variable name, so that when the constant needs to be changed, it only has to be done once.  A variable may also be a series of variables of any type, a so-called   of variables ( ,  , ...  ). Using a   statement, we can limit the value assignment to variables. The syntax for   is the following:   The following options are used to determine the type of data the variable can hold and to assign it attributes: Using   instead of   turns off the attribute instead.  When used in a function,   creates local variables. The following example shows how assignment of a type to a variable influences the value. Note that Bash has an option to declare a numeric value, but none for declaring string values.  This is because, by default, if no specifications are given, a variable can hold any type of data: As soon as you restrict assignment of values to a variable, it can only hold that type of data.  Possible restrictions are either integer, constant or array. See the Bash info pages for information on return status. In Bash, constants are created by making a variable read-only.  The   built-in marks each specified variable as unchangeable.  The syntax is:   The values of these variables can then no longer be changed by subsequent assignment.  If the   option is given, each variable refers to a shell function; see  .  If   is specified, each variable refers to an array of variables.  If no arguments are given, or if   is supplied, a list of all read-only variables is displayed.  Using the   option, the output can be reused as input. The return status is zero, unless an invalid option was specified, one of the variables or functions does not exist, or   was supplied for a variable name instead of for a function name. An array is a variable containing multiple values.  Any variable may be used as an array.  There is no maximum limit to the size of an array, nor any requirement that member variables be indexed or assigned contiguously.  Arrays are zero-based: the first element is indexed with the number 0. Indirect declaration is done using the following syntax to declare a variable:   The   is treated as an arithmetic expression that must evaluate to a positive number. Explicit declaration of an array is done using the   built-in:   A declaration with an index number will also be accepted, but the index number will be ignored.  Attributes to the array may be specified using the   and   built-ins.  Attributes apply to all variables in the array; you can't have mixed arrays. Array variables may also be created using compound assignments in this format:   Each value is then in the form of  .  The index number is optional.  If it is supplied, that index is assigned to it; otherwise the index of the element assigned is the number of the last index that was assigned, plus one.  This format is accepted by   as well.  If no index numbers are supplied, indexing starts at zero. Adding missing or extra members in an array is done using the syntax:   Remember that the   built-in provides the   option, which allows for reading and assigning values for member variables of an array. In order to refer to the content of an item in an array, use curly braces.  This is necessary, as you can see from the following example, to bypass the shell interpretation of expansion operators.  If the index number is   or  , all members of an array are referenced. Referring to the content of a member variable of an array without providing an index number is the same as referring to the content of the first element, the one referenced with index number zero. The   built-in is used to destroy arrays or member variables of an array: Practical examples of the usage of arrays are hard to find.  You will find plenty of scripts that don't really do anything on your system but that do use arrays to calculate mathematical series, for instance.  And that would be one of the more interesting examples...most scripts just show what you can do with an array in an oversimplified and theoretical way. The reason for this dullness is that arrays are rather complex structures.  You will find that most practical examples for which arrays could be used are already implemented on your system using arrays, however on a lower level, in the C programming language in which most UNIX commands are written.  A good example is the Bash   built-in command.  Those readers who are interested might check the   directory in the Bash source tree and take a look at  , which is processed when compiling the built-ins. Another reason good examples are hard to find is that not all shells support arrays, so they break compatibility. After long days of searching, I finally found this example operating at an Internet provider.  It distributes Apache web server configuration files onto hosts in a web farm: First two tests are performed to check whether the correct user is running the script with the correct arguments.  The names of the hosts that need to be configured are listed in the array  .  Then all these hosts are provided with the Apache configuration file, after which the daemon is restarted.  Note the use of commands from the Secure Shell suite, encrypting the connections to remote hosts. Thanks, Eugene and colleague, for this contribution. Dan Richter contributed the following example.  This is the problem he was confronted with: And this was his way of solving it: This script is then used in other scripts, such as this one, which uses a   document: We discussed this already in  . Using the   syntax will calculate the number of characters in a variable.  If   is   or  , this value is substituted with the number of positional parameters or number of elements in an array in general.  This is demonstrated in the example below:   If   is not defined or null, the expansion of   is substituted; otherwise the value of   is substituted: This form is often used in conditional tests, for instance in this one: It is a shorter notation for See   for more information about this type of condition testing. If the hyphen (-) is replaced with the equal sign (=), the value is assigned to the parameter if it does not exist: The following syntax tests the existence of a variable.  If it is not set, the expansion of   is printed to standard out and non-interactive shells quit.  A demonstration: Using   instead of the exclamation mark sets the variable to the expansion of  ; if it does not exist, nothing happens. To strip a number of characters, equal to  , from a variable, use this syntax:   The   parameter defines how many characters to keep, starting from the first character after the offset point.  If   is omitted, the remainder of the variable content is taken:   and   These constructs are used for deleting the pattern matching the expansion of   in  .    is expanded to produce a pattern just as in file name expansion.  If the pattern matches the beginning of the expanded value of  , then the result of the expansion is the expanded value of   with the shortest matching pattern ( ) or the longest matching pattern (indicated with  ). If   is   or  , the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If   is an array variable subscribed with   or  , the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.  This is shown in the examples below: The opposite effect is obtained using   and  , as in this example below.    should match a trailing portion of string: This is done using the   or   syntax.  The first form replaces only the first match, the second replaces all matches of   with  : More information can be found in the Bash info pages. Normally, a variable can hold any type of data, unless variables are declared explicitly.  Constant variables are set using the   built-in command. An array holds a set of variables.  If a type of data is declared, then all elements in the array will be set to hold only this type of data. Bash features allow for substitution and transformation of variables  .  Standard operations include calculating the length of a variable, arithmetic on variables, substituting variable content and substituting part of the content. Here are some brain crackers: Write a script that does the following: Display the name of the script being executed. Display the first, third and tenth argument given to the script. Display the total number of arguments passed to the script. If there were more than three positional parameters, use   to move all the values 3 places to the left. Print all the values of the remaining arguments. Print the number of arguments. Test with zero, one, three and over ten arguments. Write a script that implements a simple web browser (in text mode), using   and   to display HTML pages to the user.  The user has 3 choices: enter a URL, enter   for back and   to quit.  The last 10 URLs entered by the user are stored in an array, from which the user can restore the URL by using the   functionality. In this chapter, we will discuss 
 What functions are Creation and displaying of functions from the command line Functions in scripts Passing arguments to functions When to use functions 
 Shell functions are a way to group commands for later execution, using a single name for this group, or  .  The name of the routine must be unique within the shell or script.  All the commands that make up a function are executed like regular commands.  When calling on a function as a simple command name, the list of commands associated with that function name is executed.  A function is executed within the shell in which it has been declared: no new process is created to interpret the commands. Special built-in commands are found before shell functions during command lookup.  The special built-ins are:  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,   and  . Functions either use the syntax   or   Both define a shell function  .  The use of the built-in command   is optional; however, if it is not used, parentheses are needed. The commands listed between curly braces make up the body of the function.  These commands are executed whenever   is specified as the name of a command.  The exit status is the exit status of the last command executed in the body. The curly braces must be separated from the body by spaces, otherwise they are interpreted in the wrong way. The body of a function should end in a semicolon or a newline. Functions are like mini-scripts: they can accept parameters, they can use variables only known within the function (using the   shell built-in) and they can return values to the calling shell. A function also has a system for interpreting positional parameters.  However, the positional parameters passed to a function are not the same as the ones passed to a command or script. When a function is executed, the arguments to the function become the positional parameters during its execution.  The special parameter   that expands to the number of positional parameters is updated to reflect the change. Positional parameter   is unchanged.  The Bash variable   is set to the name of the function, while it is executing. If the   built-in is executed in a function, the function completes and execution resumes with the next command after the function call.  When a function completes, the values of the positional parameters and the special parameter   are restored to the values they had prior to the function's execution.  If a numeric argument is given to  , that status is returned.  A simple example: Note that the return value or exit code of the function is often storen in a variable, so that it can be probed at a later point.  The init scripts on your system often use the technique of probing the   variable in a conditional test, like this one: Or like this example from the   script, where Bash's optimization features are used: The commands after   are only executed when the test proves to be true; this is a shorter way to represent an   structure. The return code of the function is often used as exit code of the entire script.  You'll see a lot of initscripts ending in something like  . All functions known by the current shell can be displayed using the   built-in without options.  Functions are retained after they are used, unless they are   after use.  The   command also displays functions: This is the sort of function that is typically configured in the user's shell resource configuration files.  Functions are more flexible than aliases and provide a simple and easy way of adapting the user environment. Here's one for DOS users: There are plenty of scripts on your system that use functions as a structured way of handling series of commands.  On some Linux systems, for instance, you will find the   definition file, which is sourced in all init scripts.  Using this method, common tasks such as checking if a process runs, starting or stopping a daemon and so on, only have to be written once, in a general way.  If the same task is needed again, the code is recycled. You could make your own   file that contains all functions that you use regularly on your system, in different scripts.  Just put the line    somewhere at the start of the script and you can recycle functions. This section might be found in your   file.  The function   is defined and then used to set the path for the   and other users: The function takes its first argument to be a path name.  If this path name is not yet in the current path, it is added.  The second argument to the function defines if the path will be added in front or after the current   definition. Normal users only get   added to their paths, while   gets a couple of extra directories containing system commands.  After being used, the function is unset so that it is not retained. The following example is one that I use for making backups of the files for my books.  It uses SSH keys for enabling the remote connection.  Two functions are defined,   and  , that each make a   file, which is then compressed and sent to a remote server.  After that, the local copy is cleaned up. On Sunday, only   is executed. This script runs from cron, meaning without user interaction, so we redirect standard error from the   command to  . It might be argued that all the separate steps can be combined in a command such as   However, if you are interested in intermediate results, which might be recovered upon failure of the script, this is not what you want. The expression   is equivalent to   Functions provide an easy way of grouping commands that you need to execute repetitively.  When a function is running, the positional parameters are changed to those of the function.  When it stops, they are reset to those of the calling program.  Functions are like mini-scripts, and just like a script, they generate exit or return codes. While this was a short chapter, it contains important knowledge needed for achieving the ultimate state of laziness that is the typical goal of any system administrator. Here are some useful things you can do using functions: Add a function to your   config file that automates the printing of man pages.  The result should be that you type something like  , upon which the first appropriate man page rolls out of your printer.  Check using a pseudo printer device for testing purposes. As an extra, build in a possibility for the user to supply the section number of the man page he or she wants to print. Create a subdirectory in your home directory in which you can store function definitions.  Put a couple of functions in that directory.  Useful functions might be, amongs others, that you have the same commands as on DOS or a commercial UNIX when working with Linux, or vice versa.  These functions should then be imported in your shell environment when   is read. In this chapter, we will discuss the following subjects:   Available signals Use of the signals Use of the   statement How to prevent users from interrupting your programs 
 Your system contains a man page listing all the available signals, but depending on your operating system, it might be opened in a different way.  On most Linux systems, this will be  .  When in doubt, locate the exact man page and section using commands like   or   Signal names can be found using  . In the absence of any traps, an interactive Bash shell ignores   and  .    is caught and handled, and if job control is active,  ,   and   are also ignored.  Commands that are run as the result of a command substitution also ignore these signals, when keyboard generated.  by default exits a shell.  An interactive shell will send a   to all jobs, running or stopped; see the documentation on the   built-in if you want to disable this default behavior for a particular process.  Use the   option for killing all jobs upon receiving a   signal, using the   built-in. The following signals can be sent using the Bash shell: Check your   settings.  Suspend and resume of output is usually disabled if you are using   terminal emulations.  The standard   supports  +  and  +  by default. Most modern shells, Bash included, have a built-in   function.  In Bash, both signal names and numbers are accepted as options, and arguments may be job or process IDs.  An exit status can be reported using the   option: zero when at least one signal was successfully sent, non-zero if an error occurred. Using the   command from  , your system might enable extra options, such as the ability to kill processes from other than your own user ID and specifying processes by name, like with   and  . Both   commands send the   signal if none is given. This is a list of the most common signals:  and   can not be caught, blocked or ignored. When killing a process or series of processes, it is common sense to start trying with the least dangerous signal,  .  That way, programs that care about an orderly shutdown get the chance to follow the procedures that they have been designed to execute when getting the   signal, such as cleaning up and closing open files.  If you send a   to a process, you remove any chance for the process to do a tidy cleanup and shutdown, which might have unfortunate consequences. But if a clean termination does not work, the   or  signals might be the only way.  For instance, when a process does not die using  + , it is best to use the   on that process ID: When a process starts up several instances,   might be easier.  It takes the same option as the   command, but applies on all instances of a given process.  Test this command before using it in a production environment, since it might not work as expected on some of the commercial Unices. There might be situations when you don't want users of your scripts to exit untimely using keyboard abort sequences, for example because input has to be provided or cleanup has to be done.  The   statement catches these sequences and can be programmed to execute a list of commands upon catching those signals. The syntax for the   statement is straightforward:   This instructs the   command to catch the listed  , which may be signal names with or without the   prefix, or signal numbers.  If a signal is   or  , the   are executed when the shell exits.  If one of the signals is  , the list of   is executed after every simple command.  A signal may also be specified as  ; in that case   are executed each time a simple command exits with a non-zero status.  Note that these commands will not be executed when the non-zero exit status comes from part of an   statement, or from a   or   loop.  Neither will they be executed if a logical   (&&) or   (||) result in a non-zero exit code, or when a command's return status is inverted using the   operator. The return status of the   command itself is zero unless an invalid signal specification is encountered.  The   command takes a couple of options, which are documented in the Bash info pages. Here is a very simple example, catching  +  from the user, upon which a message is printed.  When you try to kill this program without specifying the   signal, nothing will happen: When Bash receives a signal for which a trap has been set while waiting for a command to complete, the trap will not be executed until the command completes.  When Bash is waiting for an asynchronous command via the   built-in, the reception of a signal for which a trap has been set will cause the   built-in to return immediately with an exit status greater than 128, immediately after which the trap is executed. When debugging longer scripts, you might want to give a variable the   attribute and trap   messages for that variable.  Normally you would just declare a variable using an assignment like  .  Replacing the declaration of the variable with the following lines might provide valuable information about what your script is doing: The   command relies on a database which is regularly built using the   script with cron: Signals can be sent to your programs using the   command or keyboard shortcuts.  These signals can be caught, upon which action can be performed, using the   statement. Some programs ignore signals.  The only signal that no program can ignore is the   signal. A couple of practical examples: Create a script that writes a boot image to a diskette using the   utility.  If the user tries to interrupt the script using  + , display a message that this action will make the diskette unusable. Write a script that automates the installation of a third-party package of your choice.  The package must be downloaded from the Internet.  It must be decompressed, unarchived and compiled if these actions are appropriate.  Only the actual installation of the package should be uninterruptable. This document gives an overview of common shell features (the same in every shell flavour) and differing shell features (shell specific features). The following features are standard in every shell.  Note that the stop, suspend, jobs, bg and fg commands are only available on systems that support job control.
 The table below shows major differences between the standard shell ( ), Bourne Again SHell ( ), Korn shell ( ) and the C shell ( ). Since the Bourne Again SHell is a superset of  , all   commands will also work in   - but not vice versa.    has many more features of its own, and, as the table below demonstrates, many features incorporated from other shells. Since the Turbo C shell is a superset of  , all   commands will work in  , but not the other way round. The Bourne Again SHell has many more features not listed here.  This table is just to give you an idea of how this shell incorporates all useful ideas from other shells: there are no blanks in the column for  .  More information on features found only in Bash can be retrieved from the Bash info pages, in the   section. More information: You should at least read one manual, being the manual of your shell.  The preferred choice would be  ,   being the GNU shell and easiest for beginners.  Print it out and take it home, study it whenever you have 5 minutes. This section contains an alphabetical overview of common UNIX commands.  More information about the usage can be found in the man or info pages. Format files for printing on a PostScript printer. PDF viewer. Create a new user or update default new user information. Create a shell alias for a command. Execute commands periodically, does not assume continuously running machine. Search the whatis database for strings. APT package handling utility. Spell checker. Queue, examine or delete jobs for later execution. Adjust audio mixer. Pattern scanning and processing language. Bourne Again SHell. Queue, examine or delete jobs for later execution. Run a job in the background. Bitmap editor and converter utilities for the X window System. A block-sorting file compressor. Concatenate files and print to standard output. Change directory. An interactive text-mode program for controlling and playing
       audio CD Roms under Linux. An audio CD reading utility which
       includes extra data verification features. Record a CD-R. Change file attributes. Change group ownership. Update or query run level information for system services. Change file access permissions. Change file owner and group. Compress files. Copy files and directories. Maintain crontab files. Open a C shell. Remove sections from each line of file(s). Print or set system date and time. Convert and copy a file (disk dump). Report file system disk usage. DHCP client daemon. Find differences between two files. Send domain name query packets to name servers. Print or control the kernel ring buffer. Estimate file space usage. Display a line of text. Diff to English translator. Extended grep. Unmount and eject removable media. Start the Emacs editor. Invoke subprocess(es). Exit current shell. Add function(s) to the shell environment. Convert a TIFF facsimile to PostScript. Format floppy disk. Partition table manipulator for Linux. Fetch mail from a POP, IMAP, ETRN or ODMR-capable server. Bring a job in the foreground. Determine file type. Find files. Mail (re)formatter. Print a random, hopefully interesting adage. Transfer files (unsafe unless anonymous account is used!)services. Graphical web browser. Gnome Display Manager. Control console devices. Image manipulation program. Print lines matching a pattern. The grub shell. A PostScript and PDF viewer. Compress or expand files. Stop the system. Output the first part of files. Display help on a shell built-in command. DNS lookup utility. Apache hypertext transfer protocol server. Print real and effective UIDs and GIDs. Configure network interface or show configuration. Read Info documents. Process control initialization. Display I/O statistics. Display/change network interface status. IP firewall administration. IP packet filter administration. Java archive tool. List backgrounded tasks. Desktop manager for KDE. Terminate process(es). Open a Korn shell. Modify an LDAP entry. LDAP search tool.  with features. Linux boot loader. Text mode WWW browser. Make links between files. Load keyboard translation tables. Find files. Close current shell. Send requests to the LP print service. Line printer control program. Print spool queue examination program. Offline print. Remove print requests. List directory content. Text mode WWW browser. Send and receive mail. Read man pages. Copy MSDOS files to/from Unix. Display an MSDOS directory. Display memory usage. Display memory usage statistics. Control write access to your terminal. Add an MSDOS file system to a low-level formatted floppy disk. Creates a stand-alone boot floppy for the running system. Create directory. Create a hybrid ISO9660 filesystem. Filter for displaying text one screen at the time. Mount a file system or display information about mounted file systems. Web browser. Control magnetic tape drive operation. Network diagnostic tool. Rename files. Internet domain name server. Browser program for ftp services (insecure!). Print network connections, routing tables, interface statistics, masquerade connections, and multi-cast memberships. Print statistics about networked file systems. Run a program with modified scheduling priority. Network exploration tool and security scanner. Simple interface for configuring run levels. Change password. Ghostscript PDF to PostScript translator. Practical Extraction and Report Language. Page through text output. Send echo request to a host. Convert text files for printing. Print all or part of environment. Autonomous mail processor. Report process status. Display a tree of processes. Print present working directory. Display disk usage and limits. Remote copy (unsafe!) Remote Desktop Protocol client. Stop and restart the system. Alter priority of a running process. Remote login (telnet, insecure!). Remove a file. Remove a directory. RPM Package Manager. Remote shell (insecure!). Secure remote copy. Screen manager with VT100 emulation. Display, set or change variable. Set terminal attributes. Secure (encrypted) ftp. Open a standard shell. Bring the system down. Wait for a given period. Security Enhanced version of the GNU Locate. text mode Usenet client. Network intrusion detection tool. Sort lines of text files. Secure shell. Authentication key generation. Change and print terminal line settings. Switch user. Concatenate and print files in reverse. Output the last part of files. Talk to a user. Archiving utility. Open a Turbo C shell. User interface to the TELNET protocol (insecure!). Text formatting and typesetting. Time a simple command or give resource usage. News reading program. Display top CPU processes. Change file timestamps. Print the route packets take to network host. A file integrity checker for UNIX systems. Tab Window Manager for the X Window System. Controll resources. Set user file creation mask. Unmount a file system. Decompress compressed files. Remove duplicate lines from a sorted file. Kernel daemon to flush dirty buffers back to disk. Display system uptime and average load. Delete a user account and related files. Start the vi (improved) editor. The Vim tutor. Report virtual memory statistics. Show who is logged on and what they are doing. Send a message to everybody's terminal. Print the number of bytes, words and lines in files. Shows the full path of (shell) commands. Show who is logged on. Print effective user ID. Query a whois or nicname database. Send a message to another user. X authority file utility. Graphical front end to cdrecord. Analog/digital clock for X. Monitor system console messages with X. X Display Manager with support for XDMCP, host chooser. DVI viewer. X font server. Server access control program for X The extended Internet services daemon. System load average display for X. Server font list displayer for X. Audio player for X. PDF viewer. Terminal emulator for X. Compress or expand files. Search possibly compressed files for a regular expression. Filter for viewing compressed text. ,  The C shell,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  Korn shell,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  